<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Veränderbarkeit - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="Einführung.html"><strong>1.</strong> Einführung</a></li><li><a href="Erste_Schritte.html"><strong>2.</strong> Erste Schritte</a></li><li><ul class="section"><li><a href="Rust_Installieren.html"><strong>2.1.</strong> Rust installieren</a></li><li><a href="Hallo_Welt.html"><strong>2.2.</strong> Hallo Welt</a></li><li><a href="Hallo_Cargo.html"><strong>2.3.</strong> Hallo Cargo</a></li></ul></li><li><a href="Lerne_Rust.html"><strong>3.</strong> Lerne Rust</a></li><li><ul class="section"><li><a href="Ratespiel.html"><strong>3.1.</strong> Ratespiel</a></li><li><a href="Speisende_Philosophen.html"><strong>3.2.</strong> Speisende Philosophen</a></li><li><a href="Rust_In_Anderen_Sprachen.html"><strong>3.3.</strong> Rust in anderen Sprachen</a></li></ul></li><li><a href="Effektives_Rust.html"><strong>4.</strong> Effektives Rust</a></li><li><ul class="section"><li><a href="Der_Stack_Und_Der_Heap.html"><strong>4.1.</strong> Der Stack und der Heap</a></li><li><a href="Testen.html"><strong>4.2.</strong> Testen</a></li><li><a href="Bedingte_Kompilierung.html"><strong>4.3.</strong> Bedingte Kompilierung</a></li><li><a href="Dokumentation.html"><strong>4.4.</strong> Dokumentation</a></li><li><a href="Iteratoren.html"><strong>4.5.</strong> Iteratoren</a></li><li><a href="Nebenläufigkeit.html"><strong>4.6.</strong> Nebenläufigkeit</a></li><li><a href="Fehlerbehandlung.html"><strong>4.7.</strong> Fehlerbehandlung</a></li><li><a href="Garantien_Wählen.html"><strong>4.8.</strong> Garantien Wählen</a></li><li><a href="FFI.html"><strong>4.9.</strong> FFI</a></li><li><a href="Borrow_Und_AsRef.html"><strong>4.10.</strong> Borrow und AsRef</a></li><li><a href="Release_Kanäle.html"><strong>4.11.</strong> Release Kanäle</a></li></ul></li><li><a href="Syntax_Und_Semantik.html"><strong>5.</strong> Syntax und Semantik</a></li><li><ul class="section"><li><a href="Variablenbindung.html"><strong>5.1.</strong> Variablenbindung</a></li><li><a href="Funktionen.html"><strong>5.2.</strong> Funktionen</a></li><li><a href="Primitive_Typen.html"><strong>5.3.</strong> Primitive Typen</a></li><li><a href="Kommentare.html"><strong>5.4.</strong> Kommentare</a></li><li><a href="If.html"><strong>5.5.</strong> if</a></li><li><a href="Schleifen.html"><strong>5.6.</strong> Schleifen</a></li><li><a href="Besitz.html"><strong>5.7.</strong> Besitz</a></li><li><a href="Referenzen_Und_Ausleihen.html"><strong>5.8.</strong> Referenzen und Ausleihen</a></li><li><a href="Lebensdauer.html"><strong>5.9.</strong> Lebensdauer</a></li><li><a href="Veränderbarkeit.html" class="active"><strong>5.10.</strong> Veränderbarkeit</a></li><li><a href="Structs.html"><strong>5.11.</strong> Structs</a></li><li><a href="Enums.html"><strong>5.12.</strong> Enums</a></li><li><a href="Match.html"><strong>5.13.</strong> Match</a></li><li><a href="Muster.html"><strong>5.14.</strong> Muster</a></li><li><a href="Methodensyntax.html"><strong>5.15.</strong> Methodensyntax</a></li><li><a href="Vektoren.html"><strong>5.16.</strong> Vektoren</a></li><li><a href="Strings.html"><strong>5.17.</strong> Strings</a></li><li><a href="Generics.html"><strong>5.18.</strong> Generics</a></li><li><a href="Traits.html"><strong>5.19.</strong> Traits</a></li><li><a href="Drop.html"><strong>5.20.</strong> Drop</a></li><li><a href="If_Let.html"><strong>5.21.</strong> if let</a></li><li><a href="Trait_Objekte.html"><strong>5.22.</strong> Trait Objekte</a></li><li><a href="Closures.html"><strong>5.23.</strong> Closures</a></li><li><a href="UFCS.html"><strong>5.24.</strong> Universal Function Call Syntax</a></li><li><a href="Crates_Und_Module.html"><strong>5.25.</strong> Crates und Module</a></li><li><a href="Const_Und_Static.html"><strong>5.26.</strong> <code>const</code> und <code>static</code></a></li><li><a href="Attribute.html"><strong>5.27.</strong> Attribute</a></li><li><a href="Type_Aliase.html"><strong>5.28.</strong> <code>type</code> Aliase</a></li><li><a href="Zwischen_Typen_Umwandeln.html"><strong>5.29.</strong> Zwischen typen umwandeln</a></li><li><a href="Assoziierte_Typen.html"><strong>5.30.</strong> Assoziierte Typen</a></li><li><a href="Größenlose_Typen.html"><strong>5.31.</strong> Größenlose Typen</a></li><li><a href="Operatoren_Und_Überladen.html"><strong>5.32.</strong> Operatoren und Überladen</a></li><li><a href="Deref_Umwandlung.html"><strong>5.33.</strong> Deref Umwandlung</a></li><li><a href="Makros.html"><strong>5.34.</strong> Makros</a></li><li><a href="Raw_Zeiger.html"><strong>5.35.</strong> Raw Zeiger</a></li><li><a href="Unsafe.html"><strong>5.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="Nightly_Rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="Compiler_Plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="Inline_Assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="No_Stdlib.html"><strong>6.3.</strong> <code>no_stdlib</code></a></li><li><a href="Intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="Lang_Items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="Fortgeschrittenes_Linken.html"><strong>6.6.</strong> Fortgeschrittenes Linken</a></li><li><a href="Benchmark_Tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="Box_Syntax_Und_Muster.html"><strong>6.8.</strong> Box Syntax und Muster</a></li><li><a href="Slice_Muster.html"><strong>6.9.</strong> Slice Muster</a></li><li><a href="Assoziierte_Konstanten.html"><strong>6.10.</strong> Assoziierte Konstanten</a></li></ul></li><li><a href="Glossar.html"><strong>7.</strong> Glossar</a></li><li><a href="Akademische_Forschung.html"><strong>8.</strong> Akademische Forschung</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="Veränderbarkeit.html#veränderbarkeit" id="veränderbarkeit"><h1>Veränderbarkeit</h1></a>
<!-- Mutability, the ability to change something, works a bit differently in Rust
than in other languages. The first aspect of mutability is its non-default
status: -->
Veränderbarkeit, die Möglichkeit etwas zu ändern, funktioniert in Rust ein wenig anders als in anderen Programmiersprachen.
Standardmäßig sind Variablen nicht veränderbar: 
<!-- XXX rust,ignore wird bei meinem gitbook nicht erkannt und Syntaxhighlighting ist aus -->
```rust,ignore
let x = 5;
x = 6; // Fehler!
```
<!-- We can introduce mutability with the `mut` keyword: -->
Wir können Veränderbarkeit mit dem Schlüsselwort `mut`, die Kurzform für "mutable" (englisch: veränderbar), einführen:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;

x = 6; // Kein Problem!

#}</code></pre></pre>
<!-- This is a mutable [variable binding][vb]. When a binding is mutable, it means
you’re allowed to change what the binding points to. So in the above example,
it’s not so much that the value at `x` is changing, but that the binding
changed from one `i32` to another. -->
Dies ist eine veränderbare [Variablenbindung][v].
Wenn eine Bindung veränderbar ist, bedeutet es,
 dass du ändern kannst woran die Variablenbindung gebunden ist.
In dem oberen Beispiel ist es nicht so, dass sich der Wert in `x` ändert,
 sondern dass sich die Bindung von `x` von einem `i32` zu einem Anderen geändert hat.
<!-- You can also create a [reference][ref] to it, using `&x`, but if you want to use the reference to change it, you will need a mutable reference: -->
Du kannst auch eine [Referenz][ref] zu einer Variablenbindung mittels `&x` erstellen.
Wenn du aber die Referenz benutzen möchtest um die Variablenbindung zu ändern,
 benötigst du eine *veränderbare* Referenz: <!-- *Hervorhebung* hinzugefügt -->
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let y = &amp;mut x;

#}</code></pre></pre>
<!-- `y` is an immutable binding to a mutable reference,
  which means that you can’t bind 'y' to something else (`y = &mut z`),
  but `y` can be used to bind `x` to something else (`*y = 5`). A subtle distinction. -->
`y` ist eine unveränderbare Variablenbindung zu einer veränderbaren Referenz.
Das bedeutet, dass du `y` nicht zu etwas anderem binden kannst, z.B. `y = &mut z`.
Du kannst aber `y` benutzen um `x` an etwas anders zu binden, z.B. durch `*y = 5`.
Ein subtiler Unterschied.
<!-- Of course, if you need both: -->
Wenn du beides brauchst:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let mut y = &amp;mut x;

#}</code></pre></pre>
<!-- Now `y` can be bound to another value, and the value it’s referencing can be
changed. -->
Jetzt kann `y` an einen anderen Wert gebunden werden und der Wert der referenziert wird,
 kann geändert werden.
<!-- It’s important to note that `mut` is part of a [pattern][pattern], so you
can do things like this: -->
Es ist wichtig hervorzuheben, dass `mut` Teil eines [`Musters`][pattern] ist,
 so dass du zu soetwas binden kannst:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let (mut x, y) = (5, 6);

fn foo(mut x: i32) {
}

#}</code></pre></pre>
<!-- hier war ein Fehler in dem Book 1.3.0 durch ein # im Code -->
<!-- Note that here, the `x` is mutable, but not the `y`. -->
In dem Beispiel ist `x` veränderbar aber nicht `y`.
<!-- # Interior vs. Exterior Mutability -->
# Innere und äußere Veränderbarkeit
<!-- However, when we say something is ‘immutable’ in Rust, that doesn’t mean that
it’s not able to be changed: we are referring to its ‘exterior mutability’ that
in this case is immutable. Consider, for example, [`Arc<T>`][arc]: -->
Doch wenn wir sagen, etwas ist "unveränderlich" in Rust,
 dann bedeutet das nicht, dass es sich nicht ändern kann:
 wir meinen damit, dass dessen "äußere Veränderbarkeit" unveränderlich ist.
Betrachte als Beispiel [`Arc<T>`][arc]:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::sync::Arc;

let x = Arc::new(5);
let y = x.clone();

#}</code></pre></pre>
<!-- When we call `clone()`, the `Arc<T>` needs to update the reference count. Yet
we’ve not used any `mut`s here, `x` is an immutable binding, and we didn’t take
`&mut 5` or anything. So what gives? -->
Wenn wir `clone()` aufrufen, muss das `Arc<T>` seinen Referenzzähler aktualisieren.
Jedoch haben wir kein `mut` verwendet,
 `x` ist eine unveränderliche Variablenbindung,
 und wir haben nicht `&mut 5` oder soetwas benutzt.
Nun, was passiert hier?
<!-- To understand this, we have to go back to the core of Rust’s guiding
philosophy, memory safety, and the mechanism by which Rust guarantees it, the
[ownership][ownership] system, and more specifically, [borrowing][borrowing]: -->
Um das zu verstehen, müssen wir zurück zu den Kernprinzipien von Rust,
 Speichersicherheit und der Mechanismus, mit dem dies garantiert wird,
 [Besitz][ownership] und [Ausleihe][borrowing].
<!--
> You may have one or the other of these two kinds of borrows, but not both at
> the same time:
>
> * one or more references (`&T`) to a resource,
> * exactly one mutable reference (`&mut T`).
-->
> Du hast entweder die eine oder die andere Art Ausleihe, aber nicht beide gleichzeitig:
>
> * eine oder mehrere Referenzen (`&T`) zu einer Resource,
> * exakt eine veränderbare Referenz (`&mut T`).
<!-- So, that’s the real definition of ‘immutability’: is this safe to have two
pointers to? In `Arc<T>`’s case, yes: the mutation is entirely contained inside
the structure itself. It’s not user facing. For this reason, it hands out `&T`
with `clone()`. If it handed out `&mut T`s, though, that would be a problem. -->
Nun, dies ist die wirkliche Definition von "Unveränderbarkeit".
Ist es sicher zwei Referenzen zu Etwas zu haben?
Im Falle von `Arc<T>` ist es sicher.
Die Veränderung ist gekapselt im der Struktur selbst.
Sie ist nicht nach Außen sichtbar.
Aus diesem Grund wird `&T` durch `clone()` zurück gegeben.
Wenn es `&mut T` zurück geben würde, wäre das ein Problem.
<!-- XXX der englische Text selbst ist mit
     '...: is this safe to have two pointers to? ... yes: ...`
     sehr holprig und unklar was gemeint ist.
     Ich habe das mal angepasst. -->
<!-- Other types, like the ones in the [`std::cell`][stdcell] module, have the
opposite: interior mutability. For example: -->
Andere Typen, wie die in dem [`std::cell`][stdcell] Modul,
 haben hingegen innere Veränderbarkeit:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();

#}</code></pre></pre>
<!-- RefCell hands out `&mut` references to what’s inside of it with the
`borrow_mut()` method. Isn’t that dangerous? What if we do: -->
`RefCell` gibt über die Methode `borrow_mut()`
 eine `&mut` Referenz zu der inneren Bindung <!-- XXX Bindung oder Wert? -->
 zurück.
Ist das nicht gefährlich? Was ist, wenn wir folgendes tun:
<pre><code class="language-rust ignore">use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
let z = x.borrow_mut();
# (y, z);
</code></pre>
<!-- XXX warum ist hier ein # (y, z); ? Im book ist diese Zeile nicht mit einkompiliert. -->
<!-- This will in fact panic, at runtime. This is what `RefCell` does: it enforces
Rust’s borrowing rules at runtime, and `panic!`s if they’re violated. This
allows us to get around another aspect of Rust’s mutability rules. Let’s talk
about it first. -->
Dies löst durchaus eine `panic` zur Laufzeit aus.
Das ist, was `RefCell` macht:
 es setzt Rusts Regeln zum Ausleihen zur Laufzeit durch
 und `panic!`t wenn sie gebrochen werden.
Das erlaubt es uns mit einem weiteren Aspekt von Rusts Regeln zur Veränderbarkeit
 umzuhehen.
Lass uns aber ersteinmal über diesen Aspekt sprechen.
<!-- ## Field-level mutability -->
## Veränderbarkeit bei Feldern
<!-- Mutability is a property of either a borrow (`&mut`) or a binding (`let mut`).
This means that, for example, you cannot have a [`struct`][struct] with
some fields mutable and some immutable: -->
Veränderbarkeit ist eine Eigenschaft einer Ausleihe (`&mut`)
 oder einer Variablenbindung (`let mut`).
Das bedeutet zum Beispiel, dass du kein [Struct][struct]
 mit einigen veränderbaren und einigen unveränderbaren Feldern haben kannst:
<pre><code class="language-rust ignore">struct Point {
      x: i32,
      mut y: i32, // das geht nicht
}
</code></pre>
<!-- The mutability of a struct is in its binding: -->
Die Veränderbarkeit eines Struct ist in ihrer Bindung:
<pre><code class="language-rust ignore">struct Point {
      x: i32,
      y: i32,
}

let mut a = Point { x: 5, y: 6 };

a.x = 10;

let b = Point { x: 5, y: 6};

b.x = 10; // error: cannot assign to immutable field `b.x`
</code></pre>
<!-- However, by using [`Cell<T>`][cell], you can emulate field-level mutability: -->
Jedoch kann man mit Hilfe von [`Cell<T>`][cell] Veränderbarkeit pro Feld nachbilden:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::cell::Cell;

struct Point {
      x: i32,
      y: Cell&lt;i32&gt;,
}

let point = Point { x: 5, y: Cell::new(6) };

point.y.set(7);

println!(&quot;y: {:?}&quot;, point.y);

#}</code></pre></pre>
<!-- This will print `y: Cell { value: 7 }`. We’ve successfully updated `y`. -->
Dies gibt `y: Cell { value: 7 }` aus.
Wir haben `y` erfolgreich verändert.

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="Lebensdauer.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="Structs.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="Lebensdauer.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="Structs.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
