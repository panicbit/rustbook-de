<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Lebensdauer - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="Einführung.html"><strong>1.</strong> Einführung</a></li><li><a href="Erste_Schritte.html"><strong>2.</strong> Erste Schritte</a></li><li><ul class="section"><li><a href="Rust_Installieren.html"><strong>2.1.</strong> Rust installieren</a></li><li><a href="Hallo_Welt.html"><strong>2.2.</strong> Hallo Welt</a></li><li><a href="Hallo_Cargo.html"><strong>2.3.</strong> Hallo Cargo</a></li></ul></li><li><a href="Lerne_Rust.html"><strong>3.</strong> Lerne Rust</a></li><li><ul class="section"><li><a href="Ratespiel.html"><strong>3.1.</strong> Ratespiel</a></li><li><a href="Speisende_Philosophen.html"><strong>3.2.</strong> Speisende Philosophen</a></li><li><a href="Rust_In_Anderen_Sprachen.html"><strong>3.3.</strong> Rust in anderen Sprachen</a></li></ul></li><li><a href="Effektives_Rust.html"><strong>4.</strong> Effektives Rust</a></li><li><ul class="section"><li><a href="Der_Stack_Und_Der_Heap.html"><strong>4.1.</strong> Der Stack und der Heap</a></li><li><a href="Testen.html"><strong>4.2.</strong> Testen</a></li><li><a href="Bedingte_Kompilierung.html"><strong>4.3.</strong> Bedingte Kompilierung</a></li><li><a href="Dokumentation.html"><strong>4.4.</strong> Dokumentation</a></li><li><a href="Iteratoren.html"><strong>4.5.</strong> Iteratoren</a></li><li><a href="Nebenläufigkeit.html"><strong>4.6.</strong> Nebenläufigkeit</a></li><li><a href="Fehlerbehandlung.html"><strong>4.7.</strong> Fehlerbehandlung</a></li><li><a href="Garantien_Wählen.html"><strong>4.8.</strong> Garantien Wählen</a></li><li><a href="FFI.html"><strong>4.9.</strong> FFI</a></li><li><a href="Borrow_Und_AsRef.html"><strong>4.10.</strong> Borrow und AsRef</a></li><li><a href="Release_Kanäle.html"><strong>4.11.</strong> Release Kanäle</a></li></ul></li><li><a href="Syntax_Und_Semantik.html"><strong>5.</strong> Syntax und Semantik</a></li><li><ul class="section"><li><a href="Variablenbindung.html"><strong>5.1.</strong> Variablenbindung</a></li><li><a href="Funktionen.html"><strong>5.2.</strong> Funktionen</a></li><li><a href="Primitive_Typen.html"><strong>5.3.</strong> Primitive Typen</a></li><li><a href="Kommentare.html"><strong>5.4.</strong> Kommentare</a></li><li><a href="If.html"><strong>5.5.</strong> if</a></li><li><a href="Schleifen.html"><strong>5.6.</strong> Schleifen</a></li><li><a href="Besitz.html"><strong>5.7.</strong> Besitz</a></li><li><a href="Referenzen_Und_Ausleihen.html"><strong>5.8.</strong> Referenzen und Ausleihen</a></li><li><a href="Lebensdauer.html" class="active"><strong>5.9.</strong> Lebensdauer</a></li><li><a href="Veränderbarkeit.html"><strong>5.10.</strong> Veränderbarkeit</a></li><li><a href="Structs.html"><strong>5.11.</strong> Structs</a></li><li><a href="Enums.html"><strong>5.12.</strong> Enums</a></li><li><a href="Match.html"><strong>5.13.</strong> Match</a></li><li><a href="Muster.html"><strong>5.14.</strong> Muster</a></li><li><a href="Methodensyntax.html"><strong>5.15.</strong> Methodensyntax</a></li><li><a href="Vektoren.html"><strong>5.16.</strong> Vektoren</a></li><li><a href="Strings.html"><strong>5.17.</strong> Strings</a></li><li><a href="Generics.html"><strong>5.18.</strong> Generics</a></li><li><a href="Traits.html"><strong>5.19.</strong> Traits</a></li><li><a href="Drop.html"><strong>5.20.</strong> Drop</a></li><li><a href="If_Let.html"><strong>5.21.</strong> if let</a></li><li><a href="Trait_Objekte.html"><strong>5.22.</strong> Trait Objekte</a></li><li><a href="Closures.html"><strong>5.23.</strong> Closures</a></li><li><a href="UFCS.html"><strong>5.24.</strong> Universal Function Call Syntax</a></li><li><a href="Crates_Und_Module.html"><strong>5.25.</strong> Crates und Module</a></li><li><a href="Const_Und_Static.html"><strong>5.26.</strong> <code>const</code> und <code>static</code></a></li><li><a href="Attribute.html"><strong>5.27.</strong> Attribute</a></li><li><a href="Type_Aliase.html"><strong>5.28.</strong> <code>type</code> Aliase</a></li><li><a href="Zwischen_Typen_Umwandeln.html"><strong>5.29.</strong> Zwischen typen umwandeln</a></li><li><a href="Assoziierte_Typen.html"><strong>5.30.</strong> Assoziierte Typen</a></li><li><a href="Größenlose_Typen.html"><strong>5.31.</strong> Größenlose Typen</a></li><li><a href="Operatoren_Und_Überladen.html"><strong>5.32.</strong> Operatoren und Überladen</a></li><li><a href="Deref_Umwandlung.html"><strong>5.33.</strong> Deref Umwandlung</a></li><li><a href="Makros.html"><strong>5.34.</strong> Makros</a></li><li><a href="Raw_Zeiger.html"><strong>5.35.</strong> Raw Zeiger</a></li><li><a href="Unsafe.html"><strong>5.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="Nightly_Rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="Compiler_Plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="Inline_Assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="No_Stdlib.html"><strong>6.3.</strong> <code>no_stdlib</code></a></li><li><a href="Intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="Lang_Items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="Fortgeschrittenes_Linken.html"><strong>6.6.</strong> Fortgeschrittenes Linken</a></li><li><a href="Benchmark_Tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="Box_Syntax_Und_Muster.html"><strong>6.8.</strong> Box Syntax und Muster</a></li><li><a href="Slice_Muster.html"><strong>6.9.</strong> Slice Muster</a></li><li><a href="Assoziierte_Konstanten.html"><strong>6.10.</strong> Assoziierte Konstanten</a></li></ul></li><li><a href="Glossar.html"><strong>7.</strong> Glossar</a></li><li><a href="Akademische_Forschung.html"><strong>8.</strong> Akademische Forschung</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="Lebensdauer.html#lebensdauer" id="lebensdauer"><h1>Lebensdauer</h1></a>
<p>Dieser Guide ist einer von dreien, der Rusts Ownership-System.
präsentiert. Dies ist eines von Rusts einzigartigen und verlockenden
Features mit denen Rust Entwickler vertraut sein sollten.
Durch Ownership [engl.: Besitz] erreicht Rust sein größtes Ziel,
die Speichersicherheit.
Es gibt ein paar verschiedene Konzepte, jedes mit seinem eigenen Kapitel:</p>
<ul>
<li><a href="Besitz.html">Besitz</a>, das Schlüsselkonzept.</li>
<li><a href="Referenzen_Und_Ausleihen.html">Ausleihen</a>, und das assozierte Feature ‘Referenzen’</li>
<li>Lebensdauer, das was du gerade liest.</li>
</ul>
<p>Diese drei Kapitel sind verwandt und deswegen in dieser Reihenfolge zu lesen.
Du wirst alle drei benötigen um das Ownership-System vollständig zu verstehen.</p>
<a class="header" href="Lebensdauer.html#meta" id="meta"><h1>Meta</h1></a>
<p>Bevor wir in die Details gehen gibt es zwei wichtige Hinweise über das
Ownership-System.</p>
<p>Rust hat einen Fokus auf Sicherheit und Geschwindigkeit.
Es erfüllt diese Ziele durch viele &quot;kostenfreie Abstraktionen&quot;
[‘zero-cost abstractions’], was bedeutet, dass in Rust die Kosten so niedrig
wie möglich sind um diese Abstraktionen funktionieren zu lassen.
Jegliche Analyse über die wie in diesem Guide sprechen wird
<em>zur Kompilierzeit</em> ausgeführt. Du zahlst für diese Features
keine Extrakosten zur Laufzeit.</p>
<p>Jedoch hat dieses System einen gewissen Preis: Die Lernkurve.
Viele neue Rust Nutzer erleben etwas,
was wir &quot;mit dem <em>borrow checker</em> kämpfen&quot; nennen,
wobei dann Rust verweigert ein Programm zu kompilieren
bei dem der Author denkt, dass es korrekt ist.
Das passiert häufig, da das mentale Modell des Programmierers von Ownership
nicht den eigentlichen Regeln entspricht, die Rust implementiert.
Du wirst wahrscheinlich zuerst etwas ähnliches erleben.
Die guten Nachricht ist aber:
Erfahrenere Rust Entwickler berichten, dass, sobald sie eine Zeit
mit den Regeln des Ownership-Systems gearbeitet haben, sie immer weniger
mit dem <em>borrow checker</em> kämpfen müssen.</p>
<p>Mit diesem Wissen, lass uns über Lebensdauer lernen.</p>
<a class="header" href="Lebensdauer.html#lebensdauer-1" id="lebensdauer-1"><h1>Lebensdauer</h1></a>
<p>Eine Referenz auf eine Ressource, die jemand anderes besitzt, auszuleihen
kann kompliziert sein. Stell dir zum Beispiel diese Folge von
Vorgängen vor:</p>
<ul>
<li>Ich erhalte ein Handle für irgendeine Ressource.</li>
<li>Ich leihe dir eine Referenz zu dieser Ressource.</li>
<li>Ich entscheide mich, dass ich die Ressource nicht mehr brauch und
gebe sie frei, während du immernoch deine Referenz hast.</li>
<li>Du entscheidest dich die Ressource zu verwenden.</li>
</ul>
<p>Oh-oh! Deine Referenz zeigt auf eine ungültige Ressource.
Dies wird &quot;baumelnder Zeiger&quot; oder &quot;use after free&quot; genannt.</p>
<p>Um das zu beheben müssen wir sicherstellen, dass Schritt Drei nie nach
Schritt Vier passiert. Das Ownership-System in Rust macht dies durch ein
Konzept namens Lebensdauer [lifetimes], welches den Scope beschreibt
für den eine Referenz gültig ist.</p>
<p>Wenn wir eine Funktion haben, die eine Referenz als Argument nimmt,
dann ist die Lebenszeit dieser Referenz entweder implizit oder explizit:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// implicit
fn foo(x: &amp;i32) {
}

// explicit
fn bar&lt;'a&gt;(x: &amp;'a i32) {
}

#}</code></pre></pre>
<p>Das <code>'a</code> wird als &quot;die Lebenszeit a&quot; gelesen. Technisch gesehen hat jedee
Referenz eine zugehörige Lebenszeit, aber der Compiler erlaubt es diese in
üblichen Fällen wegzulassen.
Bevor wir jedoch darauf eingehen gehen wir noch das explizite Beispiel durch:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn bar&lt;'a&gt;(...)

#}</code></pre></pre>
<p>Dieser Teil deklariert unsere Lebenszeit. Er besagt, dass <code>bar</code> eine Lebenszeit
namens <code>'a</code> hat. Hätten wir zwei Referenz, dann würde das so aussehen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn bar&lt;'a, 'b&gt;(...)

#}</code></pre></pre>
<p>I unserer Parameterlist benutzen wir dann die benannten Lebenszeiten:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
...(x: &amp;'a i32)

#}</code></pre></pre>
<p>Wenn wir eine <code>&amp;mut</code> Referenz haben wollten,
dann würden wir folgendes schreiben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
...(x: &amp;'a mut i32)

#}</code></pre></pre>
<p>Wenn du <code>&amp;mut i32</code> und <code>&amp;'a mut i32</code> miteinander vergleichst,
dann siehst du, dass sie eigentlich identisch sind, bis auf den Unterschied,
dass sich ein <code>'a</code> zwischen dem <code>&amp;</code> und dem <code>mut i32</code> eingeschlichen hat.
Wir lesen <code>&amp;mut i32</code> als &quot;eine veränderbare Referenz auf ein i32&quot; und
<code>&amp;'a mut i32</code> als &quot;eine veränderbare Referenz auf ein i32
mit der Lebenszeit <code>'a</code>&quot;.</p>
<a class="header" href="Lebensdauer.html#in-structs" id="in-structs"><h1>In <code>struct</code>s</h1></a>
<p>Du wirst auch explizite Lebenszeiten brauchen,
wenn du mit <a href="Structs.html"><code>struct</code></a>s arbeitest:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;{}&quot;, f.x);
}
</code></pre></pre>
<p>Wie du sehen kannst können <code>struct</code>s auch Lebenszeiten haben.
Auf eine ähnliche Art und Weise wie Funktionen deklariert</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Foo&lt;'a&gt; {

#}</code></pre></pre>
<p>eine Lebenszeit und</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
x: &amp;'a i32,

#}</code></pre></pre>
<p>benutzt sie. Also warum brauchen wir eine Lebenszeit hier?
Wir müssen sicherstellen, dass keine Referenz auf <code>Foo</code> länger lebt,
als die enthaltene Referenz auf das <code>i32</code>.</p>
<a class="header" href="Lebensdauer.html#impl-blöcke" id="impl-blöcke"><h2><code>impl</code> Blöcke</h2></a>
<p>Lass uns eine Methode auf dem Typen <code>Foo</code> implementieren:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x(&amp;self) -&gt; &amp;'a i32 { self.x }
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;x is: {}&quot;, f.x());
}
</code></pre></pre>
<p>Wie du sehen kannst müssen wir eine Lebensdauer für <code>Foo</code> in der <code>impl</code> Zeile
deklarieren. Wir wiederholen <code>'a</code> zweimal, genau wie bei Funktionen: <code>impl&lt;'a&gt;</code>
deklariert eine Lebensdauer <code>'a</code> und <code>Foo&lt;'a&gt;</code> benutzt sie.</p>
<a class="header" href="Lebensdauer.html#mehr-als-eine-lebensdauer" id="mehr-als-eine-lebensdauer"><h2>Mehr als eine Lebensdauer</h2></a>
<p>Wenn du mehrere Referenzen hast, dann kannst du die gleiche Lebensdauer mehrmals
verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn x_or_y&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {

#}</code></pre></pre>
<p>Dieser code besagt, dass <code>x</code>, <code>y</code> und
der Rückgabewert die gleiche Lebenszeit haben.
Wenn du wolltest, dass <code>x</code> und <code>y</code> verschiedene Lebenszeiten haben,
dann kannst du mehrere Lebenszeit-Parameter verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn x_or_y&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {

#}</code></pre></pre>
<p>In diesem Beispiel haben <code>x</code> und <code>y</code> also verschiedene gültige Scopes,
aber der Rückgabewert hat dieselbe Lebenszeit wie <code>x</code>.</p>
<a class="header" href="Lebensdauer.html#in-scopes-denken" id="in-scopes-denken"><h2>In Scopes denken</h2></a>
<p>Ein Weg über Lebenszeiten zu nachzudenken ist den Scope, indem eine Referenz
gültig ist, zu visualisieren. Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = &amp;5;     // -+ y goes into scope
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ y goes out of scope
</code></pre></pre>
<p>Mit unserem <code>Foo</code> hinzugefügt:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5;           // -+ y goes into scope
    let f = Foo { x: y }; // -+ f goes into scope
    // stuff              //  |
                          //  |
}                         // -+ f and y go out of scope
</code></pre></pre>
<p>Unser <code>f</code> lebt im Scope von <code>y</code>, also funktioniert alles.
Aber was wenn nicht? Dieser Code Funktioniert nicht:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let x;                    // -+ x goes into scope
                              //  |
    {                         //  |
        let y = &amp;5;           // ---+ y goes into scope
        let f = Foo { x: y }; // ---+ f goes into scope
        x = &amp;f.x;             //  | | error here
    }                         // ---+ f and y go out of scope
                              //  |
    println!(&quot;{}&quot;, x);        //  |
}                             // -+ x goes out of scope
</code></pre></pre>
<p>Uff! Wie du hier siehst ist der Scope von <code>f</code> und <code>y</code> kleiner als der von <code>x</code>.
Aber wenn wir <code>x = &amp;f.x</code> ausführen, erzeugen wir eine Referenz auf etwas, was
kurz davor steht den Scope zu verlassen.</p>
<a class="header" href="Lebensdauer.html#static" id="static"><h2>'static</h2></a>
<p>Die Lebenszeit namens ‘static’ ist eine besondere Lebenszeit. Sie signalisiert,
dass etwas dieselbe Lebenszeit wie das ganze Programm hat.
Die meisten Rust Programmierer treffen das erste mal auf <code>'static</code>,
wenn sie mit Strings arbeiten:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x: &amp;'static str = &quot;Hello, world.&quot;;

#}</code></pre></pre>
<p>Stringliterale haben den Typ <code>&amp;'static str</code>, da die Referenz immer gültig ist:
Sie sind in das Datensegment der Binärdatei integriert.
Ein anderes Beispiel sind <em>globals</em> (globale Variablen):</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
static FOO: i32 = 5;
let x: &amp;'static i32 = &amp;FOO;

#}</code></pre></pre>
<p>Dies fügt dem Datensegment der Binärdatei eine <code>i32</code> hinzu und <code>x</code> ist eine
Referenz darauf.</p>
<a class="header" href="Lebensdauer.html#weglassen-von-lebenszeiten" id="weglassen-von-lebenszeiten"><h2>Weglassen von Lebenszeiten</h2></a>
<p>Rust unterstützt mächtige lokale Typinferenz in Funktionskörpern, aber es ist
verboten in Signaturen aus der jeweiligen Signatur allein Sachen abzuleiten.
Es gibt jedoch aus ergonomischen Gründen eine sehr Eingeschränkte Form von
Inferenz namens <em>lifetime elision</em> (&quot;Weglassen von Lebenszeiten&quot;), welche
das erlaubt. Sie leitet ausschließlich basierend aus der Signatur einer
Komponente (also nicht dem Körper) etwas ab und zwar nur Lebenszeit-Parameter.
Außerdem geschieht <em>lifetime elision</em> gemäß nur drei einfahc zu merkenden und
deutlichen Regeln. Dies erlaubt der <em>lifetime elision</em> eine Kurzschreibweise
für Signaturen zu ermöglichen und gleichzeitig nicht die eigentlichen
involvierten Typen zu verstecken, wie es eine vollständig Inferenz machen würde.</p>
<p>Wenn wir über <em>lifetime elision</em> reden, dann benutzen wir den Begriff
<em>input lifetime</em> und <em>output lifetime</em>. Eine <em>input lifetime</em> ist eine
Lebenszeit, die mit einem Parameter einer Funktion assoziiert ist,
und eine <em>output lifetime</em> ist eine Lebenszeit, die mit dem Rückgabewert einer
Funktion assoziiert ist. Zum Beispiel hat diese Funktion eine <em>input lifetime</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a&gt;(bar: &amp;'a str)

#}</code></pre></pre>
<p>Diese hier hat eine <em>output lifetime</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a&gt;() -&gt; &amp;'a str

#}</code></pre></pre>
<p>Und diese hier hat eine Lebenszeit in beiden Positionen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a&gt;(bar: &amp;'a str) -&gt; &amp;'a str

#}</code></pre></pre>
<p>Hier sind die drei Regeln:</p>
<ul>
<li>
<p>Jede weggelassene Lebenszeit bei den Argumenten einer Funktion bekommt einen
individuellen Lebenszeit-Paramter.</p>
</li>
<li>
<p>Wenn es genau eine <em>input lifetime</em> gibt, ob weggelassen oder nicht,
dann wird diese Lebenszeit aller ausgelassenen Lebenszeiten im Rückgabewert
der Funktion zugewiesen.</p>
</li>
<li>
<p>Wenn es mehrere <em>input lifetime</em> gibt und eines der Argumente <code>&amp;self</code>,
<code>&amp;mut self</code> oder <code>self</code> ist, dann wird die Lebenszeit von <code>self</code>
allen weggelassenen <em>output lifetimes</em> zugewiesen.</p>
</li>
</ul>
<p>Andernfalls ist es einen Fehler eine Lebenszeit wegzulassen.</p>
<a class="header" href="Lebensdauer.html#beispiele" id="beispiele"><h3>Beispiele</h3></a>
<p>Hier sind ein paar Beispiel-Funktionen mit weggelassenen Lebenszeiten.
Wir haben jedes Beispiel einer ausgelassenen Lebenszeit mit ihrer
expandierten Form gepaart.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn print(s: &amp;str); // elided
fn print&lt;'a&gt;(s: &amp;'a str); // expanded

fn debug(lvl: u32, s: &amp;str); // elided
fn debug&lt;'a&gt;(lvl: u32, s: &amp;'a str); // expanded

// In dem vorangehenden Beispiel benötigt `lvl` keine eigene Lebenszeit,
// da es keine Referenz (`&amp;`) ist. Nur Sachen, die mit Referenzen zu tun haben
// (wie z.B. `struct`s, die Referenzen enthalten) benötigen Lebenszeiten.

fn substr(s: &amp;str, until: u32) -&gt; &amp;str; // elided
fn substr&lt;'a&gt;(s: &amp;'a str, until: u32) -&gt; &amp;'a str; // expanded

fn get_str() -&gt; &amp;str; // ILLEGAL, no inputs

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str; // ILLEGAL, two inputs
fn frob&lt;'a, 'b&gt;(s: &amp;'a str, t: &amp;'b str) -&gt; &amp;str; // Expanded: Output lifetime is ambiguous

fn get_mut(&amp;mut self) -&gt; &amp;mut T; // elided
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T; // expanded

fn args&lt;T:ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command // elided
fn args&lt;'a, 'b, T:ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command // expanded

fn new(buf: &amp;mut [u8]) -&gt; BufWriter; // elided
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt; // expanded

#}</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="Referenzen_Und_Ausleihen.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="Veränderbarkeit.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="Referenzen_Und_Ausleihen.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="Veränderbarkeit.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
