<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Akademische Forschung - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="Einführung.html"><strong>1.</strong> Einführung</a></li><li><a href="Erste_Schritte.html"><strong>2.</strong> Erste Schritte</a></li><li><ul class="section"><li><a href="Rust_Installieren.html"><strong>2.1.</strong> Rust installieren</a></li><li><a href="Hallo_Welt.html"><strong>2.2.</strong> Hallo Welt</a></li><li><a href="Hallo_Cargo.html"><strong>2.3.</strong> Hallo Cargo</a></li></ul></li><li><a href="Lerne_Rust.html"><strong>3.</strong> Lerne Rust</a></li><li><ul class="section"><li><a href="Ratespiel.html"><strong>3.1.</strong> Ratespiel</a></li><li><a href="Speisende_Philosophen.html"><strong>3.2.</strong> Speisende Philosophen</a></li><li><a href="Rust_In_Anderen_Sprachen.html"><strong>3.3.</strong> Rust in anderen Sprachen</a></li></ul></li><li><a href="Effektives_Rust.html"><strong>4.</strong> Effektives Rust</a></li><li><ul class="section"><li><a href="Der_Stack_Und_Der_Heap.html"><strong>4.1.</strong> Der Stack und der Heap</a></li><li><a href="Testen.html"><strong>4.2.</strong> Testen</a></li><li><a href="Bedingte_Kompilierung.html"><strong>4.3.</strong> Bedingte Kompilierung</a></li><li><a href="Dokumentation.html"><strong>4.4.</strong> Dokumentation</a></li><li><a href="Iteratoren.html"><strong>4.5.</strong> Iteratoren</a></li><li><a href="Nebenläufigkeit.html"><strong>4.6.</strong> Nebenläufigkeit</a></li><li><a href="Fehlerbehandlung.html"><strong>4.7.</strong> Fehlerbehandlung</a></li><li><a href="Garantien_Wählen.html"><strong>4.8.</strong> Garantien Wählen</a></li><li><a href="FFI.html"><strong>4.9.</strong> FFI</a></li><li><a href="Borrow_Und_AsRef.html"><strong>4.10.</strong> Borrow und AsRef</a></li><li><a href="Release_Kanäle.html"><strong>4.11.</strong> Release Kanäle</a></li></ul></li><li><a href="Syntax_Und_Semantik.html"><strong>5.</strong> Syntax und Semantik</a></li><li><ul class="section"><li><a href="Variablenbindung.html"><strong>5.1.</strong> Variablenbindung</a></li><li><a href="Funktionen.html"><strong>5.2.</strong> Funktionen</a></li><li><a href="Primitive_Typen.html"><strong>5.3.</strong> Primitive Typen</a></li><li><a href="Kommentare.html"><strong>5.4.</strong> Kommentare</a></li><li><a href="If.html"><strong>5.5.</strong> if</a></li><li><a href="Schleifen.html"><strong>5.6.</strong> Schleifen</a></li><li><a href="Besitz.html"><strong>5.7.</strong> Besitz</a></li><li><a href="Referenzen_Und_Ausleihen.html"><strong>5.8.</strong> Referenzen und Ausleihen</a></li><li><a href="Lebensdauer.html"><strong>5.9.</strong> Lebensdauer</a></li><li><a href="Veränderbarkeit.html"><strong>5.10.</strong> Veränderbarkeit</a></li><li><a href="Structs.html"><strong>5.11.</strong> Structs</a></li><li><a href="Enums.html"><strong>5.12.</strong> Enums</a></li><li><a href="Match.html"><strong>5.13.</strong> Match</a></li><li><a href="Muster.html"><strong>5.14.</strong> Muster</a></li><li><a href="Methodensyntax.html"><strong>5.15.</strong> Methodensyntax</a></li><li><a href="Vektoren.html"><strong>5.16.</strong> Vektoren</a></li><li><a href="Strings.html"><strong>5.17.</strong> Strings</a></li><li><a href="Generics.html"><strong>5.18.</strong> Generics</a></li><li><a href="Traits.html"><strong>5.19.</strong> Traits</a></li><li><a href="Drop.html"><strong>5.20.</strong> Drop</a></li><li><a href="If_Let.html"><strong>5.21.</strong> if let</a></li><li><a href="Trait_Objekte.html"><strong>5.22.</strong> Trait Objekte</a></li><li><a href="Closures.html"><strong>5.23.</strong> Closures</a></li><li><a href="UFCS.html"><strong>5.24.</strong> Universal Function Call Syntax</a></li><li><a href="Crates_Und_Module.html"><strong>5.25.</strong> Crates und Module</a></li><li><a href="Const_Und_Static.html"><strong>5.26.</strong> <code>const</code> und <code>static</code></a></li><li><a href="Attribute.html"><strong>5.27.</strong> Attribute</a></li><li><a href="Type_Aliase.html"><strong>5.28.</strong> <code>type</code> Aliase</a></li><li><a href="Zwischen_Typen_Umwandeln.html"><strong>5.29.</strong> Zwischen typen umwandeln</a></li><li><a href="Assoziierte_Typen.html"><strong>5.30.</strong> Assoziierte Typen</a></li><li><a href="Größenlose_Typen.html"><strong>5.31.</strong> Größenlose Typen</a></li><li><a href="Operatoren_Und_Überladen.html"><strong>5.32.</strong> Operatoren und Überladen</a></li><li><a href="Deref_Umwandlung.html"><strong>5.33.</strong> Deref Umwandlung</a></li><li><a href="Makros.html"><strong>5.34.</strong> Makros</a></li><li><a href="Raw_Zeiger.html"><strong>5.35.</strong> Raw Zeiger</a></li><li><a href="Unsafe.html"><strong>5.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="Nightly_Rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="Compiler_Plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="Inline_Assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="No_Stdlib.html"><strong>6.3.</strong> <code>no_stdlib</code></a></li><li><a href="Intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="Lang_Items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="Fortgeschrittenes_Linken.html"><strong>6.6.</strong> Fortgeschrittenes Linken</a></li><li><a href="Benchmark_Tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="Box_Syntax_Und_Muster.html"><strong>6.8.</strong> Box Syntax und Muster</a></li><li><a href="Slice_Muster.html"><strong>6.9.</strong> Slice Muster</a></li><li><a href="Assoziierte_Konstanten.html"><strong>6.10.</strong> Assoziierte Konstanten</a></li></ul></li><li><a href="Glossar.html"><strong>7.</strong> Glossar</a></li><li><a href="Akademische_Forschung.html"><strong>8.</strong> Akademische Forschung</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#die-programmiersprache-rust" id="die-programmiersprache-rust"><h1>Die Programmiersprache Rust</h1></a>
<p>Willkommen! Dieses Buch wird dir die <a href="https://www.rust-lang.org">Programmiersprache Rust</a> beibringen.
Rust ist eine Systemprogrammiersprache mit dem Fokus auf drei Ziele:
Sicherheit, Geschwindigkeit und Nebenläufigkeit (Safety, Speed, Concurrency).
Sie erreicht diese Ziele ohne Garbage Collector, was sie zu einer nützlichen Sprache
für eine Reihe von Anwendungsfällen macht, in denen andere Sprachen nicht so gut sind:
Einbettung in andere Sprachen, Programme mit besonderen Anforderungen an Speicher-
oder Zeitbedarf und Schreiben von Low-Level-Code, wie z.B. Gerätetreiber und
Betriebssysteme.
Sie übertrifft derzeitige Sprachen, die auf diesen Bereich abzielen, indem sie eine
Reihe von Sicherheitsprüfungen zur Kompilierzeit durchführt – ohne Kosten zur Laufzeit,
indem alle <em>data races</em> vermieden werden.
Rust zielt auch darauf ab „kostenfreie Abstraktionen“ zu realisieren, obwohl
einige dieser Abstraktionen sich anfühlen wie die einer Hochsprache.
Selbst dann erlaubt Rust eine genaue Kontrolle, wie es eine Low-Level-Sprache tun würde.</p>
<p>„Die Programmiersprache Rust“ ist in acht Abschnitte unterteilt.
Diese Einführung ist der erste. Danach folgen:</p>
<ul>
<li><a href="Erste_Schritte.html">Erste Schritte</a> - Richte deinen Computer für die Entwicklung mit Rust ein.</li>
<li><a href="Lerne_Rust.html">Lerne Rust</a> - Lerne Rust-Programmierung durch kleine Projekte.</li>
<li><a href="Effektives_Rust.html">Effektives Rust</a> - Fortgeschrittene Konzepte, um ausgezeichneten Rust-Code zu schreiben.</li>
<li><a href="Syntax_Und_Semantik.html">Syntax und Semantik</a> - Jedes Stück Rust auf kleine Stücke heruntergebrochen.</li>
<li><a href="Nightly_Rust.html">Nightly Rust</a> - <em>Cutting-edge features</em>, die noch nicht im stabilen Compiler verfügbar sind.</li>
<li><a href="Glossar.html">Glossar</a> - Erklärungen von Begriffen, die in diesem Buch verwendet werden.</li>
<li><a href="Bibliografie.html">Akademische Forschung</a> - Literatur, die Rust beeinflusst hat.</li>
</ul>
<p>Nach dem Lesen dieser Einführung möchtest du wahrscheinlich - je nach Vorliebe -
entweder ‚<a href="Lerne_Rust.html">Lerne Rust</a>‘ oder ‚<a href="Syntax_Und_Semantik.html">Syntax and Semantics</a>‘ lesen:
‚<a href="Lerne_Rust.html">Lerne Rust</a>‘, wenn du mit einem Projekt anfangen möchtest,
oder ‚<a href="Syntax_Und_Semantik.html">Syntax and Semantics</a>‘, wenn du lieber klein anfangen und jeweils ein
einziges Konzept ausführlich lernen möchtest, bevor du mit dem Nächsten weiter machst.
Reichliche Querverweise verbinden diese beiden Teile miteinander.</p>
<a class="header" href="print.html#mithelfen" id="mithelfen"><h3>Mithelfen</h3></a>
<p>Dieses Buch ist eine Community-Übersetzung von dem offiziellen Buch „The Rust Programming Language“.</p>
<p>Die Quelldateien dieser Übersetzung befinden sich auf Github:
<a href="https://github.com/rust-lang-de/rustbook-de">github.com/rust-lang-de/rustbook-de</a></p>
<p>Die Quelldateien des englischen Originals befinden sich ebenfalls auf Github:
<a href="https://github.com/rust-lang/rust/tree/master/src/doc/book">github.com/rust-lang/rust/tree/master/src/doc/book</a></p>
<a class="header" href="print.html#eine-kurze-einführung-in-rust" id="eine-kurze-einführung-in-rust"><h2>Eine kurze Einführung in Rust</h2></a>
<p>Ist Rust eine Sprache, die dich interessieren könnte? Lass uns ein paar
Code-Beispiele anschauen, um ein paar ihrer Stärken zu demonstrieren.</p>
<p>Das Hauptkonzept, das Rust einmalig macht, wird ‚<em>ownership</em>‘ [engl.: Eigentum]
genannt. Betrachte dieses kleine Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];
}
</code></pre></pre>
<p>Dieses Programm macht eine <a href="Variablenbindung.html">Variablenbindung</a> namens <code>x</code>. Der Wert dieser
Bindung ist ein <code>Vec&lt;T&gt;</code>, ein ‚Vektor‘, den wir durch ein <a href="Makros.html">Makro</a>
aus der Standardbibliothek erzeugt haben. Dieses Makro heißt <code>vec</code> und wir rufen
Makros mit einem <code>!</code> auf. Dies folgt einem allgemeinen Prinzip von Rust:
Mach Dinge klar! Makros können bedeutend mehr komplizierte Dinge tun als
Funktionsaufrufe und damit sind sie optisch eindeutig. Das <code>!</code> hilft auch beim
Parsen, was es erleichtert Werkzeuge zu schreiben und ebenfalls wichtig ist.</p>
<p>Wir haben <code>mut</code> benutzt, um <code>x</code> <em>mutable</em> [engl.: veränderbar] zu machen:
Bindungen sind standardmäßig <em>immutable</em> [engl.: unveränderbar].
Wir werden den Vektor noch später in diesem Beispiel verändern.</p>
<p>Es ist ebenfalls beachtenswert, dass hier keine Typangaben notwendig waren:
Obwohl Rust statisch typisiert ist, mussten wir den Typ nicht ausdrücklich
angeben. Rust hat <em>type inference</em> [engl.: Typinferenz, Typableitung], um
die Stärke statischer Typen und der Ausführlichkeit des Angebens von Typen
auszubalancieren.</p>
<p>Rust alloziert Daten bevorzugt auf dem Stack als auf dem Heap: <code>x</code> wird direkt
auf dem Stack platziert. Der <code>Vec&lt;T&gt;</code> Typ jedoch reserviert Speicher für die
Elemente des Vektors auf dem Heap. Falls du nicht mit dieser Unterscheidung
vertraut bist, dann kannst du sie fürs Erste ignorieren oder einen Blick in
<a href="Der_Stack_Und_Der_Heap.html">‚Der Stack und der Heap‘</a> werfen. Als eine Systemprogrammiersprache
gibt Rust dir die Möglichkeit zu bestimmen, wie dein Speicher alloziert wird,
aber wenn du gerade erst beginnst, ist das keine so große Sache.</p>
<p>Zuvor haben wir erwähnt, dass ‚ownership‘ das entscheidend neue Konzept in Rust ist.
Im Rust-Jargon sagen wir, dass <code>x</code> den Vektor ‚besitzt‘. Dies bedeutet, dass der
Speicher des Vektors freigegeben wird, wenn <code>x</code> den Scope [engl.: Geltungsbereich]
verlässt. Dieser Vorgang wird deterministisch vom Rust-Compiler
vorgenommen - anstatt durch einen Mechanismus wie einen Garbage Collector.
Dies bedeutet, dass man in Rust selbst keine Funktionen wie <code>malloc</code> und
<code>free</code> aufruft: Der Compiler bestimmt statisch, wann du Speicher allozieren oder
freigeben musst und fügt diese Aufrufe selbst ein. Irren ist menschlich, aber
Compiler vergessen nie.</p>
<p>Lass uns eine weitere Zeile unserem Beispiel hinzufügen:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];

    let y = &amp;x[0];
}
</code></pre></pre>
<p>Wir haben eine weitere Variablenbindung <code>y</code> hinzugefügt. In diesem Fall ist
<code>y</code> eine ‚Referenz‘ auf das erste Element des Vektors. Rusts Referenzen sind
ähnlich wie Zeiger in anderen Sprachen, aber mit zusätzlichen Überprüfungen zur
Kompilierzeit. Referenzen interagieren mit dem <em>ownership</em>-System durch das
<a href="Referenzen_Und_Ausleihen.html">‚Ausleihen‘</a> (borrowing) dessen, worauf sie zeigen.
Der Unterschied ist, dass sie nicht den zugrunde liegenden Speicher freigibt,
wenn die Referenz den Scope verlässt. Falls sie das täte,
dann würden wir zweimal freigeben, was schlecht wäre.</p>
<p>Lass uns eine dritte Zeile hinzufügen. Sie schaut harmlos aus, erzeugt aber
einen Kompilierfehler.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];

    let y = &amp;x[0];

    x.push(&quot;foo&quot;);
}
</code></pre></pre>
<p><code>push</code> ist eine Methode auf Vektoren, die ein weiteres Element an das Ende
des Vektors anhängt. Wenn wir versuchen dieses Programm zu kompilieren, erhalten
wir einen Fehler:</p>
<pre><code class="language-text">error: cannot borrow `x` as mutable because it is also borrowed as immutable
    x.push(&quot;foo&quot;);
    ^
note: previous borrow of `x` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `x` until the borrow ends
    let y = &amp;x[0];
             ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Uff! Der Rust-Compiler erzeugt manchmal recht detailierte Fehlermeldungen und dies ist
ein solches Mal. Wie der Fehler erklärt, ist zwar unsere Variablenbindung veränderbar,
aber wir können immer noch nicht <code>push</code> aufrufen. Das ist so, weil wir bereits
eine Referenz auf ein Element des Vektors - nämlich <code>y</code> - haben. Etwas zu verändern,
während eine weitere Referenz darauf existiert, ist gefährlich, weil wir die
Referenz ungültig machen könnten. In diesem konkreten Fall könnte es sein, dass
wir beim Erstellen des Vektors nur Platz für zwei Elemente reserviert haben.
Ein drittes hinzuzufügen würde dazu führen, einen neuen Speicherbereich für all
diese Elemente zu allozieren, hinüber zu kopieren und den internen Zeiger auf
diesen Speicher zu setzen. Das alles funktioniert problemlos. Das Problem ist,
dass <code>y</code> nicht aktualisiert werden würde und wir somit einen ‚hängenden Zeiger‘
[engl.: dangling pointer] hätten. Das wäre schlecht. Jegliche Benutzung von <code>y</code> wäre in
diesem Fall ein Fehler und somit hat der Compiler diesen für uns abgefangen.</p>
<p>Wie lösen wir also dieses Problem? Es gibt zwei mögliche Lösungsansätze.
Der erste ist eine Kopie zu machen, anstatt eine Referenz zu benutzen:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];

    let y = x[0].clone();

    x.push(&quot;foo&quot;);
}
</code></pre></pre>
<p>Rust hat standardmäßig <a href="Besitz#move-semantics">Move Semantics</a>, daher rufen wir die <code>clone()</code>
Methode auf, wenn wir eine Kopie von irgendwelchen Daten machen wollen.
In diesem Beispiel ist <code>y</code> nicht länger eine Referenz auf den Vektor, der in <code>x</code>
gespeichert ist, sondern eine Kopie des ersten Elements <code>&quot;Hallo&quot;</code>. Nun, da wir
keine Referenz haben, funktioniert unser <code>push()</code> einwandfrei.</p>
<p>Wenn wir wirklich eine Referenz haben wollen, dann brauchen wir die andere
Option: Sicherstellen, dass unsere Referenzen den Scope verlässt, bevor wir die
Veränderung am Vektor vornehmen. Dies sieht so aus:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];

    {
        let y = &amp;x[0];
    }

    x.push(&quot;foo&quot;);
}
</code></pre></pre>
<p>Wir haben einen inneren Scope mittels eines weiteren Paars geschweifter Klammern
erzeugt. <code>y</code> wird den Scope verlassen, bevor wir <code>push()</code> aufrufen, und damit
ist alles in Ordnung.</p>
<p>Dieses Konzept des Besitzes ist nicht nur dazu gut ‚hängende Zeiger‘ zu verhindern,
sondern auch eine ganze Reihe verwandter Probleme zu lösen, wie z.B.
<em>iterator invalidation</em>, Nebenläufigkeit und mehr.</p>
<a class="header" href="print.html#erste-schritte" id="erste-schritte"><h1>Erste Schritte</h1></a>
<p>Dieser erste Abschnitt des Buches wird dich mit Rust und seinen Werkzeugen in
Fahrt bringen. Zuerst werden wir Rust installieren. Dann kommt das klassische
‘Hallo Welt’-Programm. Zum Schluss werden wir über Cargo, dem Buildsystem und
Paketmanager von Rust, reden.</p>
<a class="header" href="print.html#rust-installieren" id="rust-installieren"><h1>Rust installieren</h1></a>
<p>Der erste Schritt um Rust zu nutzen ist es zu installieren. Es gibt eine Reihe
von Möglichkeiten Rust zu installieren, aber die einfachste ist das <code>rustup</code>-Skript
zu verwenden. Wenn du Linux oder einen Mac verwendest, dann ist alles
was du tun musst dies:</p>
<blockquote>
<p>Hinweis: Du darfst nicht die <code>$</code>-Zeichen eintippen. Sie dienen nur dazu, den
Anfang eines jeden Befehls anzuzeigen. Du wirst im Internet viele Tutorials
finden, welche dieser Konvention folgen: <code>$</code> für Befehle die als normaler
Benutzer ausgeführt werden und <code>#</code> für Befehle, welche du als Administrator
ausführen solltest.</p>
</blockquote>
<pre><code class="language-bash">$ curl -sf -L https://static.rust-lang.org/rustup.sh | sh
</code></pre>
<p>Falls du um die <a href="http://curlpipesh.tumblr.com">potenzielle Unsicherheit</a> bezüglich <code>curl | sh</code>
besorgt bist, dann lies bitte weiter und schau dir unseren Disclaimer weiter
unten an. Und benutze ruhig die Zwei-Schritte-Version der Installation und
untersuche unser Installationsskript:</p>
<pre><code class="language-bash">$ curl -f -L https://static.rust-lang.org/rustup.sh -O
$ sh rustup.sh
</code></pre>
<p>Wenn du Windows benutzt, dann lade bitte den passenden
<a href="https://www.rust-lang.org/install.html">Installer</a> herunter.</p>
<p><strong>ACHTUNG:</strong> Der Windows Installer fügt Rust standardmäßig <strong>nicht</strong> der
<code>%PATH%</code>-Systemvariable hinzu. Falls dies die einzige Rust Version ist, die du
installierst und du sie von der Eingabeaufforderung aufrufen können möchtest,
dann klicke im Installationsdialog auf &quot;Advanced&quot; und stelle sicher, dass auf
der &quot;Product Features&quot;-Seite &quot;Add to PATH&quot; auf die Festplatte installiert wird.</p>
<a class="header" href="print.html#deinstallieren" id="deinstallieren"><h2>Deinstallieren</h2></a>
<p>Falls du dich dazu entscheidest Rust nicht mehr haben zu wollen, dann werden
wir ein bisschen traurig sein, aber das ist in Ordnung. Nicht jede
Programmiersprache ist für jeden toll. Führe einfach das Uninstall-Skript aus:</p>
<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>
<p>Falls du den Windows-Installer verwendet hast, dann führe einfach die <code>.msi</code>
erneut aus und dir wird eine Option zum Deinstallieren angezeigt werden.</p>
<a class="header" href="print.html#der-versprochene-disclaimer" id="der-versprochene-disclaimer"><h2>Der versprochene Disclaimer</h2></a>
<p>Manche Leute werden, ein wenig zurecht, sehr verärgert, wenn man ihnen sagt,
dass sie <code>curl | sh</code> ausführen sollen. Im Grunde vertraut man dabei den guten
Leuten, die Rust pflegen, dass sie nicht deinen Computer hacken und böse Dinge
tun. Das ist ein guter Instinkt! Falls du einer dieser Leute bist, dann schau
dir bitte die Dokumentation auf <a href="https://github.com/rust-lang/rust#building-from-source">Rust aus den Quellen erstellen</a>
oder auf <a href="https://www.rust-lang.org/install.html">der offiziellen Binary Downloadseite</a> an.</p>
<a class="header" href="print.html#plattformunterstützung" id="plattformunterstützung"><h2>Plattformunterstützung</h2></a>
<p>Oh, wir sollten auch die offiziell unterstützten Plattformen erwähnen:</p>
<ul>
<li>Windows (7, 8, Server 2008 R2)</li>
<li>Linux (2.6.18 oder neuer, verschiedene Distributionen), x86 und x86-64</li>
<li>OSX 10.7 (Lion) oder neuer, x86 und x86-64</li>
</ul>
<p>Wir testen Rust ausführlich auf diesen Plattformen und ebenfalls auf ein paar
anderen, wie z. B. Android. Aber diese sind jene, die am ehesten funktionieren,
da sie besser getestet sind.</p>
<p>Zuletzt ein Kommentar über Windows. Rust sieht seit seinem Release Windows
als eine First-Class-Plattform an. Aber wenn wir ehrlich sind, ist das Windows
Erlebnis nicht so integriert wie das Linux/OS X Erlebnis ist. Wir arbeiten
daran! Falls etwas nicht funktioniert ist es ein Bug. Lass es uns bitte wissen,
wenn das passiert. Jeder einzelne Commit wird mit Windows getestet, genau wie
bei jeder anderen Plattform.</p>
<a class="header" href="print.html#nach-der-installation" id="nach-der-installation"><h2>Nach der Installation</h2></a>
<p>Wenn du Rust installiert hast, dann kannst du eine Shell/Eingabeaufforderung
öffnen und dies eingeben:</p>
<pre><code class="language-bash">$ rustc --version
</code></pre>
<p>Du solltest eine Versionsnummer, einen Commit-Hash und ein Commit-Datum sehen.
Wenn du gerade die Version 1.3.0 installiert hast, dann solltest du folgendes
sehen:</p>
<pre><code class="language-text">rustc 1.3.0 (9a92aaf19 2015-09-15)
</code></pre>
<p>Falls ja, dann hast du Rust erfolgreich installiert! Gratuliere!</p>
<p>Falls nicht, und du Windows nutzt, dann Prüfe, dass Rust in deiner <code>%PATH%</code>
Systemvariable ist. Wenn nicht, dann starte den Installer nochmal und wähle
&quot;Change&quot; auf der &quot;Change, repair, or remove installation&quot;-Seite und stelle
sicher, dass &quot;Add to PATH&quot; auf die Festplatte installiert wird.</p>
<p>Dieser Installer installiert auch eine lokale Kopie der Dokumentation, sodass
du sie offline lesen kannst. Auf UNIX-Systemen findet man sie in
<code>/usr/local/share/doc/rust</code>. Auf Windows ist sie in dem <code>share/doc</code>-Ordner, wo
auch immer du Rust hin installiert hast.</p>
<p>Falls nicht gibt es eine Reihe von Orten wo du Hilfe bekommen kannst.
Der beste ist
<a href="irc://irc.mozilla.org/#rust">der englischsprachige #rust IRC Channel auf irc.mozilla.org</a>,
welchen du mittels <a href="https://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a> betreten kannst. Klick auf den Link und
Chattest sofort mit anderen Rustlern. Falls du dich lieber auf deutsch
unterhalten möchtest, dann kannst du auch <a href="https://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust-de">#rust-de via Mibbit betreten</a>.
Andere großartige Ressourcen beinhalten das <a href="https://users.rust-lang.org/">Benutzerforum</a> und
<a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<a class="header" href="print.html#hallo-welt" id="hallo-welt"><h1>Hallo Welt!</h1></a>
<p>Nun, da du Rust installiert hast, lass uns dein erstes Rust-Programm schreiben.
Es ist traditionell so, dass man mit dem ersten Programm in einer neuen Sprache
den Text &quot;Hallo Welt!&quot; auf dem Bildschirm ausgeben läßt. Die tolle Sache an so
einem einfachen Programm ist, dass du überprüfen kannst, dass dein Compiler
nicht einfach nur installiert ist, sondern auch ordnungsgemäß funktioniert.
Und Informationen auf dem Bildschirm auszugeben ist eine ziemlich häufige Sache.</p>
<p>Im ersten Schritt müssen wir eine Datei erstellen, in die wir unseren Code packen.
Ich mag es ein <code>projekte</code>-Verzeichnis in meinem Heimverzeichnis zu
erstellen und alle meine Projekte dort aufzubewahren. Rust ist es egal wo dein
Code liegt.</p>
<p>Dies führt sogar zu einer anderen Angelegenheit, welche wir behandeln sollten:
Diese Anleitung wird annehmen, dass du grundlegendend mit der Kommandozeile
vertraut bist. Rust selbst stellt keine besonderen Anforderungen an deine
Editierwerkzeuge oder wo dein Code liegt. Falls du eine IDE der Kommandozeile
vorziehst, dann möchtest du vielleicht <a href="https://github.com/oakes/SolidOak">SolidOak</a> oder Plugins für
deine bevorzugte IDE ausprobieren. Es existieren eine Reihe von Erweiterungen
von unterschiedlicher Qualität, welche von der Community entwickelt werden.
Das Rust-Team liefert auch <a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">Plugins für verschiedene Editoren</a>.
Deine IDE einzurichten sprengt den Rahmen dieses Tutorials, also schau in die
Dokumentation für dein spezielles Setup.</p>
<p>Da dies nun aus dem Raum ist, lass uns damit anfangen ein Verzeichnis in unserem
Projekte Verzeichnis anzulegen.</p>
<pre><code class="language-bash">$ mkdir ~/projekte
$ cd ~/projekte
$ mkdir hallo_welt
$ cd hallo_welt
</code></pre>
<p>Wenn Windows und nicht die Powershell benuzt, dann wird <code>~</code> wohl nicht
funktionieren. Für mehr Details, schaue in die Dokumentation für deine Shell.</p>
<p>Lass uns als nächstes eine neue Quelltextdatei anlegen. Wir werden unsere Datei
<code>main.rs</code> nennen. Rust Dateien haben immer die Endung <code>.rs</code>. Wenn du mehr
als ein Wort in deinem Dateinamen verwendest, dann benutze einen Unterstrich:
<code>hallo_welt.rs</code> anstatt <code>hallowelt.rs</code>.</p>
<p>Nun, da wir unsere Datei offen haben, tippen wir folgenden Quelltext ein:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hallo Welt!&quot;);
}
</code></pre></pre>
<p>Speichere die Datei und tippe dann in die Kommandozeile:</p>
<pre><code class="language-bash">$ rustc main.rs
$ ./main # oder main.exe unter Windows
Hallo Welt!
</code></pre>
<p>Erfolg! Lass uns im Detail durchgehen und sehen, was gerade passiert ist.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Diese Zeilen definieren eine <em>Funktion</em> in Rust. Die <code>main</code>-Funktion ist
besonders: Sie ist der Anfang eines jeden Rust-Programmes. Die erste Zeile sagt
&quot;Ich deklariere eine Funktion namens <code>main</code>, welche keine Argumente entgegen
nimmt und nichts zurückgibt&quot;. Falls es Argumente gäbe, dann würden sie zwischen
den Klammern (<code>(</code> und <code>)</code>) stehen und weil wir nichts von dieser Funktion
zurückgeben, können wir den Rückgabetyp koomplett weglassen. Darauf gehen
wir später ein.</p>
<p>Du wirst auch feststellen, dass die Funktion von geschweiften Klammern (<code>{</code> und
<code>}</code>) umgeben ist. Rust benötigt diese um jeden Funktionskörper herum. Es gilt
als guten Stil die geöffnete Klammer in die selbe Zeile wie die
Funktionsdeklaration, mit einem Leerzeichen dazwischen, zu setzen.</p>
<p>Als nächstes kommt diese Zeile:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hallo Welt&quot;);

#}</code></pre></pre>
<p>Diese Zeile macht die ganze Arbeit in unserem kleinen Programm. Es gibt eine
Zahl von Details die hier wichtig sind. Das erste ist, dass die Zeile mit
vier Leerzeichen anstatt mit Tabs eingerückt ist. Bitte stelle den Editor
deiner Wahl so ein, dass mit der Tab-Taste vier Leerzeichen eingefügt werden.
Wir bieten ein paar <a href="https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md">Beispieleinstellungen für verschiedene Editoren</a>
an.</p>
<p>Der Zweite Punkt ist der <code>println!()-</code>Teil. Dieser ruft ein Rust-<a href="Makros.html">Makro</a>
(so wird Metaprogrammierung in Rust gemacht) auf. Wenn es eine
Funktion wäre, dann würde es so aussehen: <code>println()</code>. Für unsere Zwecke
brauchen wir uns nicht um diesen Unterschied kümmern. Merk dir einfach, dass du
manchmal ein <code>!</code> sehen wirst und es bedeutet, dass du ein Makro anstatt eine
normalen Funktion aufrufst. Rust implementiert aus einem guten Grund
<code>println!</code> als Makro anstatt als normale Funktion. Aber das ist ein
fortgeschrittenes Thema. Eine letzte Sache noch: Rusts-Makros sind bedeutend
anders als C-Makros, falls du die mal benutzt hast. Hab keine Angst Makros zu
benutzen. Wir werden die Details später noch behandeln. Aber für den Moment
musst du uns vertrauen.</p>
<p>Weiter gehts. &quot;Hallo Welt&quot; ist ein ‘String’. Strings sind ein überraschend
kompliziertes Thema in einer Systemprogrammiersprache. Und dies ist ein
‘statisch allokierter’ String. Falls du mehr über Allokierung lesen möchtest,
dann schau dir <a href="Der_Stack_Und_Der_Heap.html">der Stack und der Heap</a> an. Aber du musst es nicht
unbedingt, wenn du nicht möchtest. Wir übergeben den String als Argument an
<code>println!</code>, was dann den String auf dem Bildschirm ausgibt. Leicht genug!</p>
<p>Weiterhin endet die Zeile mit einem Semikolon (<code>;</code>). Rust ist eine
<a href="Glossar.html#ausdrucksorientierte-sprache">‘ausdrucksorientierte’ Sprache</a>. Das bedeuted,
dass die meisten Dinge Ausdrücke anstatt Anweisungen sind. Das <code>;</code> wird
benutzt um anzuzeigen, dass der Ausdruck zuende ist und der nächste beginnen
kann. Die meisten Zeilen in Rust-Code enden mit einem <code>;</code>.</p>
<p>Zum Schluss kompilieren wir unser Programm und lassen es laufen.
Wir können mit unserem Compiler <code>rustc</code> kompilieren, indem wir den Namen
unserer Quelltextdatei angeben:</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>Dies ist ähnlich wie bei <code>gcc</code> oder <code>clang</code>, falls du einen C oder C++
Hintegrund hast. Rust wird eine binäre ausführbare Datei ausgeben.
Du kannst sie mittels <code>ls</code> sehen:</p>
<pre><code class="language-bash">$ ls
main  main.rs
</code></pre>
<p>Oder unter Windows:</p>
<pre><code class="language-bash">$ dir
main.exe  main.rs
</code></pre>
<p>Es existieren nun zwei Dateien: Unser Quellcode mit der <code>.rs</code> Endung und eine
ausführbare Datei (<code>main.exe</code> unter Window, <code>main</code> überall sonst).</p>
<pre><code class="language-bash">$ ./main  # or main.exe on Windows
</code></pre>
<p>Dies gibt nun unseren <code>Hallo Welt!</code>-Text in unserer Kommandozeile aus.</p>
<p>Falls du von dynamischen Sprachen wie Ruby, Python oder JavaScript kommst, dann
bist du vielleicht nicht daran gewöhnt, dass diese zwei Schritte getrennt sind.
Rust ist eine ‘ahead-of-time compiled language’, was bedeutet, dass man ein
Programm kompilieren und dann jemand anderem geben kann ohne, dass diese
Person Rust zur Ausführung benötigt. Wenn man jemandem eine <code>.rb</code>, <code>.py</code> oder
<code>.js</code> gibt, dann benötigt dieser Jemand eine installierte
Ruby-/Python-/JavaScript-Implementierung. Aber man braucht nur einen Befehl um
zu kompilieren und auszuführen. Im Sprachendesign ist alles ein Kompromiss und
Rust hat seine Entscheidung getroffen.</p>
<p>Gratuliere! Du hast nun offiziell ein Rust-Programm geschrieben. Das macht dich
nun zu einem Rust-Programmier! Willkommen.</p>
<p>Als nächstes würde ich dich gerne mit einem anderen Werkzeug bekanntmachen,
nämlich mit Cargo. Dieses wird benutzt, um realitätsnahe Programme zu
schreiben. Nur <code>rustc</code> zu benutzen ist nett für einfache Sachen. Aber während
dein Projekt wächst wirst du etwas haben wollen, was dir hilft alle
Möglichkeiten die dir <code>rustc</code> bietet, zu managen und es dir leicht macht
Code mit anderen Leuten und Projekten zu teilen.</p>
<a class="header" href="print.html#hallo-cargo" id="hallo-cargo"><h1>Hallo Cargo!</h1></a>
<p><a href="http://doc.crates.io">Cargo</a> ist ein Werkzeug, welches Rustler benutzen um ihre Rust
Projekte zu verwalten. Cargo ist derzeit in einem pre-1.0 Zustand und ist somit
immer noch in Arbeit. Jedoch ist es bereits gut genug es für viele Rust Projekte
einzusetzen und somit wird vorausgesetzt, dass Rust Projekte Cargo von Anfang
an einsetzen.</p>
<p>Cargo verwaltet drei Sachen: Das bauen des Codes, das Herunterladen der
Abhängigkeiten, welche dein Projekt benötigt und
das Bauen dieser Abhängigkeiten. Zu Anfang hat dein Programm keine
Abhängigkeiten. Also wirst du nur den ersten Teil an Funktionalität nutzen.
Später wirst du komplexere Programme mit einigen Abhängigkeiten erstellen
und dann macht es sich bezahlt, dass du Cargo von Anfang an genutzt hast.</p>
<p>Wenn du Rust mit dem offiziellen Installer installiert hast, dann wirst du
auch Cargo haben. Wenn du allerdings Rust auf eine andere Art und Weise
installiert hast, dann möchtest du möglicherweise einen Blick in die
<a href="https://github.com/rust-lang/cargo#installing-cargo-from-nightlies">Cargo README</a> werfen um herauszufinden, wie man Cargo installiert.</p>
<a class="header" href="print.html#nach-cargo-umwandeln" id="nach-cargo-umwandeln"><h2>Nach Cargo umwandeln</h2></a>
<p>Lass uns unser 'Hallo Welt'-Projekt nach Cargo umwandeln.</p>
<p>Um ein Projekt zu &quot;Cargoifizieren&quot; benötigen wir drei Dinge:
Erstelle eine <code>Cargo.toml</code> Konfigurationsdatei, lege die Quelltexte an den
richtigen Platz und entferne die alte ausführbare Datei (<code>main.exe</code> unter
Windows, <code>main</code> sonst wo). Lass uns den ersten Teil zuerst machen:</p>
<pre><code class="language-bash">$ mkdir src
$ mv main.rs src/main.rs
$ rm main  # oder main.exe unter Windows
</code></pre>
<p>Da wir eine ausführbare Datei erstellen behalten wir <code>main.rs</code> als
Dateiname bei. Wenn wir stattdessen eine Bibliothek erstellen wollten,
müssten wir <code>lib.rs</code> verwenden. Diese Konvention wird von Cargo benutzt um
unsere Projekte erfolgreich zu kompilieren. Wenn wir wollen, dann können
wir diese Konvention auch außer Kraft setzen.</p>
<p>Cargo erwartet, dass deine Quelltexte in einem <code>src</code>-Verzeichnis liegen.
Das lässt das oberste Verzeichnis für andere Sachen wie READMEs,
Lizenzinformationen und anderen Dingen, die nichts mit deinem
Code zu tun haben, frei.</p>
<!-- A place for everything, and everything in its place. -->
<p>Als nächstes unsere Konfigurationsdatei:</p>
<pre><code class="language-bash">$ editor Cargo.toml
</code></pre>
<p>Stelle sicher, dass der Name korrekt ist: Das große <code>C</code> ist notwendig!</p>
<p>Schreib das hier hinein:</p>
<pre><code class="language-toml">[package]

name = &quot;hallo_welt&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;Dein Name &lt;du@example.com&gt;&quot; ]
</code></pre>
<p>Diese Datei ist im <a href="https://github.com/toml-lang/toml">TOML</a>-Format. TOML ist ähnlich wie INI, aber hat ein
paar tolle Extra-Funktionen. Der TOML-Dokumentation zufolge</p>
<blockquote>
<p>Zielt TOML darauf ab ein minimales Konfigurationsformat zu sein, welches
aufgrund seiner offensichtlichen Semantik, leicht zu lesen ist. TOML ist
dazu designt eindeutig auf eine Hashtabelle abzubilden. Toml sollte in einer
breiten Vielzahl von Sprachen leicht in Datenstrukturen zu parsen sein.</p>
</blockquote>
<p>Sobald wir diese Datei im Wurzelverzeichnis unseres Projektes haben, sind wir
auch schon bereit es zu bauen! Um das zu tun, führe dies aus:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hallo_welt v0.0.1 (file:///home/deinname/projekte/hallo_welt)
$ ./target/debug/hallo_welt
Hallo Welt!
</code></pre>
<p>Bumm! Wir haben unser Projekt mit <code>cargo build</code> gebaut und es mit
<code>./target/debug/hallo_welt</code> ausgeführt. Wir können beides auch in
einem einzigen Schritt machen mittels <code>cargo run</code>:</p>
<pre><code class="language-bash">$ cargo run
     Running `target/debug/hallo_welt`
Hallo Welt!
</code></pre>
<p>Beachte, dass dieses mal das Projekt nicht neu kompiliert wurde. Cargo hat
selber herausgefunden, dass wir den Quelltext nicht verändert haben und hat
einfach nur die Binärdatei ausgeführt. Hätten wir eine Veränderung
vorgenommen, dann hätten wir beides gesehen:</p>
<pre><code class="language-bash">$ cargo run
   Compiling hallo_welt v0.0.1 (file:///home/deinname/projekte/hallo_welt)
     Running `target/debug/hallo_welt`
Hallo Welt!
</code></pre>
<p>Dies hat uns nicht viel mehr eingebracht als einfach nur <code>rustc</code> zu benutzen.
Aber denk an Zukunft: Wenn unser Projekt komplexer wird, dann müssen wir
mehr machen um alle Teile zusammen ordentlich zum Kompilieren zu bringen.
Mit Cargo können wir, während unser Projekt wächst, einfach <code>cargo build</code>
aufrufen und unser Projekt wird sofort auf die richtige Art und Weise gebaut.</p>
<p>Wenn unser Projekt dann endlich fertig zum Release ist, kannst du einfach
<code>cargo build --release</code> benutzen um dein Projekt mit Optimierungen zu
kompilieren.</p>
<p>Du wirst auch feststellen, dass Cargo eine neue Datei erzeugt hat: <code>Cargo.lock</code>.</p>
<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</code></pre>
<p>Die <code>Cargo.lock</code>-Datei wird von Cargo benutzt, um deine Abhängigkeit zu
verfolgen. Im Moment haben wir keine, also ist sie etwas dürftig.
Du wirst diese Datei niemals selber anfassen müssen. Lass einfach Cargo
die Sache regeln.</p>
<p>Das wars! Wir haben <code>hallo_welt</code> erfolgreich mit Cargo gebaut. Obwohl das
Programm simpel ist, benutzt es viele der Werkzeuge die du für den Rest
deiner Rust-Karriere brauchst. <!-- klingt etwas merkwürdig -->
Du kannst erwarten, dass du mit nahezu allen Rust-Projekten so
loslegen kannst:</p>
<pre><code class="language-bash">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</code></pre>
<a class="header" href="print.html#ein-neues-projekt" id="ein-neues-projekt"><h2>Ein neues Projekt</h2></a>
<p>Du brauchst nicht jedes mal durch alle diese Schritte gehen, wenn du ein neues
Projekt anfängst! Cargo hat die Fähigkeit ein Gerüst-Projekt zu erzeugen, mit
dem du sofort anfangen kannst zu entwickeln.</p>
<p>Um eine neues Projekt mit Cargo anzufangen benutze <code>cargo new</code>:</p>
<pre><code class="language-bash">$ cargo new hallo_welt --bin
</code></pre>
<p>Wir übergeben <code>--bin</code>, da es unser Ziel ist eine ausführbare Anwendung,
anstatt einer Bibliothek, zu erzeugen. Ausführbare Dateien werden oft
‘binaries’ genannt.
(So wie in <code>/usr/bin</code>, falls du auf einem Unix System bist).</p>
<p>Lass uns mal sehen welche Dateien Cargo für uns erzeugt hat:</p>
<pre><code class="language-bash">$ cd hallo_welt
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>Falls du den <code>tree</code>-Befehl nicht hast, dann kannst du ihn dir wahrscheinlich
mit hilfe der Paketverwaltung deiner Distribution besorgen. Der Befehl ist nicht
notwendig, aber sicherlich nützlich.</p>
<p>Das ist alles was wir brauchen um loszulegen. Lass uns zuerst die <code>Cargo.toml</code> betrachten.</p>
<pre><code class="language-toml">[package]

name = &quot;hallo_welt&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dein Name &lt;du@example.com&gt;&quot;]
</code></pre>
<p>Cargo hat diese Datei mit einigen Vorgaben, basierend auf den von dir
übergebenen Argumenten und deiner globalen <code>git</code>-Konfiguration, gefüllt.
Du wirst vielleicht bemerken, dass Cargo das <code>hallo_welt</code>-Verzeichnis auch
als <code>git</code>-Repository initialisiert hat.</p>
<p>Das hier steht in der <code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo hat ein &quot;Hallo Welt!&quot; für uns erzeugt und du kannst sofort mit dem Coden
loslegen!
Cargo hat seinen eigenen <a href="http://doc.crates.io/guide.html">Guide</a>, welcher die Features von Cargo in
größerem Detail behandelt.</p>
<p>Da du nun mit den Werkzeugen vertraut bist, lass uns tatsächlich mehr über
die Sprache Rust selbst lernen. Dies sind die Grundlagen, welche dir den Rest
deiner Zeit mit Rust sehr dienlich sein werden.</p>
<p>Du hast Zwei Möglichkeiten:
Entweder stürzt du dich in ein Projekt mit ‘<a href="Lerne_Rust.html">Lerne Rust</a>’,
oder du arbeitest dir deinen Weg von unten nach oben mit
‘<a href="Syntax_Und_Semantik.html">Syntax und Semantik</a>’.
Erfahrene Systemprogrammierer werden ‘Lerne Rust’ mit sicherheit vorziehen, während Leute
mit Hintergrund in dynamischen Sprachen beides bevorzugen könnten.
Verschiedene Leute lernen verschieden! Wähle was Dir am besten liegt.</p>
<a class="header" href="print.html#lerne-rust" id="lerne-rust"><h1>Lerne Rust</h1></a>
<p>Willkommen! Dieser Abschnitt enthält ein paar Tutorials, welche dir Rust durch
aufbauen eines Projektes beibringen. Du wirst zuerst eine umfassende Übersicht
bekommen, Details werden wir aber überfliegen.</p>
<p>Falls du Rust lieber von Grund auf lernen möchtest, dann schau dir den Teil
<a href="Syntax_Und_Semantik.html">Syntax und Semantik</a> an.</p>
<a class="header" href="print.html#ratespiel" id="ratespiel"><h1>Ratespiel</h1></a>
<p>Für unser erstes Projekt wollen wir eine
klassische Anfängeraufgabe implementieren: das Ratespiel.
So funktioniert es: Unser Programm wird eine zufällige
ganze Zahl zwischen eins und hundert erzeugen.
Es wird uns dann auffordern, sie zu erraten.
Bei einem Rateversuch wird es uns sagen, ob wir zu niedrig oder zu hoch liegen.
Sobald wir richtig raten, wird es uns gratulieren. Klingt das gut?</p>
<a class="header" href="print.html#anlegen" id="anlegen"><h1>Anlegen</h1></a>
<p>Lass uns ein neues Projekt anlegen. Gehe in dein Projekteverzeichnis.
Erinnerst du dich wie wir die Verzeichnisstruktur und eine <code>Cargo.toml</code> für
<code>hallo_welt</code> anlegen mussten? Cargo hat ein Befehl dafür, welcher das für uns
erledigt. Lass uns den ausprobieren:</p>
<pre><code class="language-bash">$ cd ~/projekte
$ cargo new ratespiel --bin
$ cd ratespiel
</code></pre>
<p>Wir übergeben den Namen unseres Projektes und – da wir eine Binärdatei
anstatt eine Bibliothek erstellen – <code>--bin</code> an <code>cargo new</code>.</p>
<p>Schau dir mal die erzeugte <code>Cargo.toml</code> an:</p>
<pre><code class="language-toml">[package]

name = &quot;ratespiel&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dein Name &lt;du@example.com&gt;&quot;]
</code></pre>
<p>Cargo holt diese Informationen aus deiner Betriebssystemumgebung. Wenn diese
nicht korrekt sind, dann korrigiere sie ruhig.</p>
<p>Schließlich generiert Cargo noch ein <code>Hallo Welt</code> für uns.
Schau dir die <code>src/main.rs</code> an:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Lass uns versuchen das, was uns Cargo gegeben hat, zu kompilieren:</p>
<pre><code class="language-{bash}">$ cargo build
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
</code></pre>
<p>Ausgezeichnet! Öffne nochmal deine <code>src/main.rs</code>. Wir werden unseren ganzen
Code in diese Datei schreiben.</p>
<p>Lass mich dir noch einen weiteren Cargo Befehl zeigen: <code>run</code>. <code>cargo run</code>
ist fast  wie <code>cargo build</code>, aber führt zusätzlich noch die erzeugte ausführbare
Datei aus.</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/debug/ratespiel`
Hello, world!
</code></pre>
<p>Prima! Der <code>run</code> Befehl ist sehr praktisch, wenn man sein Projekt häufig
widerholt ausprobieren möchte. Unser Spiel ist ein solches Projekt und wir
müssen jeden Schritt zügig testen können bevor wir mit dem Nächsten fortfahren.</p>
<a class="header" href="print.html#einen-rateversuch-verarbeiten" id="einen-rateversuch-verarbeiten"><h1>Einen Rateversuch verarbeiten</h1></a>
<p>Also lass uns anfangen! Das erste, was für unser Ratespiel tun müssen, ist dem
unserem Spieler zu erlauben eine Vermutung einzugeben. Schreib das hier
in deine <code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use std::io;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);

    let mut vermutung = String::new();

    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Deine Vermutung: {}&quot;, vermutung);
}
</code></pre></pre>
<p>Das ist eine Menge! Lass es uns Schritt für Schritt durchgehen.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::io;

#}</code></pre></pre>
<p>Wir werden Benutzereingaben entgegennehmen und dann das Ergebnis ausgeben.
Dazu verwenden wir das <code>io</code>-Modul aus der Standardbibliothek. Rust
importiert standardmäßig ein paar Dinge in jedes Programm,
<a href="https://doc.rust-lang.org/std/prelude/index.html">das ‘Prelude’</a>. Wenn etwas nicht im Prelude ist, dann musst
du es mittels <code>use</code> importieren.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
</code></pre></pre>
<p>Wie du zuvor schon gesehen hast, ist die <code>main()</code>-Funktion der Startpunkt
in deinem Programm. Die <code>fn</code>-Syntax deklariert eine neue Funktion, die <code>()</code>
zeigen an, dass es keine Argumente gibt und <code>{</code> beginnt den
Körper der Funktion. Weil wir keinen Rückgabewert angegeben haben, wird
automatisch angenommn, dass dieser <code>()</code>, ein leeres <a href="Primitive_Typen.html#Tupel">Tupel</a> ist.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);

#}</code></pre></pre>
<p>Wir haben zuvor gelernt, dass <code>println!()</code> ein <a href="Makros.html">Makro</a> ist, dass
einen <a href="Strings.html">String</a> auf dem Bildschirm ausgibt.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    let mut vermutung = String::new();

#}</code></pre></pre>
<p>Nun wird es interessant! In dieser kleinen Zeile ist eine Menge los.
Das erste ist eine <a href="Variablenbindung.html">let-Anweisung</a>. Diese wird verwendet,
um ‘Variablenbindungen’ zu erzeugen. Sie nehmen diese Form an:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let foo = bar;

#}</code></pre></pre>
<p>Dies wird eine neue Bindung namens <code>foo</code> erzeugen
und den Wert <code>bar</code> daran binden. In vielen Sprachen wird das eine ‘Variable’
genannt, aber Rusts Variablenbindungen haben ein paar Tricks in ihren Ärmeln.</p>
<p>Zum Beispiel sind sie standardmäßig <em>immutable</em> [unveränderbar]. Deswegen
benutzt unser Beispiel <code>mut</code>: Es macht eine Bindung <em>mutable</em> [veränderbar]
anstatt <em>immutable</em>. Auf der linken Seite der Zuweisung akzeptiert <code>let</code>
nicht einfach nur einen Namen, es akzeptiert sogar ‘<a href="Muster.html">Muster</a>’.
Wir werden Muster später noch verwenden. Es ist fürs erste leicht genug
zu benutzen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let foo = 5; // immutable (unveränderbar)
let mut bar = 5; // mutable (veränderbar)

#}</code></pre></pre>
<p>Oh, und <code>//</code> leitet einen Kommentar bis zum Ende der Zeile ein.
Rust ignoriert alles in <a href="Kommentare.html">Kommentaren</a>.</p>
<p>So, nun wissen wissen wir, dass <code>let mut vermutung</code> eine neue Variablenbindung
namens <code>vermutung</code> einführt, aber wir müssen noch auf die andere Seite des <code>=</code>
schauen woran sie gebunden ist: <code>String::new()</code>.</p>
<p><code>String</code> ist ein String typ, welcher von der Standardbibliothek zur Verfügung
gestellt wird. Ein <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> ist ein UTF-8 kodierter Text,
der wachsen kann.</p>
<p>Die <code>::new()</code> Syntax benutzt <code>::</code> weil es eine ‘assoziierte Funktion’ eines
bestimmten Typs ist. Sprich, es ist mit <code>String</code> selbst assoziiert,
anstatt mit einer Instanz von <code>String</code>. Manche Sprachen nennen das eine
‘statische Methode’.</p>
<p>Diese Funktion heißt <code>new()</code>, da sie einen neuen, leeren <code>String</code>.
Du wirst bei vielen Typen eine <code>new()</code> Funktion finden, da es ein typischer
Name ist um irgendeine Art von neuen Wert zu erzeugen.</p>
<p>Lass uns weiter machen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

#}</code></pre></pre>
<p>Das ist eine Menge mehr! Lass uns das wieder Schritt für Schritt durchgehen.
Die erste Zeile besteht aus zwei Teilen. Hier ist der erste:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
io::stdin()

#}</code></pre></pre>
<p>Erinnerst du dich wie wir <code>use</code> in der ersten Zeile des Programmes benutzt
haben um <code>std::io</code> zu importieren? Wir rufen nun eine Assozierte Funktion davon
auf. Wenn wir <code>use std::io</code> nicht verwendet hätten, dann hätten wir diese
Zeile als als <code>std::io::stdin()</code> schreiben können.</p>
<p>Diese spezielle Funktion gibt uns ein Handle für die Standardeingabe deines
Terminals. Genauer gesagt ein <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a>.</p>
<p>Der nächste Teil wird dieses Handle verwenden um an die Eingaben des Benutzers
zu gelangen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
.read_line(&amp;mut vermutung)

#}</code></pre></pre>
<p>Here rufen wir die <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line()</code></a> Methode unseres Handle auf.
<a href="Methodensyntax.html">Methoden</a> sind wie assoziierte Funktionen, aber sind nur für eine
jeweilige Instanz eines Types verfügbar, anstatt für den Typ selbst. Wir
übergeben außerdem ein Argument an <code>read_line()</code>: <code>&amp;mut vermutung</code>.</p>
<p>Erinnerst du dich wir oben <code>vermutung</code> gebunden haben? Wir hatten gesagt, dass
es <em>mutable</em> ist. Jedoch nimmt <code>read_line</code> keinen <code>String</code> als Argument: Es
nimmt einen <code>&amp;mut String</code>. Rust hat ein Feature namens
‘<a href="Referenzen_Und_Ausleihen.html">Referenzen</a>’, welches einem erlaubt mehrere Referenzen auf ein
Stück Daten zu haben, was kopieren reduzieren kann. Referenzen sind ein
komplexes Feature, da eines von Rusts Hauptverwendungsargumenten ist, wie sicher
und einfach es ist, Referenzen zu benutzen. Wir müssen jedoch nicht viele dieser
Details wissen um unser Programm im Moment zu vollenden.
Fürs Erste ist alles was wir kennen müssen, dass, ähnlich wie <code>let</code>
Bindungen, Referenzen standardmäßig <em>immutable</em> sind. Daher müssen wir
<code>&amp;mut vermutung</code> schreiben anstatt <code>&amp;vermutung</code>.</p>
<p>Warum nimmt <code>read_line()</code> eine <em>mutable</em> Referenz eines String? Der Job dieser
Funktion ist es die Eingaben des Benutzers auf der Standardeingabe zu nehmen
und in einem String zu platzieren. Also nimmt sie einen String als
Argument, und um die Eingabe hinzuzufügen muss dieser <em>mutable</em> sein.</p>
<p>Aber wir sind noch nicht ganz fertig mit dieser Zeile Code.
Während es sich um eine einzelne Textzeile handelt, ist es nur der erste
Teil einer einzelnen logischen Zeile an Code:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

#}</code></pre></pre>
<p>Wenn man eine Methode mit der <code>.foo()</code> Syntax aufruft, dann darf man eine
neue Zeile oder andere Leerzeichen einführen.
Dies hilft einem lange Zeilen aufzuteilen. Wir <em>hätten</em> auch das tun können:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    io::stdin().read_line(&amp;mut vermutung).ok().expect(&quot;Fehler beim Lesen der Zeile&quot;);

#}</code></pre></pre>
<p>Aber das ist schwerer zu lesen. Also haben wir es aufgeteilt in drei Zeilen für
drei Methodenaufrufe. Wir haben bereits über <code>read_line()</code> geredet,
aber was ist mit <code>ok()</code> und <code>expect()</code>? Nun, wir haben bereits erwähnt,
dass <code>read_line()</code> das, was der Benutzer eingibt, in den <code>&amp;mut String</code> steckt,
den wir ihr übergeben. Aber sie gibt auch einen Wert zurück:
In diesem Fall ein <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. Rust hat eine Reihe von Typen
namens <code>Result</code> in seiner Standardbibliothek:
Einen allgemeines <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> und spezifische Versionen für
unter-bibliotheken, wie z.B. <code>io::Result</code>.</p>
<p>Der Zweck dieser <code>Result</code> Typen ist Informationen zur Fehlerbehandung bereit
zu stellen. Werte des <code>Result</code> Typ besitzen, wie jeder Typ, Methoden.
In diesem Fall hat <code>io::Result</code> eine <code>ok()</code> Methode, welche sagt
&quot;wir möchten annehmen, dass dieser Wert ein erfolgreicher ist&quot;. Falls nicht,
schmeißen wir einfach die Fehlerinformation weg. Warum sie wegwerfen? Nun,
für ein einfaches Programm wollen wir einfach einen allgemeinen Fehler
ausgeben, da im Grunde jeder Fehler bedeutet, dass wir nicht
fortfahren können. Die <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.ok"><code>ok()</code> Methode</a> gibt einen Wert zurück, welcher
eine weitere Methode besitzt: <code>expect()</code>. Die <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect()</code>-Methode</a>
nimmt einen Wert auf dem sie aufgerufen wird und, falls dieser kein
erfolgreicher ist, wird eine <a href="Fehlerbehandlung.html"><code>panic</code></a> mit der Nachricht, die man
übergeben hat, erzeugt. Eine <code>panic</code> wie diese sorgt dafür, dass unser Programm
abstürzt und die Nachricht anzeigt.</p>
<p>Falls wir diese beiden Methodenaufrufe weglassen wird unser Programm zwar
kompilieren, aber wir werden eine Warnung bekommen:</p>
<pre><code class="language-bash">$ cargo build
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut vermutung);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Rust warnt uns, dass wir den <code>Result</code> Wert nicht verwendet haben.
Diese Warnung stammt von einer speziellen Anmerkung, die <code>io::Result</code> hat.
Rust versucht dir zu sagen, dass du einen möglichen Fehler nicht behandelt
hast. Der richtige Weg um den Fehler zu unterdrücken ist eigentlich
Fehlerbehandlung zu schreiben. Glücklicherweise können wir diese zwei kleinen
Methoden verwenden, falls uns ein Crash in Ordnung ist, wenn es einen Fehler
gibt. Falls wir uns von dem Fehler irgendwie erholen können, dann würden
wir etwas anderes machen, aber das bewahren wir uns für ein zukünftiges
Projekt auf.</p>
<p>Es gibt nurnoch eine übrige Zeile dieses ersten Beispiels:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    println!(&quot;Deine Vermutung: {}&quot;, vermutung);

#}</code></pre></pre>
<p>Dies gibt den, in dem wir unsere Eingabe gespeichert haben, aus.
Die <code>{}</code> sind Platzhalter, und somit übergeben wir <code>vermutung</code> daran.
Hätten wir mehrere <code>{}</code>, dann würde wir mehrere Argumente übergeben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x und y: {} und {}&quot;, x, y);

#}</code></pre></pre>
<p>Einfach.</p>
<p>Jedenfalls war das die Tour.  Mit <code>cargo run</code> können wir ausführen,
was wir bereits haben:</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/debug/ratespiel`
Rate die Zahl!
Bitte gib deine Vermutung ein.
6
Deine Vermutung:  6
</code></pre>
<p>Also gut! Unser erster Teil ist fertig: Wir können Eingaben von der Tastatur
holen und sie wieder ausgeben.</p>
<a class="header" href="print.html#eine-geheime-zahl-erzeugen" id="eine-geheime-zahl-erzeugen"><h1>Eine geheime Zahl erzeugen</h1></a>
<p>Als nächstes müssen wir eine zufällige Zahl erzeugen. Rust hat noch keine
Möglichkeit um Zufallszahlen zu erzeugen in seiner Standardbibliothek.
Das Rust Team hat jedoch eine <a href="https://crates.io/crates/rand"><code>rand</code> Crate</a> zur Verfügung gestellt.
Eine ‘Crate’ [engl.: Kiste] ist ein Paket aus Rust Code.
Wir haben bereits eine ‘binary crate’ gebaut,
was eine ausführbare Datei ist.
<code>rand</code> ist eine ‘library crate’, welche den Code enthält,
der dazu Gedacht ist von anderen Programmen als Bibliothek verwendet zu
werden.</p>
<p>Cargo ist wirklich gut darin externe Crates zu verwenden. Bevor wir Code
schreiben können der <code>rand</code> verwendet, müssen wir unsere <code>Cargo.toml</code>
anpassen. Öffne sie und füge diese paar Zeilen am Ende an:</p>
<pre><code class="language-toml">[dependencies]

rand=&quot;0.3.0&quot;
</code></pre>
<p>Der <code>[dependencies]</code> Abschnitt der <code>Cargo.toml</code> ist wie der <code>[package]</code>
Abschnitt: Alles was diesem folgt gehört dazu, bis ein nächster Abschnitt
beginnt. Cargo benutzt den <em>dependencies</em> Abschnitt um zu wissen, welche
Abhängigkeiten an externen Crates du hast und welche Version du benötigst.
In diesem Fall haben wir Version <code>0.3.0</code> spezifiziert, was Cargo als ein
Release versteht, der mit dieser spezifischen Version kompatibel ist.
Cargo versteht <a href="http://semver.org">Semantische Versionierung</a>, was ein Standard ist,
um Versionsnummern zu schreiben. Falls wir nur exakt <code>0.3.0</code> verwenden wollten,
dann könnten wir <code>=0.3.0</code> schreiben. Falls wir die neueste Version verwenden
wollten, dann könnten wir <code>*</code> verwenden; wir könnten eine Bereich von
Versionen verwenden. <a href="http://doc.crates.io/crates-io.html">Cargos Dokumentation</a> enthält mehr Details.</p>
<p>Nun lass uns, ohne unseren Code zu ändern, das Projekt neu kompilieren:</p>
<pre><code class="language-bash">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
</code></pre>
<p>(Du könntest natürlich andere Versionen sehen.)</p>
<p>Das ist eine Menge an neuer Ausgabe! Nun da wir eine externe Abhängigkeit
haben holt Cargo die aktuellste Version von allem aus der Registry, was
eine Kopie der Daten auf <a href="https://crates.io">Crates.io</a> ist. Crates.io ist der Ort,
wo Leute im Rust Ökosystem ihre Open-Source Projekte veröffentlichen,
um sie für andere zur Verfügung zu stellen.</p>
<p>Nach dem aktualisieren der Registry prüft Cargo unsere <code>[dependencies]</code> und
lädt alle, die wir noch nicht haben, herunter. In diesem Fall laden wir uns
auch eine Kopie der <code>libc</code> Crate, obwohl wir gesagt haben, dass wir nur von
der <code>rand</code> Crate abhängen wollen. Das ist so weil <code>rand</code> von <code>libc</code> abhängt
um zu funktionieren. Nach dem herunterladen kompiliert Cargo diese und danach
unser Projekt.</p>
<p>Falls wir <code>cargo build</code> nochmal ausführen,
dann werden wir eine andere Ausgabe bekommen:</p>
<pre><code class="language-bash">$ cargo build
</code></pre>
<p>Genau, keine Ausgabe! Cargo weis, dass unser Projekt schon kompiliert wurde
und, dass alle unsere Abhängigkeiten kompiliert sind, also gibt es keinen
Grund diesen ganzen Kram zu machen. Da es nichts zu tun gibt, beendet es sich
einfach. Falls wir die <code>src/main.rs</code> nochmal öffnen und eine trviale Änderung
vornehmen und speichern, dann werden wir nur eine Zeile sehen:</p>
<pre><code class="language-bash">$ cargo build
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
</code></pre>
<p>So, wir haben Cargo gesagt, dass wir irgendeine <code>0.3.x</code> Version von <code>rand</code>
wollen, also hat es die aktuellste Version
(zur der Zeit als dies hier verfasst wurde) <code>v0.3.8</code> heruntergeladen.
Aber was passiert, wenn nächste Woche Version <code>v0.3.9</code> mit einem wichtigen
Bugfix herauskommt? Während Bugfixes zwar wichtig sind, was ist wenn <code>0.3.9</code>
Regressionen enthält, die das kompilieren mit unserem Code verhindern?</p>
<p>Die Antwort auf dieses Problem ist die <code>Cargo.lock</code> Datei, die du nun in
deinem Projektvrzeichniss finden wirst. Wenn du ein Projekt das erste mal
kompilierst, dann findet Cargo die ganzen Versionen heraus, die deinen
Kriterien entsprechen, und schreibt sie in die <code>Cargo.toml</code>. Wenn du dein
Projekt in der Zukunft kompilierst, dann sieht Cargo, dass die <code>Cargo.lock</code>
existiert und benutzt dann nur die darin spezifizierten Versionen, anstatt
nochmal alles erneut herauszufinden. Damit hat man automatisch
reproduzierbare Builds. In anderen Worten, du bleibst solange bei Version
<code>0.3.8</code> bis wir ausdrücklich upgraden, das gleiche gilt für jeden mit dem
wir unseren Code teilen, dank dieser Sperrdatei.</p>
<p>Was ist nun, wenn wir <code>v0.3.9</code> <em>doch</em> nutzen wollen? Cargo hat einen anderen
Befehl, <code>update</code>, der besagt &quot;ignoriere die Sperrdatei, finde die neusten
Versionen heraus die zu meiner Spezifikation passen. Falls das funktioniert,
schreibe diese Versionen in die Sperrdatei&quot;. Aber standardmäßig wird
Cargo nur nach Versionen größer als <code>0.3.0</code> und kleiner als <code>0.4.0</code> schauen.
Falls wir weiter zu <code>0.4.x</code> wollten, dann müssten wir das direkt in die
<code>Cargo.toml</code> eintragen. Wenn wir das täten, dann würde Cargo beim nächsten
<code>cargo build</code> den Index neu laden und unsere <code>rand</code> Anforderungen neu
auswerten.</p>
<p>Es gibt noch eine Menge mehr über <a href="http://doc.crates.io">Cargo</a> und seinem
<a href="http://doc.crates.io/crates-io.html">Ökosystem</a> zu erzählen, aber für das erste ist das alles
was wir wissen müssen. Cargo macht es wirklich einfach Bibliotheken
wiederzuverwenden und deswegen neigen Rustler dazu kleinere Projekte zu
schreiben, welche aus einer Reihe von Unterpaketen zusammengebaut sind.</p>
<p>Lass uns beginnen die <code>rand</code> Crate tasächlich zu <em>benutzen</em>. Hier ist unser
nächster Schritte:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);

    let mut vermutung = String::new();

    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Deine Vermutung: {}&quot;, vermutung);
}
</code></pre></pre>
<p>Das erste was wir gemacht haben ist die erste Zeile zu ändern. Dort steht nun
<code>extern crate rand</code>. Weil wir <code>rand</code> in unseren <code>[dependencies]</code> deklariert
deklariert haben, können wir <code>extern crate</code> benutzen um Rust wissen zu lassen,
dass wir sie benutzen. Dies ist außerdem das äquivalent zu einem <code>use rand;</code>,
sodass wir alles in der <code>rand</code> Crate erreichen können, indem wir es mit
<code>rand::</code> einleiten.</p>
<p>Als nächstes fügen wir noch eine weitere <code>use</code> Zeile hinzu: <code>use rand::Rng</code>.
Wir werden gleich eine Methode verwenden, welche erfordert, dass <code>Rng</code>
im Scope ist. Die grundlegende Idee ist folgende: Methoden können auf
sogenannten <code>Traits</code> definiert werden und, damit diese Methoden funktionieren,
müssen sie im aktuellen Scope sein. Für weitere Details lies den
Abschnitt <a href="Traits.html">Traits</a>.</p>
<p>Es gibt zwei weitere Zeilen, die wir in der Mitte hinzugefügt haben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

#}</code></pre></pre>
<p>Wir benutzen die <code>rand::thread_rng()</code>-Funktion, um eine Kopie des
Zufallszahlengenerators zu erhalten, welcher dem aktuellen
<a href="Nebenl%C3%A4ufigkeit.html">Thread</a>, in dem wir sind, angehört.
Weil wir oben <code>use rand::Rng</code> verwendet haben, hat dieser Generator eine
<code>gen_range()</code> Methode zur Verfügung. Diese Methode nimmt zwei Argumente und
generiert eine Zahl, die zwischen diesen beiden liegt.
Der Bereich ist einschließlich dem unteren Ende und ausschließlich dem oberen
Ende, also brauchen wir <code>1</code> und <code>101</code> um eine Zahl zwischen eins bis hundert
zu erhalten.</p>
<p>Die zweite Zeile gibt einfach die geheime Zahl aus. Das ist nützlich während
wir unser Programm entwickeln, damit wir es leicht testen können.
Aber wir werden es aus der finalen Version entfernen. Es ist wohl kaum ein
Spiel, wenn es die Antwort schon beim Start ausgibt!</p>
<p>Versuche unser neues Programm ein paar mal auszuführen:</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/debug/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 7
Bitte gib deine Vermutung ein.
4
Deine Vermutung: 4
$ cargo run
     Running `target/debug/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 83
Bitte gib deine Vermutung ein.
5
Deine Vermutung: 5
</code></pre>
<p>Super! Weiter: Lass uns die Vermutung mit der geheimen Zahl vergleichen.</p>
<a class="header" href="print.html#vermutungen-vergleichen" id="vermutungen-vergleichen"><h1>Vermutungen vergleichen</h1></a>
<p>Nun da wir unsere Benutzereingabe haben, lass uns unsere Vermutung mit der
Zufallszahl vergleichen. Hier ist unser nächster Schritt, auch wenn er
<strong>noch nicht wirklich kompiliert</strong>:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);

    let mut vermutung = String::new();

    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Deine Vermutung: {}&quot;, vermutung);

    match vermutung.cmp(&amp;geheime_zahl) {
        Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
    }
}
</code></pre></pre>
<p>Es gibt ein paar neue Sachen hier. Das erste ist ein weiteres <code>use</code>.
Wir importieren einen Typ namens <code>std::cmp::Ordering</code> in den aktuellen Scope.
Dann benutzen wir ihn ein paar Zeilen später:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    match vermutung.cmp(&amp;geheime_zahl) {
        Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
    }

#}</code></pre></pre>
<p>Die <code>cmp()</code> Methode kann auf allem aufgerufen werden,
was verglichen werden kann und nimmt eine Referenz auf die Sache, mit der wir
es vergleichen wollen. Es gibt den Typ <code>Ordering</code> zurück, den wir zuvor
mit <code>use</code> importiert haben. Wir benutzen eine <a href="Match.html"><code>Match</code></a> Anweisung um
festzustellen welche <code>Ordering</code> genau vorliegt. <code>Ordering</code> ist ein
<a href="Enums.html"><code>Enum</code></a>, kurz für ‘enumeration’ [engl.: Aufzählung], was so aussieht:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
enum Foo {
    Bar,
    Baz,
}

#}</code></pre></pre>
<p>Mit dieser Definition ist der mögliche Wert des Typs <code>Foo</code>
entweder <code>Foo::Bar</code> oder <code>Foo::Baz</code>. Wir benutzen die <code>::</code> um den Namensraum
einer jeweiligen <code>enum</code> Variante anzuzeigen.</p>
<p>Das <a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>Ordering</code></a> <code>enum</code> hat drei mögliche Varianten:
<code>Less</code>, <code>Equal</code> und <code>Greater</code>. Die <code>match</code> Anweisung nimmt den Wert eines Typen
und lässt dich einen ‘Zweig’ für jeden möglichen Wert erstellen. Da wir drei
Arten von <code>Ordering</code> haben, haben wir drei Zweige:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    match vermutung.cmp(&amp;geheime_zahl) {
        Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
    }

#}</code></pre></pre>
<p>Falls der Wert <code>Less</code> ist, geben wir <code>Zu klein!</code> aus, falls er <code>Greater</code> ist,
<code>Zu groß!</code> und ist er <code>Equal</code>, dann <code>Gewonnen!</code>. <code>match</code> ist sehr nützlich und
wird häufig in Rust verwendet.</p>
<p>Ich hatte aber erwähnt, dass dieser Code so noch nicht ganz kompiliert.
Mal probieren:</p>
<pre><code class="language-bash">$ cargo build
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
src/main.rs:28:25: 28:40 error: mismatched types:
 expected `&amp;collections::string::String`,
    found `&amp;_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match vermutung.cmp(&amp;geheime_zahl) {
                                       ^~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `ratespiel`.
</code></pre>
<p>Uff! Das ist ein großer Fehler. Sein Kern ist, dass wir <code>mismatched types</code>,
also nicht zusammenpassende Typen haben. Rust hat ein starkes, statisches
Typensystem. Es hat jedoch auch Typinferenz.
Als wir <code>let vermutung = String::new()</code> geschrieben haben war Rust in der Lage
abzuleiten, dass <code>vermutung</code> ein <code>String</code> sein sollte und somit mussten wir
nicht den Typ ausdrücklich aufschreiben. Und bei unserer <code>geheime_zahl</code> Variable
gibt es eine Reihe von Typen, die den Wert eins bis hundert annehmen können:
<code>i32</code>, eine 32-bit Ganzzahl, oder <code>u32</code>, eine vorzeichenlose 32-bit
Ganzzahl, oder <code>i64</code>, eine 64-bit Ganzzahl, oder andere.
Soweit war das nicht wichtig, weswegen Rust standardmäßig <code>i32</code> gewählt hat.
Jedoch weis Rust hier nicht wie es <code>vermutung</code> und die <code>geheime_zahl</code>
vergleichen soll. Sie müssen vom selben Typ sein. Letztlich wollen wir für
den Vergleich den <code>String</code>, den wir von der Eingabe lesen,
in eine richtigen Zahlentyp umwandeln. Wir können das mit drei weiteren Zeilen
erledigen. Hier ist unser neues Programm:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);

    let mut vermutung = String::new();

    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    let vermutung: u32 = vermutung.trim().parse()
        .ok()
        .expect(&quot;Bitte eine Zahl eintippen!&quot;);

    println!(&quot;Deine Vermutung: {}&quot;, vermutung);

    match vermutung.cmp(&amp;geheime_zahl) {
        Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
    }
}
</code></pre></pre>
<p>Die drei neuen Zeilen sind:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
    let vermutung: u32 = vermutung.trim().parse()
        .ok()
        .expect(&quot;Bitte eine Zahl eintippen!&quot;);

#}</code></pre></pre>
<p>Augenblick mal, ich dachte wir hätten bereits eine <code>vermutung</code>? Ja, haben wir,
aber Rust erlaubt uns die vorherige <code>vermutung</code> mit einer neuen zu verdecken.
Dies wird häufig in genau dieser Situationen benutzt, wo <code>vermutung</code> als
<code>String</code> beginnt, wir es es aber in ein <code>u32</code> umwandeln möchten. Verdeckung von
Variablen lässt uns den Name <code>vermutung</code> wiederverwenden, anstatt wir gezwungen
sind uns einen neuen eindeutigen Namen wie <code>vermutung_str</code> und <code>vermutung</code>,
oder ähnlich, auszudenken.</p>
<p>Wir binden <code>vermutung</code> an einen Ausdruck, der so ähnlich wie ein vorheriger
aussieht:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
vermutung.trim().parse()

#}</code></pre></pre>
<p>Gefolgt von einem <code>ok().expect()</code> Aufruf. Hier verweist <code>vermutung</code> noch auf
die alte <code>vermutung</code>, jene, die ein String mit unserer Eingabe war. Die <code>trim()</code>
Methode auf <code>String</code>s eliminiert jegliche Form von Leerzeichen am Anfang und
am Ende unseres Strings. Das ist wichtig, da wir die Entertaste drücken mussten
um <code>read_line()</code> zufrieden zu stellen. Das bedeutet, dass, wenn wir <code>5</code>
eingeben und Enter drücken, <code>vermutung</code> so aussieht: <code>5\n</code>. Das <code>\n</code> stellt
eine neue Zeile dar (erzeugt durch die Entertaste). <code>trim()</code> entfernt das und
in unserem String bleibt nur die <code>5</code> übrig.
Die <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code> Methode auf Strings</a> parst unseren String in einen
Zahlentyp. Da es verschiedene mögliche Zahlentypen gibt, müssen wir Rust einen
Hinweis geben welchen Zahlentyp wir denn genau haben wollen.
Deswegen <code>let vermutung: u32</code>.
Der Doppelpunkt (<code>:</code>) nach <code>vermutung</code> sagt Rust,
dass wir dessen Typ anmerken wollen.
<code>u32</code> ist eine vorzeichenlose 32-bit Ganzzahl.
Rust hat <a href="Primitive_Typen#numerische-typen">eine Reihe eingebauter Zahlentypen</a>,
aber wir haben <code>u32</code> gewählt.
Es ist eine gute Standardwahl für eine kleine positive Zahl.</p>
<p>Genauso wie <code>read_line()</code>, kann unser Aufruf von <code>parse()</code> einen Fehler
verursachen. Was ist, wenn unser String <code>A❤%</code> enthielte? Es gibt keine
Möglichkeit das in eine Zahl umzuwandeln. Deswegen werden wir dasselbe
wie mit <code>read_line()</code> gemachen: Wir benutzen die <code>ok()</code> und <code>expect()</code>
Methoden um unser Programm bei einem Fehler zu crashen.</p>
<p>Lass uns unser Programm ausprobieren!</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/you/projects/ratespiel)
     Running `target/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 58
Bitte gib deine Vermutung ein.
  76
Deine Vermutung: 76
Zu groß!
</code></pre>
<p>Schön! Du kannst sehen, dass ich vor meiner Vermutung sogar ein paar
Leerzeichen eingetippt hat und das Programm immernoch wusste, dass Ich
76 geraten habe. Führe das Programm ein paar mal aus und stelle sicher,
dass sowohl das Raten der korrekten Zahl, als auch das Raten einer zu
kleinen Zahl funktioniert.</p>
<p>Nun funktioniert auch schon der größte Teil des Spiels,
aber wir haben nur einen Versuch. Lass uns das durch das Hinzufügen von
Schleifen ändern!</p>
<a class="header" href="print.html#wiederholungen-mit-schleifen" id="wiederholungen-mit-schleifen"><h1>Wiederholungen mit Schleifen</h1></a>
<p>Das <code>loop</code> Schlüsselwort gibt uns eine Endlosschleife.
Lass uns das hinzufügen:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    loop {
        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut vermutung = String::new();

        io::stdin().read_line(&amp;mut vermutung)
            .ok()
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let vermutung: u32 = vermutung.trim().parse()
            .ok()
            .expect(&quot;Bitte eine Zahl eintippen!&quot;);

        println!(&quot;Deine Vermutung: {}&quot;, vermutung);

        match vermutung.cmp(&amp;geheime_zahl) {
            Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
        }
    }
}
</code></pre></pre>
<p>Und probier es aus. Aber warte, haben wir nicht gerade eine
Endlosschleife hinzugefügt? Japp.
Erinnerst du dich an unsere Diskussion über <code>parse()</code>?
Wenn wir einen &quot;nicht-Zahl&quot; eingeben, dann brechen wir ab und beenden das
Programm. Beobachte:</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 59
Bitte gib deine Vermutung ein.
45
Deine Vermutung: 45
Zu klein!
Bitte gib deine Vermutung ein.
60
Deine Vermutung: 60
Zu groß!
Bitte gib deine Vermutung ein.
59
Deine Vermutung: 59
Du gewinnst!
Bitte gib deine Vermutung ein.
ende
thread '&lt;main&gt;' panicked at 'Bitte eine Zahl eintippen!'
</code></pre>
<p>Ha! <code>ende</code> beended sogar das Programm. Genauso wie jede andere Eingabe, die
keine Zahl ist. Nun, das ist, milde ausgedrückt, eher suboptimal.
Zuerst lass uns tatsächlich beenden, wenn man das Spiel gewinnt:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    loop {
        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut vermutung = String::new();

        io::stdin().read_line(&amp;mut vermutung)
            .ok()
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let vermutung: u32 = vermutung.trim().parse()
            .ok()
            .expect(&quot;Bitte eine Zahl eintippen!&quot;);

        println!(&quot;Deine Vermutung: {}&quot;, vermutung);

        match vermutung.cmp(&amp;geheime_zahl) {
            Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre></pre>
<p>Durch das Hinzufügen der <code>break</code> Zeile nach dem <code>Gewonnen!</code> verlassen
wir die Schleife, wenn wir gewinnen. Die Schleife zu verlassen bedeutet auch
das Programm zu beenden, da sie das letzte in unserer <code>main()</code> ist.
Wir haben noch eine weitere Anpassung zu machen: Wenn jemand eine &quot;nicht-Zahl&quot;
eingibt, dann wollen wir nicht beenden, sondern es einfach ignorieren.
Das können wir so machen:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    loop {
        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut vermutung = String::new();

        io::stdin().read_line(&amp;mut vermutung)
            .ok()
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let vermutung: u32 = match vermutung.trim().parse() {
            Ok(zahl) =&gt; zahl,
            Err(_) =&gt; continue,
        };

        println!(&quot;Deine Vermutung: {}&quot;, vermutung);

        match vermutung.cmp(&amp;geheime_zahl) {
            Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre></pre>
<p>Diese Zeilen wurden geändert:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let vermutung: u32 = match vermutung.trim().parse() {
    Ok(zahl) =&gt; zahl,
    Err(_) =&gt; continue,
};

#}</code></pre></pre>
<p>So geht man in der Regel von &quot;stürze bei einem Fehler ab&quot; zu
&quot;behandle den Fehler tatsächlich&quot;, indem man von <code>ok().expect()</code>
zu einer <code>match</code> Anweisung wechselt. Das <code>Result</code>, welches von <code>parse()</code>
zurückgegeben wird, ist tatsächlich ein <code>enum</code>, genau wie <code>Ordering</code>,
aber in diesem Fall enthält jede Variante ein paar Daten:
<code>Ok</code> ist ein Erfolg und <code>Err</code> ist ein Fehlschlag. Jeder davon enthält
ein paar Daten:  Die erfolgreich geparste Zahl oder einen Fehlertyp.
In diesem Fall, &quot;matchen&quot; wir <code>Ok(zahl)</code>, was den inneeren Wert von <code>Ok</code>
an den Name <code>num</code> bindet und danach diesen Wert auf der rechten Seite
zurückgibt. Im <code>Err</code> Fall interessieren wir uns nicht für die Art des
Fehlers, also benutzen wir einfach <code>_</code> anstatt einen Namen.
Dies ignoriert den Fehler und <code>continue</code> sorgt dafür, dass wir mit der
nächsten Iteration der Schleife fortfahren.</p>
<p>Nun sollte alles in Ordnung sein! Mal ausprobieren:</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 61
Bitte gib deine Vermutung ein.
10
Deine Vermutung: 10
Zu klein!
Bitte gib deine Vermutung ein.
99
Deine Vermutung: 99
Zu groß!
Bitte gib deine Vermutung ein.
foo
Bitte gib deine Vermutung ein.
61
Deine Vermutung: 61
Gewonnen!
</code></pre>
<p>Wunderbar! Es fehlt noch eine winzig kleine Änderung damit das
Ratespiel fertig ist. Kannst du dir vorstellen welche?
Genau, wir wollen unsere geheime Zahl nicht ausgeben.
Die Ausgabe war gut zum Testen, aber sie nimmt dem Spiel ein wenig
den Sinn. Hier ist der fertige Code:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut vermutung = String::new();

        io::stdin().read_line(&amp;mut vermutung)
            .ok()
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let vermutung: u32 = match vermutung.trim().parse() {
            Ok(zahl) =&gt; zahl,
            Err(_) =&gt; continue,
        };

        println!(&quot;Deine Vermutung: {}&quot;, vermutung);

        match vermutung.cmp(&amp;geheime_zahl) {
            Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre></pre>
<a class="header" href="print.html#fertig" id="fertig"><h1>Fertig!</h1></a>
<p>Jetzt hast du erfolgreich das Ratespiel gebaut! Gratuliere!</p>
<p>Dieses erste Projekt hat dir eine Menge gezeigt: <code>let</code>, <code>match</code>,
Methoden, assoziierte Funktionen, wie man externe Crates verwendet, und mehr.
Unser nächstes Projekt wird soger noch mehr demonstrieren.</p>
<a class="header" href="print.html#speisende-philosophen" id="speisende-philosophen"><h1>Speisende Philosophen</h1></a>
<a class="header" href="print.html#rust-in-anderen-sprachen" id="rust-in-anderen-sprachen"><h1>Rust in anderen Sprachen</h1></a>
<a class="header" href="print.html#effektives-rust" id="effektives-rust"><h1>Effektives Rust</h1></a>
<!--vim:set spelllang=de:-->
<p>Wir haben also bis jetzt einige Grundlagen in Rust erworben.
Bis zu <em>gutem Rust</em> fehlt allerdings noch ein kleines Stück.</p>
<p>Dieses Kapitel besteht aus einer Reihe relativ unabhängiger Tutorials,
welche erklären wie wir das nächste Level in Rust erreichen.
Dabei werden wir auf übliche Patterns und Features der Standardbibliothek eingehen.
Diese Unterkapitel halten keine explizite Reihenfolge ein.</p>
<a class="header" href="print.html#der-stack-und-der-heap" id="der-stack-und-der-heap"><h1>Der Stack und der Heap</h1></a>
<p>Rust operiert auf einer sehr niedrigen Ebene im System.
Wenn du bereits Erfahrung mit Programmiersprachen hast,
bei denen Speicherverwaltung automatisiert wird,
dann sind dir eventuell einige Aspekte einer Systemsprache noch nicht vertraut.
Das wichtigste ist, wie Speicher funktioniert, mit Stack und Heap.
Wenn dir Speicherallokation in C-artigen Sprachen bereits vertraut ist,
dann sieh dieses Kapitel als Auffrischung.
Wenn nicht, dann lernst du hier Grundlagen, aus der Sicht von Rust.</p>
<a class="header" href="print.html#speicherverwaltung" id="speicherverwaltung"><h2>Speicherverwaltung</h2></a>
<p>Die beiden Begriffe Stack und Heap beschreiben unterschiedliche Bereiche im Arbeitsspeicher und helfen uns dabei zu unterscheiden wann Speicher alloziert und dealloziert wird.</p>
<p>Hier zum Vergleich:</p>
<p>Der Stack ist sehr schnell und daher der Ort an dem Rust standardmäßig Speicher alloziert.
Der Speicher im Stack ist allerdings nur lokal innerhalb einer Funktion verfügbar.
Der Heap, auf der anderen Seite, ist langsamer, wird explizit für von deinem Programm alloziert aber ist dafür global erreichbar und hat prinzipiell keine Größenbeschränkung.</p>
<a class="header" href="print.html#der-stack" id="der-stack"><h2>Der Stack</h2></a>
<p><em>(engl. stack = <strong>„Der Stapel“</strong> )</em></p>
<p>Nehmen wir mal ein Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 42;
}
</code></pre></pre>
<p>Dieses Programm besteht nur aus einer Variablenzuweisung, <code>x</code>.
Der Speicher für <code>x</code> muss irgendwo alloziert werden.
Rust ‚Stack-Alloziert‘ standardmäßig, das heißt Werte landen auf dem Stack.
Was heißt das?</p>
<p>Wenn eine Funktion aufgerufen wird, dann wird für jede ihrer lokalen Variablen, und etwas Zusatzinformation, Speicher auf ihrem Stack, dem Stackframe, reserviert.
Für diese Tutorial ignorieren wir die Zusatzinformationen erst einmal.
Wenn <code>main()</code> also ausgeführt wird, dann allozieren wir einen einzelnen 32-bit Integer auf dem Stackframe, das passiert hier ganz automatisch.
Wenn die Funktion terminiert wird der Stackframe freigegeben.
Auch vollautomatisch.</p>
<p>Das ist alles, für diese kleine Beispiel.
Der Kernpunkt an dieser Lektion ist, dass Stackallokation sehr sehr schnell ist,
da wir bereits vor dem Start des Programms die lokalen Variablen kennen und daher den Speicher für sie auch schon ganz am Anfang auf einmal reservieren können.
Da alle lokalen Variablen nach Ende der Funktion nicht mehr benötigt werden, können wir sie auch alle auf einmal wieder freigeben.</p>
<p>Der Nachteil hier ist jedoch, dass wir die Werte der Variablen nicht länger als für die Dauer einer einzelnen Funktion vorhalten können.
Dafür gibt es dann den Heap.</p>
<p>Doch was heißt Stack eigentlich.
Dafür hier ein etwas umfangreicheres Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust">fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
</code></pre></pre>
<p>Dieses Programm hat insgesamt drei Variablen: zwei in <code>foo()</code> und eine in <code>main()</code>.
Just vor dem Aufruf von <code>main()</code> wird ein Integer auf deren Stack alloziert.
Die Sicht deines Betriebssystem auf den Speicher entspricht im Prinzip einer langen Liste von Adressen, von 0 bis <code>n</code>.
Wobei <code>n</code> von der Größe des Arbeitsspeichers abhängt.
Wenn du zum Beispiel nur 1 Gigabyte RAM haben solltest, ist <code>n</code> <code>1,073,741,823</code> (2<sup>30</sup>-1).</p>
<p>Hier eine Darstellung des Stackframes:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert  </th></tr></thead><tbody>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</tbody></table>
<p>Wir haben <code>x</code> auf Adresse <code>0</code>, mit dem Wert <code>42</code>.</p>
<p>Wenn nun <code>foo()</code> aufgerufen wird, wird ein weiterer Stackframe alloziert:</p>
<p>Daher auch der Begriff „Stack“ = „Stapel“,
es wird immer etwas oben drauf gelegt und auch ausschließlich von oben wieder herunter genommen.
Wie bei einem Stapel Teller.
Solange <code>foo()</code> läuft, ist auch <code>main()</code> noch nicht beendet und der Speicher beider Funktionen ist noch vergeben.
Der Speicher von <code>main()</code> kann noch nicht freigegeben werden bevor <code>foo()</code> noch nicht beendet ist.
Jedoch kann <code>foo()</code> auch nicht direkt auf den Speicher von <code>main()</code> zugreifen.</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert  </th></tr></thead><tbody>
<tr><td> 2       </td><td> z    </td><td> 100   </td></tr>
<tr><td> 1       </td><td> y    </td><td> 5     </td></tr>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</tbody></table>
<p>Da <code>0</code> bereits im erst Stackframe vergeben war, verwendet <code>foo()</code> nun Adressen <code>1</code> und <code>2</code>. Der Stapel wächst sprichwörtlich nach oben mit jedem Funktionsaufruf.</p>
<p>Die Adressen <code>0</code> bis <code>2</code> sind allerdings rein zur Illustration gewählt,
im tatsächlichen Speicher hätten diese Adressen andere Werte und wären auch nicht direkt aufeinanderfolgend.</p>
<p>Nachdem <code>foo()</code> beendet ist wird sein Frame wieder vom Stapel genommen und wir sind wieder zurück bei:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert  </th></tr></thead><tbody>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</tbody></table>
<p>Und dann, nachdem <code>main()</code> ebenfalls fertig ist wird auch diese Adresse wieder freigegeben. Ganz einfach!</p>
<p>Ein drittes Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust">fn bar() {
    let i = 6;
}

fn foo() {
    let a = 5;
    let b = 100;
    let c = 1;

    bar();
}

fn main() {
    let x = 42;

    foo();
}
</code></pre></pre>
<p>Als erstes <code>main()</code>:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert  </th></tr></thead><tbody>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</tbody></table>
<p><code>main()</code> ruft <code>foo()</code> auf:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert  </th></tr></thead><tbody>
<tr><td> 3       </td><td> c    </td><td> 1     </td></tr>
<tr><td> 2       </td><td> b    </td><td> 100   </td></tr>
<tr><td> 1       </td><td> a    </td><td> 5     </td></tr>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</tbody></table>
<p>Dann ruft <code>foo()</code> <code>bar()</code> auf:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert  </th></tr></thead><tbody>
<tr><td> 4       </td><td> i    </td><td> 6     </td></tr>
<tr><td> 3       </td><td> c    </td><td> 1     </td></tr>
<tr><td> 2       </td><td> b    </td><td> 100   </td></tr>
<tr><td> 1       </td><td> a    </td><td> 5     </td></tr>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</tbody></table>
<p>Puh! Unser Stapel wächst in die Höhe.</p>
<p>Nach dem <code>bar()</code> fertig ist, wird sein Stackframe dealloziert und es bleiben nur der von <code>foo()</code> und <code>main()</code>:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert  </th></tr></thead><tbody>
<tr><td> 3       </td><td> c    </td><td> 1     </td></tr>
<tr><td> 2       </td><td> b    </td><td> 100   </td></tr>
<tr><td> 1       </td><td> a    </td><td> 5     </td></tr>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</tbody></table>
<p>Und dann wird <code>foo()</code> auch noch fertig und wir haben nur noch <code>main()</code>:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert  </th></tr></thead><tbody>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</tbody></table>
<p>Wir sind fertig.
Kriegst du ein Gefühl für die Tellerstapel?
Wir legen einen drauf und nehmen einen wieder runter,
wir nehmen nie was aus der Mitte raus.</p>
<a class="header" href="print.html#der-heap" id="der-heap"><h2>Der Heap</h2></a>
<p><em>(engl. heap = <strong>„Der Haufen“</strong> )</em></p>
<p>Wie bereits erwähnt können Funktionen nicht auf die lokalen variablen von anderen Funktionen zugreifen.
Manchmal möchte man jedoch etwas von einer Funktion an eine andere übergeben oder länger als für die Laufzeit einer Funktion im Speicher behalten.
Dafür haben wir den Heap.</p>
<p>In Rust allozieren wir Speicher auf dem Heap mit einer <a href="http://doc.rust-lang.org/stable/std/boxed/"><code>Box&lt;T&gt;</code></a>.
Hier ein Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Box::new(5);
    let y = 42;
}
</code></pre></pre>
<p>Was also diesmal in <code>main()</code> passiert ist folgendes:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert   </th></tr></thead><tbody>
<tr><td> 1       </td><td> y    </td><td> 42     </td></tr>
<tr><td> 0       </td><td> x    </td><td> ?????? </td></tr>
</tbody></table>
<p>Wir allozieren Speicher für zwei Variablen auf dem Stack, wie gehabt.
<code>y</code> ist <code>42</code>, aber was ist <code>x</code>?
Nun, <code>x</code> ist ein <code>Box&lt;i32&gt;</code>, und <code>Box</code>en allozieren ihren Speicher auf dem Heap.
Der eigentliche Wert dieser Box ist ein <code>struct</code> das eine Adresse zu einem Stück Speicher (genug für einen <code>i32</code>) auf dem Heap beinhaltet.
Wenn wir nun die Funktion ausführen und <code>Box::new()</code> aufrufen,
wird der Speicher auf dem Heap alloziert und <code>5</code> dorthin geschrieben.
Der Speicher sieht also eigentlich etwa so aus:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 5                      </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 1                    </td><td> y    </td><td> 42                     </td></tr>
<tr><td> 0                    </td><td> x    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
</tbody></table>
<p>Wir haben (2<sup>30</sup>) - 1 Adressen in unserem imaginären 1GB RAM.
Da der Stack von 0 nach oben wächst ist es am einfachsten die Adressen von Oben nach unten für den Heap zu verwenden.
Der erste Wert steht also an der höchsten Stelle im Speicher.
Das <code>struct</code> auf <code>x</code> hat einen <a href="Raw_Zeiger.html">raw Zeiger</a> auf die Stelle an der wir den Speicher auf dem Heap alloziert haben, also den Wert (2<sup>30</sup>) - 1.</p>
<p>Wir habe noch nicht wirklich viel darüber gesprochen, was es eigentlich bedeutet in diesen Kontexten Speicher zu allozieren und zu deallozieren.
Das zu vertiefen würde den Rahmen dieses Tutorials sprengen,
aber was wichtig ist mitzunehmen, ist dass der Heap nicht einfach nur ein von oben nach unten wachsender Stack ist.
Im Gegensatz zum Stack muss der Heap nicht in einer festen Reihenfolge alloziert und freigegeben werden.
Dadurch kann er allerdings Löcher haben.
Dazu wird es später ein Beispiel geben.
Hier erst mal ein kleines Diagramm des Speicherlayouts eines Programms das schon ein Weilchen lief:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 5                      </td></tr>
<tr><td> (2<sup>30</sup>) - 2 </td><td>      </td><td>                        </td></tr>
<tr><td> (2<sup>30</sup>) - 3 </td><td>      </td><td>                        </td></tr>
<tr><td> (2<sup>30</sup>) - 4 </td><td>      </td><td> 42                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 3                    </td><td> y    </td><td> → (2<sup>30</sup>) - 4 </td></tr>
<tr><td> 2                    </td><td> y    </td><td> 42                     </td></tr>
<tr><td> 1                    </td><td> y    </td><td> 42                     </td></tr>
<tr><td> 0                    </td><td> x    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
</tbody></table>
<p>In diesem Fall haben wir 4 Werte auf dem Heap alloziert, aber deallozieren zwei davon.
Es gibt eine Lücke zwischen (2<sup>30</sup>) - 1 und (2<sup>30</sup>) - 4,
die momentan nicht benutzt wird.
Die genauen Details wie und warum das passiert hängen davon ab mit welcher Strategie man seinen Heap verwaltet.
Verschiedene Programme können unterschiedliche Speicherallokatoren verwenden,
also Bibliotheken, die einem das abnehmen.
Rust Programme verwenden <a href="http://www.canonware.com/jemalloc/">jemalloc</a>.</p>
<p>Zurück zu unserem Beispiel.
Da sich diese Werte auf dem Heap befinden, können sie länger existieren als die Funktion die die Box erzeugt hat.
In diesem Fall jedoch nicht.<sup class="footnote-reference"><a href="print.html#1">1</a></sup>
Wenn eine Funktion endet wird ihr Stackframe freigegeben.
<code>Box&lt;T&gt;</code> hat einen Trick: <a href="Drop.html">Drop</a>.
Es implementiert <code>Drop</code> und gibt sobald ihr Wert auf dem Stack freigegeben wird ebenfalls den Speicher auf dem Heap frei.
Geil! Wenn also <code>x</code> verschwindet gibt es vorher seinen Speicher auf dem Heap frei:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert   </th></tr></thead><tbody>
<tr><td> 1       </td><td> y    </td><td> 42     </td></tr>
<tr><td> 0       </td><td> x    </td><td> ?????? </td></tr>
</tbody></table>
<p>Sobald der Stackframe verschwindet, wird der gesamte verwendete Speicher freigegeben.</p>
<a class="header" href="print.html#argumente-und-ausleihen" id="argumente-und-ausleihen"><h2>Argumente und Ausleihen</h2></a>
<p>Wir hatten bereits ein paar grundlegende Beispiele für Stack und Heap,
aber was ist mit Funktionsargumenten und Ausleihen?</p>
<pre><pre class="playpen"><code class="language-rust">fn foo(i: &amp;i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &amp;x;

    foo(y);
}
</code></pre></pre>
<p>Wenn wir <code>main()</code> betreten sieht der Speicher so aus:</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert   </th></tr></thead><tbody>
<tr><td> 1       </td><td> y    </td><td> → 0    </td></tr>
<tr><td> 0       </td><td> x    </td><td> 5      </td></tr>
</tbody></table>
<p><code>x</code> ist einfach wieder <code>5</code> und <code>y</code> ist eine Referenz auf <code>x</code>.
Sein Wert ist also die Speicheradresse von <code>x</code>, in diesem Fall also <code>0</code>.</p>
<p>Was passiert wenn wir nun <code>foo()</code> aufrufen und <code>y</code> übergeben?</p>
<table><thead><tr><th> Adresse </th><th> Name </th><th> Wert   </th></tr></thead><tbody>
<tr><td> 3       </td><td> z    </td><td> 42     </td></tr>
<tr><td> 2       </td><td> i    </td><td> → 0    </td></tr>
<tr><td> 1       </td><td> y    </td><td> → 0    </td></tr>
<tr><td> 0       </td><td> x    </td><td> 5      </td></tr>
</tbody></table>
<p>Stackframes sind nicht nur für lokale Zuweisungen, sie sind auch für Argumente gedacht.
In diesem Fall also brauchen wir sowohl <code>i</code>, das Argument und <code>z</code>, die lokale Variable.
<code>i</code> ist die Kopie des Arguments <code>y</code>, also auch <code>0</code>.</p>
<p>Das ist der Grund dafür, dass man ausgeliehenen Speicher nicht deallozieren kann. Wenn wir nun <code>x</code> freigeben würden, würden <code>y</code> und <code>i</code> auf ungültigen Speicher zeigen.
Das ist in Sprachen wie C möglich, aber nicht in Rust.</p>
<a class="header" href="print.html#ein-komplexes-beispiel" id="ein-komplexes-beispiel"><h2>Ein komplexes Beispiel</h2></a>
<p>Gehen wir das hier mal Schritt für Schritt durch:</p>
<pre><pre class="playpen"><code class="language-rust">fn foo(x: &amp;i32) {
    let y = 10;
    let z = &amp;y;

    baz(z);
    bar(x, z);
}

fn bar(a: &amp;i32, b: &amp;i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &amp;d;

    baz(e);
}

fn baz(f: &amp;i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &amp;h;

    foo(j);
}
</code></pre></pre>
<p>Als erstes rufen wir <code>main()</code> auf:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</tbody></table>
<p>Wir allozieren Speicher für <code>j</code>, <code>i</code> und <code>h</code>.
<code>i</code> liegt auf dem Heap, beinhaltet also einen Adresswert dort hin.</p>
<p>Als nächstes wird am Ende von <code>main()</code> <code>foo()</code> aufgerufen:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</tbody></table>
<p>Speicher wird für <code>x</code>, <code>y</code> und <code>z</code> belegt.
Das Argument <code>x</code> hat den gleichen Wert wie <code>j</code>, da wird das ja übergeben haben, ein Zeiger auf die Adresse <code>0</code>, da <code>j</code> auf <code>h</code> zeigt.</p>
<p>Danach ruft <code>foo()</code> <code>baz()</code> auf und übergibt <code>z</code>:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 7                    </td><td> g    </td><td> 100                    </td></tr>
<tr><td> 6                    </td><td> f    </td><td> → 4                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</tbody></table>
<p>Wir haben Speicher für <code>f</code> und <code>g</code> alloziert.
<code>baz()</code> ist sehr kurz und wenn es vorbei ist wird sein Stackframe freigegeben:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</tbody></table>
<p>Danach ruft <code>foo()</code> <code>bar()</code> mit <code>x</code> und <code>z</code> auf:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> (2<sup>30</sup>) - 2 </td><td>      </td><td> 5                      </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 10                   </td><td> e    </td><td> → 9                    </td></tr>
<tr><td> 9                    </td><td> d    </td><td> → (2<sup>30</sup>) - 2 </td></tr>
<tr><td> 8                    </td><td> c    </td><td> 5                      </td></tr>
<tr><td> 7                    </td><td> b    </td><td> → 4                    </td></tr>
<tr><td> 6                    </td><td> a    </td><td> → 0                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</tbody></table>
<p>Wir allozieren also einen weiteren Wert auf dem Heap und müssen eins von (2<sup>30</sup>) - 1 abziehen.
Das ist einfacher das zu schreiben als <code>1,073,741,822</code> ☺.
Jedenfalls, hier die Variablen wie gewohnt.</p>
<p>Am Ende von <code>bar()</code> wird wieder <code>baz()</code> aufgerufen:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> (2<sup>30</sup>) - 2 </td><td>      </td><td> 5                      </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 12                   </td><td> g    </td><td> 100                    </td></tr>
<tr><td> 11                   </td><td> f    </td><td> → 9                    </td></tr>
<tr><td> 10                   </td><td> e    </td><td> → 9                    </td></tr>
<tr><td> 9                    </td><td> d    </td><td> → (2<sup>30</sup>) - 2 </td></tr>
<tr><td> 8                    </td><td> c    </td><td> 5                      </td></tr>
<tr><td> 7                    </td><td> b    </td><td> → 4                    </td></tr>
<tr><td> 6                    </td><td> a    </td><td> → 0                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</tbody></table>
<p>So, jetzt haben wir den tiefsten Punkt in unserer Schachtelung erreicht,
Glückwunsch, du bist bist jetzt noch dran geblieben.</p>
<p>Nachdem <code>baz()</code> nun zu Ende ist können wir <code>f</code> und <code>g</code> wegwerfen:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> (2<sup>30</sup>) - 2 </td><td>      </td><td> 5                      </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 10                   </td><td> e    </td><td> → 9                    </td></tr>
<tr><td> 9                    </td><td> d    </td><td> → (2<sup>30</sup>) - 2 </td></tr>
<tr><td> 8                    </td><td> c    </td><td> 5                      </td></tr>
<tr><td> 7                    </td><td> b    </td><td> → 4                    </td></tr>
<tr><td> 6                    </td><td> a    </td><td> → 0                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</tbody></table>
<p>Danach endet <code>bar()</code>. <code>d</code> ist hier ja eine <code>Box&lt;T&gt;</code>, also geben wir noch den Speicher an der Adresse frei, auf die sie zeigt:(2<sup>30</sup>) - 2.</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</tbody></table>
<p>Dann ist <code>foo()</code> fertig:</p>
<table><thead><tr><th> Adresse              </th><th> Name </th><th> Wert                   </th></tr></thead><tbody>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</tbody></table>
<p>Und endlich auch <code>main()</code>.
Hiernach wir der Rest aufgeräumt.
Sobald <code>i</code> ge<code>Drop</code>pt wird, wird auch der Rest vom Heap geleert.</p>
<a class="header" href="print.html#was-machen-andere-sprachen" id="was-machen-andere-sprachen"><h2>Was machen andere Sprachen?</h2></a>
<p>Viele Sprachen verwenden heutzutage einen Garbage Collector.
Das hat einige Vorteile, die Beschreibung würde allerdings den Rahmen dieses Tutorials sprengen.
Dort hat man keinen manuellen Einfluss darauf, ob Speicher auf dem Heap oder Stack verwendet wird.
Stattdessen liegt fast alles auf dem Heap und der Garbage Collector hält regelmäßig das Programm kurz an und räumt auf.</p>
<p>Bei Sprachen wie C/C++ kann man zwischen Stack und Heap unterscheiden, muss allerdings manuell seinen Speicher aufräumen.
Hier gibt es bereits moderne Mechanismen, u.a. SmartPointer, die ähnliche Charakteristika haben wie Rust <code>Box&lt;T&gt;</code> etc, Konzepte wie „Besitz“ und „Ausleihen“ sind allerdings noch kein Kernfeature der Sprache.</p>
<a class="header" href="print.html#was-soll-ich-benutzen" id="was-soll-ich-benutzen"><h2>Was soll ich benutzen?</h2></a>
<p>Der Stack ist schneller und einfacher zu handhaben, wofür also den Heap?
Ein wichtiger Grund ist, dass Stack-allozieren alleine nur LIFO<sup class="footnote-reference"><a href="print.html#2">2</a></sup>-Verhalten bietet.
Heapallokation ist vielseitiger und erlaubt schnelles Übergeben von großen Werten ohne Kopieren.</p>
<p>Allgemein ist Stackallokation zu bevorzugen, weshalb Rust standardmäßig den Stack nutzt, das ist grundlegend einfacher und meistens effizienter.</p>
<a class="header" href="print.html#laufzeiteffizienz" id="laufzeiteffizienz"><h2>Laufzeiteffizienz</h2></a>
<p>Speicher auf dem Stack verwalten ist trivial:
Die Maschine inkrementiert und dekrementiert einfach den sogenannten <em>Stack-Pointer</em>.
Speicher auf dem Heap verwalten ist nicht trivial:
Speicher auf dem Heap kann beliebig freigegeben werden und jeder Block auf dem Heap kann eine beliebige Größe haben, es ist allgemein schwerer wiederverwendbare Bereiche zu identifizieren.</p>
<p>Um hier noch tiefer einzusteigen kannst du <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.4688">diese Paper</a> (englisch) lesen oder Grundstudiums-Vorlesungen „Betriebssysteme“ der Uni deiner Wahl besuchen :D</p>
<a class="header" href="print.html#semantische-bedeutung" id="semantische-bedeutung"><h2>Semantische Bedeutung</h2></a>
<p>Stackallokation beeinflusst nicht nur Rust selbst, sondern auch das mentale Modell des Entwicklers.
LIFO-Semantik definiert Rusts automatische Speicherverwaltung.
Selbst die Freigabe von Heap-allozierten Boxen mit einem einzelnen Besitzer wird von der LIFO-Semantik des Stacks bestimmt, wie bereits oben demonstriert.
Nicht-LIFO-Semantik würde zwar mehr Flexibilität bieten,
jedoch könnte dann nicht automatisch zur Compile-Zeit abgeleitet werden,
wann Speicher freigegeben werden kann.
Ein Compiler müsste sich auf dynamische Protokolle, potentiell außerhalb der Sprache selbst, verlassen (zum Beispiel <em>reference counting</em> wie in <code>Rc&lt;T&gt;</code> und <code>Arc&lt;T&gt;</code>).</p>
<p>Wenn man es übertreibt kann man sagen, dass die erhöhte Freiheit durch Heapallokation mit signifikanten Kosten verbunden ist, entweder in Form von Laufzeit-Performance (z.B. durch einen Garbage Collector) oder durch erhöhten Aufwand für den Entwickler in Form von expliziten Mechanismen zur Speicherverwaltung (<code>new</code>, <code>delete</code>), welche Rust nicht vorsieht.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Wir können den Speicher länger leben lassen indem wir den Besitz übertragen das heißt manchmal ‚moving out of the box‘. Komplexere Beispiele folgen später.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Last in first out.</p>
</div>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<blockquote>
<p>Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.</p>
<p><em>Das Testen von Programmen ist eine sehr effektive Art,
die Anwesenheit von Bugs zu zeigen, aber ist hoffnungslos unangemessen, deren Abwesenheit zu zeigen.</em></p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>
<a class="header" href="print.html#das-test-attribut" id="das-test-attribut"><h2>Das <code>test</code> Attribut</h2></a>
<p>In Rust ist ein Test ganz einfach eine Funktion die mit <code>test</code> annotiert ist.
Beginnen wir also ein kleines Cargo Projekt namens <code>adder</code>:</p>
<pre><code class="language-bash">$ cargo new adder
$ cd adder
</code></pre>
<p>Wenn wir <code>cargo new</code> ohne <code>--bin</code> ausführen erzeugt Cargo ein Library-Projekt.
Cargo generiert automatisch einen kleinen Test, wie man am Inhalt von <code>src/lib.rs</code> sieht:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
}

#}</code></pre></pre>
<p>Achte auf <code>#[test]</code>.
Das ist ein Attribut und es markiert die Funktion <code>it_works()</code> als Test.
Sie ist erst mal leer.
Dann kann sie auch auch nicht fehlschlagen.
Wir können sie ganz einfach mit <code>cargo test</code> ausführen:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Hier sehen wir zwei Ausgaben.
Die erste für den Test den wir geschrieben haben,
die zweite für Dokumentationstests, davon später mehr.
Vorerst:</p>
<pre><code class="language-text">test it_works ... ok
</code></pre>
<p>Beachte dass hier der Name unserer Funktion <code>it_works</code> steht.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn it_works() {
}

#}</code></pre></pre>
<p>Warum schlägt dieser leere Test aber nun nicht fehl?
Jeder Test der kein <code>panic!()</code> provoziert ist erfolgreich.
Wie könnten wir ihn nun fehlschlagen lassen?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert!(false);
}

#}</code></pre></pre>
<p><code>assert!</code> ist ein Macro in Rust das genau ein Argument nimmt,
und wenn das nicht <code>true</code> ist, dann ruft es <code>panic!</code> auf.
Also nochmal:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247
</code></pre>
<p>Rust sagt uns, dass unser Test gefailt ist.</p>
<pre><code class="language-text">test it_works ... FAILED
</code></pre>
<p>Was uns auch die Zusammenfassung am Ende sagt:</p>
<pre><code class="language-text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Wir haben ebenfalls einen non-zero status code bekommen, ein feature unserer Shell (<em>linux und OS X</em>), dass das letzte Kommando fehlgeschlagen ist.</p>
<pre><code class="language-bash">$ echo $?
101
</code></pre>
<p>Auf Windows in <code>cmd</code> :</p>
<pre><code class="language-bash">&gt; echo %ERRORLEVEL%
</code></pre>
<p>oder PowerShell:</p>
<pre><code class="language-bash">&gt; echo $LASTEXITCODE # Der Exitcode selbst
&gt; echo $? # ein boolean, Erfolgreich oder nicht
</code></pre>
<p>Das ist nützlich wenn du <code>cargo test</code> in andere Tools integrieren willst.</p>
<p>Wir können den Test auch invertieren, wenn wir wollen, dass er fehlschlägt: <code>should_panic</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic]
fn it_works() {
    assert!(false);
}

#}</code></pre></pre>
<p>Der Test zählt nun als erfolgreich, wenn <code>panic!</code> eintritt.
Gleich mal ausprobieren:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Rust kennt noch ein weiteres Macro: <code>assert_eq!</code>, zum Vergleichen zweier Werte:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}

#}</code></pre></pre>
<p>Schlägt das hier nun fehl?
Nein, denn da steht noch <code>should_panic</code>:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><code>should_panic</code> ist immer mit etwas Vorsicht zu genießen, denn es schwer sicher zu sein, ob der Test nicht auf Grund anderer Probleme ge<code>panic</code>t hat.
Wir können aber Bedingungen für bestimmte Fehler hinzufügen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic(expected = &quot;assertion failed&quot;)]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}

#}</code></pre></pre>
<p>Jetzt muss das <code>assert_eq!</code> fehlschlagen, sonst scheitert der Test trotzdem.</p>
<p>Soviel also zu Grundlagen, schreiben wir endlich einen nützlichen Test!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}

#}</code></pre></pre>
<p>Das ist ein klassischer Fall für <code>assert_eq!</code>: Wir rufen eine Funktion auf und vergleichen ihren Rückgabewert.</p>
<a class="header" href="print.html#das-ignore-attribut" id="das-ignore-attribut"><h2>Das <code>ignore</code> Attribut</h2></a>
<p>In Manchen Situationen wollen wir bestimmte Tests nicht immer mit ausführen, besonders, wenn sie teuer sind.
Diese kann man dann mit <code>ignore</code> ausschalten:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}

#[test]
#[ignore]
fn expensive_test() {
    // Code der eine Stunde läuft
}

#}</code></pre></pre>
<p>Jetzt werden sie exklusiv dann ausgeführt wenn wir <code>cargo test -- --ignored</code> ausführen:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Wir sehen: <code>it_works</code> wurde getestet, <code>expensive_test</code> nicht.</p>
<pre><code class="language-bash">$ cargo test -- --ignored
     Running target/adder-91b3e234d4ed382a

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Wichtig: <code>--ignored</code> ist ein Argument, das von dem Testbinary interpretiert wird, nicht von Cargo selbst.
Das wird mit den extra <code>--</code> vermittelt.</p>
<a class="header" href="print.html#das-tests-modul" id="das-tests-modul"><h2>Das <code>tests</code> Modul</h2></a>
<p>Was ist allerdings, wenn wir noch Hilfsfunktionen für unsere Tests brauchen,
die selbst keine Tests sind, die wir aber auch nicht mit ausliefern wollen?
Dafür kann man Tests innerhalb eines <code>tests</code> Moduls implementieren.
So in etwa:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::add_two;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}

#}</code></pre></pre>
<p>Das erlaubt es uns alle unsere Tests hier zu gruppieren und zusätzlich auch noch ggf. Hilfsfunktionen zu implementieren.
Dieses gesamte Modul wird nicht in unser crate kompiliert, wenn wir es nicht explizit als Test kompilieren, wir haben also nie Testcode in unserer Bibliothek.
Das spart nicht nur Kompilierzeit, sondern auch noch Platz.</p>
<p>Eine weitere Änderung ist die <code>use</code> Deklaration.
Weil wir uns hier in einem Untermodul und damit einem anderen Namespace befinden müssen, müssen wir die zu testende Funktion quasi importieren.
Das kann nerven, wenn wir irgendwann größere Projekte haben, also vereinfachen wir das doch einfach mit <code>*</code></p>
<pre><code class="language-rust ignore">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Beachte, dass sich die <code>use</code> Zeile geändert hat:</p>
<pre><code class="language-bash">$ cargo test
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Schön!</p>
<p>Die momentane Konvention ist, dass das <code>tests</code> Modul deine &quot;unit-style&quot; Tests enthält.
Alles was nur kleine Funktionalitätstests umfasst.
Integrationstest jedoch, verdienen etwas mehr Platz, dafür haben wir das <code>tests</code> Verzeichnis.</p>
<a class="header" href="print.html#das-tests-verzeichnis" id="das-tests-verzeichnis"><h2>Das <code>tests</code> Verzeichnis</h2></a>
<p>Um einen Integrationstest zu schreiben erzeugen wir erst einmal unser <code>tests</code> Verzeichnis und legen darin eine <code>.rs</code> Datei an: <code>tests/lib.rs</code>:</p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_works() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Das sieht unserem vorherigen Test schon sehr ähnlich, naja, nicht ganz.
Wir haben nun die Zeile <code>extern crate adder</code> ganz oben.
Das ist weil die Tests im <code>tests</code> Verzeichnis ein eigenes Crate sind und daher unsere Bibliothek erst einbinden müssen.
Das ist auch ein Grund warum Integrationstests hier gut aufgehoben sind, sie verwenden unsere Bibliothek genauso wie es ein dritter tun würde.</p>
<p>Führen wir sie aus:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Jetzt haben wir drei Sektionen: unsere vorherigen Tests werden ja immernoch ausgeführt.</p>
<p>Das ist alles zum <code>tests</code> Verzeichnis.
Das <code>tests</code> Modul brauchen wir hier nicht, da alles mit Tests zu tun hat.</p>
<p>Kommen wir nun zum dritten Teil: Dokumentation.</p>
<a class="header" href="print.html#dokumentationstests" id="dokumentationstests"><h2>Dokumentationstests</h2></a>
<p>Nichts ist besser als Dokumentation mit Beispielen.
Nichts ist blöder als wenn die Beispiele in der Dokumentation nicht funktionieren, zum Beispiel, weil sich die API verändert hat, seitdem die Dokumentation geschrieben wurde.
Rust macht damit Schluss, indem es automatisch den Code in der Dokumentation mit ausführt.
<em>Allerdings nur bei Bibliothek-Crates, nicht Binary-Crates.</em>
Hier nochmal <code>src/lib.rs</code> mit Beispielen:</p>
<pre><code class="lang-rust">
//! The `adder` crate provides functions that add numbers to other numbers.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// This function adds two to its argument.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Wichtig hier: Moduldokumentation beginnt mit <code>//!</code> und Funktionsdokumentation mit <code>///</code>.
Kommentare die mit <code>//</code> beginnen landen nicht in der Dokumentation.
Rusts Dokumentationswerkzeug unterstützt Markdown, daher markieren drei Accent grave Zeichen *(backticks &quot;`&quot;)*
Es ist Konvention eine Überschrift <code># Examples</code> <em>(bitte Englisch)</em> zu haben, dem dann die Beispiele folgen.</p>
<p>Noch ein Testlauf:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Jetzt haben wir alle drei Arten von Tests getestet.
Hier heißt der Dokumentationstest <code>_0</code> und der Funktionstest <code>add_two_0</code>.
Die Zahl wir inkrementiert je mehr Tests dazukommen.</p>
<p>Wir haben noch nicht alles wichtige zu Dokumentationstests hier erwähnt.
Für mehr schau in das <a href="documentation">Dokumentationskapitel</a>.</p>
<a class="header" href="print.html#bedingte-kompilierung" id="bedingte-kompilierung"><h1>Bedingte Kompilierung</h1></a>
<p>Rust hat ein spezielles Attribut, <code>#[cfg]</code>,
welches es uns erlaubt Code nur dann kompilieren zu lassen wenn ein bestimmtes Flag an den Compiler übergeben wird. Davon gibt es zwei Formen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[cfg(foo)]
# fn foo() {}

#[cfg(bar = &quot;baz&quot;)]
# fn bar() {}

#}</code></pre></pre>
<p>Dann gibt es noch Zusätze wie <code>any()</code>, <code>all()</code> oder <code>not()</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[cfg(any(unix, windows))]
# fn foo() {}

#[cfg(all(unix, target_pointer_width = &quot;32&quot;))]
# fn bar() {}

#[cfg(not(foo))]
# fn not_foo() {}

#}</code></pre></pre>
<p>Und diese können wiederum beliebig geschachtelt werden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[cfg(any(not(unix), all(target_os=&quot;macos&quot;, target_arch = &quot;powerpc&quot;)))]
# fn foo() {}

#}</code></pre></pre>
<p>Um diese Schalter an und auszuschalten, benutzt du in deiner <code>Cargo.toml</code> die <a href="http://doc.crates.io/manifest.html#the-%5Bfeatures%5D-section"><code>[features]</code> Sektion</a> (englisch):</p>
<pre><code class="language-toml">[features]
# no features by default
default = []

# The “secure-password” feature depends on the bcrypt package.
secure-password = [&quot;bcrypt&quot;]
</code></pre>
<p>Wenn das passiert ist übergibt Cargo die Flags auf diese Weise an <code>rustc</code>:</p>
<pre><code class="language-text">--cfg feature=&quot;${feature_name}&quot;
</code></pre>
<p>Die Summe dieser <code>cfg</code> Flags bestimmt welche aktiviert und damit kompiliert werden.
Hier am Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[cfg(feature = &quot;foo&quot;)]
mod foo {
}

#}</code></pre></pre>
<p>Wenn wir jetzt mit <code>cargo build --features &quot;foo&quot;</code> kompilieren,
wird das Flag <code>--cfg feature=&quot;foo&quot;</code> an <code>rustc</code> gesendet und das Ergebnis wird <code>mod foo</code> enthalten.
Wenn wir allerdings normal mit <code>cargo build</code> kompiliren, ohne extra Flags, gibt es kein <code>foo</code>.</p>
<a class="header" href="print.html#cfg_attr" id="cfg_attr"><h1>cfg_attr</h1></a>
<p>Man kann auch andere Attribute basierend auf <code>cfg</code> Variablen mit <code>cfg_attr</code> setzen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[cfg_attr(a, b)]
# fn foo() {}

#}</code></pre></pre>
<p>Das ist das selbe wie <code>#[b]</code> wenn <code>a</code> vom <code>cfg</code> Attribut gesetzt ist.
Sonst nichts.</p>
<a class="header" href="print.html#cfg" id="cfg"><h1>cfg!</h1></a>
<p>Das <code>cfg!</code> Macro ist eine <a href="Compiler_Plugins.html">Syntax Erweiterung</a> die dich diese Flags an beliebigen Stellen im Code verwenden lässt:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
if cfg!(target_os = &quot;macos&quot;) || cfg!(target_os = &quot;ios&quot;) {
    println!(&quot;Think Different!&quot;);
}

#}</code></pre></pre>
<p>Das wird zur beim Kompilieren durch <code>true</code> oder <code>false</code> ersetzt,
je nach Konfiguration.</p>
<a class="header" href="print.html#dokumentation" id="dokumentation"><h1>Dokumentation</h1></a>
<p>Dokumentation ist ein wichtiger Teil eines jeden Software Projekts.
In Rust ist sie ein Sprachbestandteil.
Reden wir doch mal über die Tools die uns Rust zur Verfügung stellt um unser Projekt zu dokumentieren.</p>
<a class="header" href="print.html#Über-rustdoc" id="Über-rustdoc"><h2>Über <code>rustdoc</code></h2></a>
<p>Das Rust Paket beinhaltet ein Tool namens <code>rustdoc</code>, welches Dokumentation generiert.
<code>rustdoc</code> wird von Cargo für <code>cargo doc</code> verwendet.</p>
<p>Dokumentation kann auf zwei Arten erzeugt werden: aus dem Quelltext und aus Markdown Dateien.</p>
<a class="header" href="print.html#dokumentation-von-quelltext" id="dokumentation-von-quelltext"><h2>Dokumentation von Quelltext</h2></a>
<p>Die primäre Methode ein Rust Projekt zu dokumentieren ist den Quelltext zu annotieren.
Dafür gibt es eine eigene Art von Kommentaren:</p>
<pre><code class="lang-rust">
/// Constructs a new `Rc<T>`.
///
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
pub fn new(value: T) -> Rc<T> {
    // hier die implementation
}
</code></pre>
<p>Dieser Code generiert Dokumentation die <a href="https://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new">wie diese aussieht</a>.
Nur halt ohne die Implementierung.</p>
<p>Das erste was uns an diesen Annotationen auffällt ist dass es mit <code>///</code> anstatt <code>//</code> anfängt.
Drei Slashes deuten einen Dokumentationskommentar an.</p>
<p>Dokumentation wird in Markdown geschrieben.</p>
<p>Rust kann diese Kommentare unterscheiden und daraus Dokumentation erzeugen.
Das ist unter anderem wichtig wenn man Dinge wie <code>enum</code>s dokumentiert:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// The `Option` type. See [the module level documentation](index.html) for more.
enum Option&lt;T&gt; {
    /// No value
    None,
    /// Some value `T`
    Some(T),
}

#}</code></pre></pre>
<p>Das hier oben funktioniert, das folgende leider nicht:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// The `Option` type. See [the module level documentation](index.html) for more.
enum Option&lt;T&gt; {
    None, /// No value
    Some(T), /// Some value `T`
}

#}</code></pre></pre>
<p>Dafür gibt es sogar eine Fehlermeldung:</p>
<pre><code class="language-text">hello.rs:4:1: 4:2 error: expected ident, found `}`
hello.rs:4 }
           ^
</code></pre>
<p>Dieser <a href="https://github.com/rust-lang/rust/issues/22547">Fehler</a> ist leider richtig so denn Dokumentationskommentare beziehen sich immer auf was direkt auf sie folgt.</p>
<a class="header" href="print.html#dokumentation-schreiben" id="dokumentation-schreiben"><h3>Dokumentation Schreiben</h3></a>
<p>Gehen wir also mal auf die einzelnen Teile diese Dokumentation ein:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Constructs a new `Rc&lt;T&gt;`.

#}</code></pre></pre>
<p>Im Grunde gelten hier die gleichen Regeln wie für git commit Nachrichten.
Die erste Zeile der Dokumentation sollte eine kurze Zusammenfassung dessen sein, worauf sie sich bezieht. Nur ein Satz. Nur Grundsätzliches. Nicht in die Tiefe.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
///
/// Other details about constructing `Rc&lt;T&gt;`s, maybe describing complicated
/// semantics, maybe additional options, all kinds of stuff.
///

#}</code></pre></pre>
<p>Wenn wir noch mehr aussagen möchten, können wir einen weiteren Absatz zur Beschreibung hinzufügen.</p>
<a class="header" href="print.html#spezielle-Überschriften" id="spezielle-Überschriften"><h4>Spezielle Überschriften</h4></a>
<p>Als nächstes ein paar spezielle Überschriften.
Diese beginnen in Markdown immer mit einem <code>#</code>.
Es gibt vier sehr gebräuchliche Überschriften, diese sind allerdings reine Konvention, sie haben keine eigene Syntax.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// # Panics
# fn foo() {}

#}</code></pre></pre>
<p><code>panic</code> indiziert in Rust vornehmlich, dass ein nicht behebbarer Fehler aufgetreten ist,
meistens durch Programmierfehler.
In diesen Fällen soll der aktuelle Thread &quot;kontrolliert abstürzen&quot;.
Wenn das in deinem Programm so vorgesehen ist, solltest du in der Dokumentation explizit darauf hinweisen.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// # Failures
# fn foo() {}

#}</code></pre></pre>
<p>Wenn deine Funktion/Methode ein <code>Result&lt;T, E&gt;</code> zurückgibt,
dann beschreibe die Bedingungen unter denen es einen <code>Err(E)</code> zurückgibt.
Das ist nicht ganz so wichtig wie eine Panik, da Failures Teil des Typsystems sind, aber es ist dennoch wichtig.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// # Safety
# fn foo() {}

#}</code></pre></pre>
<p>Wenn die Funktion <code>unsafe</code> verwendet, dann sollte ebenfalls explizit darauf hingewiesen werden, da hier eventuell Probleme auftreten können vor denen Rust anderweitig gefeit ist.</p>
<pre><code class="lang-rust">
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
</code></pre>
<p>Viertens, <code>Examples</code>.
Wenn du nur ein bis zwei Beispiele zu deiner Dokumentation hinzufügst erleichterst du anderen den Umgang mit deiner Bibliothek erheblich.
Dokumentation kann noch so detailiert sein, bevor man wissen möchte wie etwas funktioniert möchte man wissen wie man es benutzt.
Bevor du dich fragst wie das Mahlwerk deiner neue Kaffeemaschine funktioniert, interessiert dich doch eher, wie du damit Kaffee kochst oder?</p>
<pre><code class="lang-rust">
/// # Examples
///
/// Einfache `&str` Patterns:
///
/// ```
/// let v: Vec<&str> = "Mary had a little lamb".split(' ').collect();
/// assert_eq!(v, vec!["Mary", "had", "a", "little", "lamb"]);
/// ```
///
/// Kompliziertere Patterns mit einem Lambda:
///
/// ```
/// let v: Vec<&str> = "abc1def2ghi".split(|c: char| c.is_numeric()).collect();
/// assert_eq!(v, vec!["abc", "def", "ghi"]);
/// ```
</code></pre>
<p>Reden wir einmal etwas detailierter über Codeblöcke.</p>
<a class="header" href="print.html#codeblock-annotationen" id="codeblock-annotationen"><h4>Codeblock Annotationen</h4></a>
<p>Um Quelltext in Kommentaren zu schreiben benutzt man in Markdown drei Accent Graves.</p>
<pre><code class="lang-rust">
/// ```
/// println!("Hello, world");
/// ```
# fn foo() {}
</code></pre>
<p>Dabei wir wird in der ersten Zeile normalerweise die Programmiersprache für den Highlighter angegeben.
Bei uns ist Rust Standard, wenn du etwas anderes angeben willst dann sieht das zum Beispiel so aus:</p>
<pre><code class="lang-rust">
/// ```c
/// printf("Hello, world\n");
/// ```
# fn foo() {}
</code></pre>
<p>Wenn du Plaintext ausgeben willst nimm <code>```text</code></p>
<p>Es ist wichtig die richtige Codeblockannotation zu wählen, da <code>rustdoc</code> diese nicht nur für Highlighting verwendet.
Denn die Beispiele in deinem Crate können tatsächlich getestet werden.
Somit wird sichergestellt, dass sie nicht veraltet sind.
Wenn du allerdings C Code nicht mit <code>```c</code> annotierst, denkt <code>rustdoc</code> es muss ihn als Rust kompilieren und meldet dann Fehler, weil das natürlich nicht geht.</p>
<a class="header" href="print.html#dokumentation-als-tests" id="dokumentation-als-tests"><h2>Dokumentation als Tests</h2></a>
<p>Reden wir einmal über unsere Beispiele:</p>
<pre><code class="lang-rust">
/// ```
/// println!("Hello, world");
/// ```
# fn foo() {}
</code></pre>
<p>Dir ist vielleicht aufgefallen, dass du kein <code>fn main()</code> gebraucht hast.
<code>rustdoc</code> generiert hier automatisch einen Wrapper dafür.
Zum Beispiel:</p>
<pre><code class="lang-rust">
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>Das testet dann eigentlich diesen Code:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    use std::rc::Rc;
    let five = Rc::new(5);
}
</code></pre></pre>
<p>Hier ist der gesamte Algorithmus den <code>rustdoc</code> verwendet um Beispiele nachzubearbeiten:</p>
<ol>
<li>Jedes <code>#![foo]</code> Attribut am Anfang bleibt als Crate Attribut intakt.</li>
<li>Einige gebräuchliche <code>allow</code> Attribute werden eingefügt um die Linter zu beschwichtigen und die Regeln etwas weniger streng zu machen, u.a. <code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>, <code>unused_attributes</code>, und <code>dead_code</code>.</li>
<li>Wenn ein Beispiel keine <code>extern crate</code> enthält wird <code>extern crate &lt;mein crate&gt;;</code> hinzugefügt.</li>
<li>Zum Schluss wird der Code noch in ein <code>fn main() {...}</code> eingepackt, wenn das noch nicht so ist.</li>
</ol>
<a class="header" href="print.html#partielle-beispiele" id="partielle-beispiele"><h2>Partielle Beispiele</h2></a>
<p>Manchmal reicht die Nachbearbeitung aber nicht ganz,
zum Beispiel wenn man nur auf ganz bestimmte Zeilen hinweisen will.
Die obig genannten Beispiele mit <code>///</code> sehen eigentlich ein wenig anders aus:</p>
<pre><code class="language-text">/// Kleines Beispiel.
# fn foo() {}
</code></pre>
<p>anstatt:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Kleines Beispiel.
# fn foo() {}

#}</code></pre></pre>
<p>Man kann also <em>nur in Kommentaren</em> Zeilen mit einem <code>#</code> ausblenden.
Dieser Code wird dann mit kompiliert, aber nicht angezeigt.
Das kann man dazu nutzen um unvollständige Beispiele zu zeigen,
die allerdings trotzdem korrekt kompilieren sollen.
Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 6;
println!(&quot;{}&quot;, x + y);

#}</code></pre></pre>
<p>Dieser Code muss auf jeden Fall Zeile für Zeile erläutert werden.</p>
<p>Erst setzen wir <code>x</code> auf fünf:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);

#}</code></pre></pre>
<p>Danach <code>y</code> auf sechs:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);

#}</code></pre></pre>
<p>Zum Schluss geben wir deren Summe aus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);

#}</code></pre></pre>
<p>Hier das ganze nochmal als Plaintext:</p>
<blockquote>
<p>Erst setzen wir <code>x</code> auf fünf:</p>
<pre><code class="language-text">let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Danach <code>y</code> auf sechs:</p>
<pre><code class="language-text"># let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Zum Schluss geben wir deren Summe aus:</p>
<pre><code class="language-text"># let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
</blockquote>
<a class="header" href="print.html#macros-kommentieren" id="macros-kommentieren"><h3>Macros kommentieren</h3></a>
<p>Hier ist ein Beispiel eines dokumentierten <code>macro</code>s:</p>
<pre><code class="lang-rust">
/// Panic with a given message unless an expression evaluates to true.
///
/// # Examples
///
/// ```
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(1 + 1 == 2, “Math is broken.”);
/// # }
/// ```
///
/// ```should_panic
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(true == false, “I’m broken.”);
/// # }
/// ```
#[macro_export]
macro_rules! panic_unless {
    ($condition:expr, $($rest:expr),+) => ({ if ! $condition { panic!($($rest),+); } });
}
# fn main() {}
</code></pre>
<p>Hier fallen dir sicherlich drei Dinge auf:
wir müssen selber <code>extern crate</code> hinzufügen, damit wir <code>#[macro_use]</code> dranschreiben können.
Zweitens müssen wir auch noch selbst <code>main()</code> schreiben und zum Schluss ganz viele <code>#</code>s um das dann wieder unsichtbar zu machen.</p>
<a class="header" href="print.html#dokumentation-testen" id="dokumentation-testen"><h3>Dokumentation Testen</h3></a>
<p>Das geht entweder mit</p>
<pre><code class="language-bash">$ rustdoc --test path/to/my/crate/root.rs
</code></pre>
<p>oder</p>
<pre><code class="language-bash">$ cargo test
</code></pre>
<p><code>cargo test</code> funktioniert allerdings nur bei Bibliotheken, das liegt daran wie <code>rustdoc</code> funktioniert: Es linkt gegen die Bibliothek.</p>
<p>Annotationen die auch beim <a href="Testen.html">Testen</a> funktionieren, sind auch bei <code>rustdoc</code> manchmal nützlich, zum Beispiel:</p>
<pre><code class="lang-rust">
/// ```ignore
/// fn foo() {
/// ```
# fn foo() {}
</code></pre>
<p><code>ignore</code> bittet Rust dieses Beispiel bitte nicht mitzutesten,
wenn man weiß dass der Test scheitern würde.</p>
<pre><code class="lang-rust">
/// ```should_panic
/// assert!(false);
/// ```
# fn foo() {}
</code></pre>
<p>Das ist allerdings die allgemeinste Lösung, meisten ist eine der folgenden Möglichkeiten passender.
Oder man will lieber <code>text</code> verwenden, wenn es kein gar Rustcode ist oder Zeilen mit <code>#</code> ausblenden um ein Beispiel zu konstruieren welches trotzdem funktioniert.</p>
<p><code>should_panic</code> sagt <code>rustdoc</code> dass der code korrekt compiliert, aber der Test fehlschlagen soll.</p>
<pre><code class="lang-rust">
/// ```no_run
/// loop {
///     println!("Hello, world");
/// }
/// ```
# fn foo() {}
</code></pre>
<p>Und <code>no_run</code> führt dazu, dass dein Code kompiliert, aber nicht nicht ausgeführt  wird. Dann zählt der Test als bestanden, sobald er korrekt kompiliert hat.</p>
<a class="header" href="print.html#module-dokumentieren" id="module-dokumentieren"><h3>Module dokumentieren</h3></a>
<p>Rust hat noch eine weitere Art von Kommentar, <code>//!</code>.
Diese Syntax bezieht sich nicht auf den darauf folgenden Block,
sondern auf den äußeren.
Sprich:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
mod foo {
    //! This is documentation for the `foo` module.
    //!
    //! # Examples

    // ...
}

#}</code></pre></pre>
<p>Am häufigsten wirst du <code>//!</code> am Anfang von Dateien sehen.
Dateien werden häufig also Module eingebunden: <code>./foo.rs</code> durch <code>mod foo</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
//! A module for using `foo`s.
//!
//! The `foo` module contains a lot of useful functionality blah blah blah

#}</code></pre></pre>
<p>Oder einfach am Anfang deiner <code>lib.rs</code>.</p>
<a class="header" href="print.html#dokumentationsstil" id="dokumentationsstil"><h3>Dokumentationsstil</h3></a>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> (englisch) ist die vollständige Quelle für alle Konventionen bezüglich Dokumentation in Rust.</p>
<a class="header" href="print.html#andere-dokumentation" id="andere-dokumentation"><h2>Andere Dokumentation</h2></a>
<p>Alles oben genannte funktioniert auch in nicht-<code>.rs</code> Dateien.
Da Kommentare in Markdown geschrieben sind,
kannst du auch gleich <code>.md</code> Dateien verwenden.</p>
<p>Wenn du Dokumentation in Markdowndateien schreibst, brauchst du die Prefixe nicht mehr. Zum Beispiel:</p>
<pre><code class="lang-rust">
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>ist einfach</p>
<pre><code class="lang-markdown">
# Examples

```
use std::rc::Rc;

let five = Rc::new(5);
```
</code></pre>
<p>in einer Markdown Datei. Wichtig ist hier nur, dass diese Dokumente immer einen Titel brauchen:</p>
<pre><code class="language-markdown">% The title

This is the example documentation.
</code></pre>
<p>Das <code>%</code> am Angang muss in der aller ersten Zeile sein.</p>
<a class="header" href="print.html#doc-attribute" id="doc-attribute"><h2>'doc' Attribute</h2></a>
<p>Wenn man genauer hinschaut, dann sind Kommentare nur eine einfachere Variante von Dokumentationsattributen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// this
# fn foo() {}

#[doc=&quot;this&quot;]
# fn bar() {}

#}</code></pre></pre>
<p>ist identisch zu:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
//! this

#![doc=&quot;/// this&quot;]

#}</code></pre></pre>
<p>Das wirst du nicht häufig zu sehen bekommen, aber manchmal kann es nützlich sein.</p>
<a class="header" href="print.html#re-exporte" id="re-exporte"><h2>Re-Exporte</h2></a>
<p><code>rustdoc</code> wird die Dokumentation von Re-Exporten an an beiden Stellen einblenden:</p>
<pre><code class="language-ignore">extern crate foo;

pub use foo::bar;
</code></pre>
<p>Hier wird die Dokumentation für 'bar<code>sowohl in der Dokumentation für das Crate</code>foo`, also auch in der dokumentation deines Crates auftauchen.</p>
<p>Das kann durch <code>no_inline</code> unterdrückt werden:</p>
<pre><code class="language-ignore">extern crate foo;

#[doc(no_inline)]
pub use foo::bar;
</code></pre>
<a class="header" href="print.html#kontrolle-des-html" id="kontrolle-des-html"><h3>Kontrolle des HTML</h3></a>
<p>Auf ein paar Aspekte des von <code>rustdoc</code> generierten HTMLs kannst du mit <code>#![doc]</code> Einfluss nehmen.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#![doc(html_logo_url = &quot;https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;,
#fn main() {
       html_favicon_url = &quot;https://www.rust-lang.org/favicon.ico&quot;,
       html_root_url = &quot;https://doc.rust-lang.org/&quot;)]

#}</code></pre></pre>
<p>Auf die weise kannst du das Logo, inklusive Favicon ersetzen.</p>
<a class="header" href="print.html#optionen-zum-einbinden-von-dateien" id="optionen-zum-einbinden-von-dateien"><h2>Optionen zum Einbinden von Dateien</h2></a>
<p><code>rustdoc</code> enthält außerdem noch ein paar weitere Kommandozeilen Optionen:</p>
<ul>
<li><code>--html-in-header FILE</code>: inkludiert den Inhalt der Datei am Ende der
<code>&lt;head&gt;...&lt;/head&gt;</code> Sektion.</li>
<li><code>--html-before-content FILE</code>: inkludiert den Inhalt einer Datei direkt nach
<code>&lt;body&gt;</code>, vor dem generierten Inhalt (inklusive Suchleiste).</li>
<li><code>--html-after-content FILE</code>: inkludiert den Inhalt der Datei am nach dem generierten Inhalt.</li>
</ul>
<a class="header" href="print.html#sicherheitshinweis" id="sicherheitshinweis"><h2>Sicherheitshinweis</h2></a>
<p>Das Markdown in den Dokumentationskommentaren wird unbearbeitet in die Webseite kopiert. Also vorsichtig mit HTML wie:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// &lt;script&gt;alert(document.cookie)&lt;/script&gt;
# fn foo() {}

#}</code></pre></pre>
<p>☺</p>
<a class="header" href="print.html#iteratoren" id="iteratoren"><h1>Iteratoren</h1></a>
<p>Redern wir doch mal über Schleifen.</p>
<p>Erinnerst du dich noch an Rusts <code>for</code>-Schleifen?
Hier nochmal zur Erinnerung:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    println!(&quot;{}&quot;, x);
}

#}</code></pre></pre>
<p>Nun da du schon etwas mehr Rust kennst können wir ja mal etwas genauer darauf eingehen, wie das so funktioniert.
Ranges (wie <code>0..10</code>) sind &quot;Iteratoren&quot;.
Ein Iterator ist etwas auf dem man <code>.next()</code> aufrufen kann und das uns dann eine Sequenz an Dingen gibt.</p>
<p>So wie in diesem Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut range = 0..10;

loop {
    match range.next() {
        Some(x) =&gt; {
            println!(&quot;{}&quot;, x);
        },
        None =&gt; { break }
    }
}

#}</code></pre></pre>
<p>Hier erstellen wir ein <strong><em>mutable binding</em></strong> zu einer Range.
Jetzt können wir mit <code>loop</code> darüber iterieren.
Das innere <code>match</code> entscheidet anhand der Ausgabe von <code>range.next()</code> ob wir weitermachen.
<code>.next()</code> gibt ein <code>Option&lt;i32&gt;</code> aus, also entweder ein <code>Some(i32)</code>, dann machen wir weiter, oder ein <code>None</code>, dann brechen wir mit <code>break</code> ab.</p>
<p><strong>Nein</strong>, dass musst du nicht jedes mal so machen, dafür gibt es <code>for</code>!</p>
<p><code>for</code> ist eigentlich nur syntaktischer Zucker für dieses <code>loop</code>/<code>match</code>/<code>break</code>-Konstrukt.
<code>for</code>-Schleifen sind allerdings nicht das einzige was Iteratoren benutzt.
Um seine eigenen Iteratoren verwenden zu können muss man das <code>Iterator</code> Trait implementieren.
Wie man das macht liegt etwas außerhalb des Rahmens dieses Kapitels.
Rust bietet eine ganze Reihe nützlicher Iterator für unterschiedliche Aufgaben.
Bevor wir allerdings auf diese genauer eingehen noch ein Anti-Pattern, welches du unbedingt vermeiden solltest. Und zwar solltest du eine Range nicht zum Zählen verwenden, zum Beispiel so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let nums = vec![1, 2, 3];

for i in 0..nums.len() {
    println!(&quot;{}&quot;, nums[i]);
}

#}</code></pre></pre>
<p>Das ist zwar möglich, aber unnötig kompliziert, denn Vektoren bringen ihre eigenen Iteratoren mit:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, num);
}

#}</code></pre></pre>
<p>Das ist besser aus zwei Gründen.
Ersten drückt das besser aus worum es hier geht, es ist semantisch sinnvoller.
Und zweitens ist es effizienter und sicherer,
die erste Variante muss extra checken ob die Indexe überhaupt valide sind.
Das ist allgemein der Vorteil von Iteratoren, sie sind auch ohne bound checks sicher.</p>
<p>Es gibt noch eine kleine Unklarheit aufgrund der Tatsache wie <code>println!</code> funktioniert.
<code>num</code> ist eigentlich ein <code>&amp;i32</code>, also nur eine Referenz auf ein <code>i32</code>.
<code>println!</code> übernimmt hier das Dereferenzieren für uns, wir sehen das also gar nicht.
Dementsprechend funktioniert auch dieser Code hier:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, *num);
}

#}</code></pre></pre>
<p>Hier dereferenzieren wir <code>num</code> explizit.
Warum gibt uns <code>&amp;nums</code> Referenzen?
Erstens, weil wir explizit mit <code>&amp;</code> danach gefragt haben.
Zweitens, wenn es uns die Daten direkt geben würde müssten wir deren Besitzer werden, das heißt es müsste implizit kopieren.
Mit <code>&amp;</code> leihen wir nur Referenzen zu den Elementen aus, ohne kopieren oder verschieben zu müssen.</p>
<p>Nun da wir festgestellt haben, dass Ranges nicht das tun was wir wollen,
reden wir mal darüber was wir eigentlich wollen.</p>
<p>Es gibt drei Kategorien von Dingen die hier wichtig sind:
<strong>Iteratoren</strong>, <strong>Iterator-Adapter</strong> und <strong>Konsumenten</strong>.</p>
<ul>
<li><em>Iteratoren</em> geben uns eine Sequenz von Werten, einen nach dem anderen.</li>
<li><em>Iterator-Adapter</em> operieren auf Iteratoren und produzieren andere Iteratoren</li>
<li><em>Konsumenten</em> nehmen Iteratoren und produzieren daraus finale Werte oder Mengen.</li>
</ul>
<p>Reden wir als erstes mal über die Konsumenten, da wir ja schon einen Iterator gesehen haben, Ranges.</p>
<a class="header" href="print.html#konsumenten" id="konsumenten"><h2>Konsumenten</h2></a>
<p>Ein <em>Konsument</em> &quot;konsumiert&quot; einen Iterator, das heißt, dass er daraus eine feste  Menge Werte oder einen einzelnen Wert daraus erstellt.
Der gebräuchlichste Konsument ist <code>collect()</code>.
Dieser Code hier kompiliert nicht, zeigt aber die Verwendung von <code>collect()</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let one_to_one_hundred = (1..101).collect();

#}</code></pre></pre>
<p>Wie du siehst rufen wir <code>collect()</code> auf unseren Iterator auf.
<code>collect()</code> nimmt so viele Elemente wie ein Iterator ihm gibt und gibt eine Sammlung an Resultaten aus.
Warum kompiliert dieser Code also nicht?
Rust kann hier nicht erkennen, welchen Type die Elemente von <code>(0..101)</code> haben.
Die Sammlung muss aber einen Bestimmten Typ haben, also geben wir hier einfach einen an:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;i32&gt;&gt;();

#}</code></pre></pre>
<p>Falls du die <code>::&lt;&gt;</code> Syntax noch vor Augen hast, sie erlaubt es uns einen Hinweis auf den Typ zu geben, denn eigentlich ist <code>collect()</code> als <code>fn collect&lt;B: FromIterator&lt;Self::Item&gt;&gt;(self)</code> implementiert.
Mit <code>_</code> können wir einen partiellen tipp geben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;_&gt;&gt;();

#}</code></pre></pre>
<p>Das sagt so viel wie &quot;Sammel in einen <code>Vec&lt;T&gt;</code>, aber inferiere bitte was <code>T</code> für mich.&quot;
<code>_</code> heißt deshalb manchmal auch &quot;Typeplatzhalter&quot;.</p>
<p>Neben <code>collect()</code> gibt es auch noch <code>find()</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let greater_than_forty_two = (0..100)
                             .find(|x| *x &gt; 42);

match greater_than_forty_two {
    Some(_) =&gt; println!(&quot;Found a match!&quot;),
    None =&gt; println!(&quot;No match found :(&quot;),
}

#}</code></pre></pre>
<p><code>find()</code> nimmt eine Closure und gibt das erste Elemente zurück, für das die Closure <code>true</code> zurückgibt.
<code>find()</code> gibt ein <code>Option&lt;T&gt;</code> zurück, anstatt dem Element selbst, da es ja auch nichts, <code>None</code>, finden könnte.</p>
<p>Ein weiterer Konsument ist <code>fold()</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let sum = (1..4).fold(0, |sum, x| sum + x);

#}</code></pre></pre>
<p><code>fold(basis, |akkumulator, element| ...)</code> nimmt zwei Argumente:
Das erste ist ein Element, genannt <em>Basis</em>.
Das zweite ist eine Closure, die selbst zwei Argumente annimmt: den <em>Akkumulator</em> und ein <em>Element</em>.
Bei jeder Iteration wird die Closure aufgerufen und das Resultat ist bei der nächsten Iteration der Akkumulator.
Beim erstenmal ist die Basis noch der Akkumulator.</p>
<p>Verwirrt? Schon klar.</p>
<p>Machen wir das mal an einem Beispiel etwas deutlicher:</p>
<table><thead><tr><th> Basis </th><th> Akkumulator </th><th> Element </th><th> Closure Ergebnis </th></tr></thead><tbody>
<tr><td> 0     </td><td> 0           </td><td> 1       </td><td> 1                </td></tr>
<tr><td> 0     </td><td> 1           </td><td> 2       </td><td> 3                </td></tr>
<tr><td> 0     </td><td> 3           </td><td> 3       </td><td> 6                </td></tr>
</tbody></table>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# (1..4)
.fold(0, |sum, x| sum + x);

#}</code></pre></pre>
<p><code>0</code> ist unsere Basis hier, <code>sum</code> ist unser Akkumulator und <code>x</code> das Element.
Beim ersten Mal ist <code>sum</code> <code>0</code> und <code>x</code> ist <code>1</code>, das erste Element von <code>nums</code>.
Dann addieren wir <code>sum</code> und <code>x</code>, also <code>0 + 1 = 1</code>.
Das Ergebnis ist beim zweiten Mal ist dann der Akkumulator, also <code>sum</code> und das nächste Element, <code>2</code>, ist nun unser <code>x</code>.
<code>1 + 2 = 3</code>, und dann ist das wieder <code>sum</code>.
Im letzten Durchgang ist <code>x</code> nun <code>3</code>, also <code>3 + 3 = 6</code>, fertig.</p>
<p><code>fold()</code> sieht auf den ersten Blick etwas komisch aus, aber danach siehst du dass du es überall brauchen wirst, immer wenn du eine Liste an Dingen hast, die du zu einem einzigen Ergebnis zusammenfassen musst.</p>
<p>Konsumenten sind vor allem aufgrund einer Eigenschaft von Iteratoren wichtig, die wir noch gar nicht besprochen hatten, Iteratoren sind faul oder &quot;lazy&quot;.
Was bedeutet das? Das sehen wir gleich wenn wir über Iteratoren reden.</p>
<a class="header" href="print.html#iteratoren-1" id="iteratoren-1"><h2>Iteratoren</h2></a>
<p>Wie wir bereits festgestellt haben sind Iteratoren etwas auf dem wir wiederholt <code>.next()</code> aufrufen können und das uns dann eine Sequenz von Dingen gibt.
Weil du <code>.next()</code> aufrufen musst können sich Iteratoren die Arbeit sparen,
alle Elemente im Voraus zu generieren.
Dieser Code hier zum Beispiel generiert nicht wirklich die zahlen von <code>1</code> bis <code>99</code>, sondern repräsentiert nur Sequenz:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let nums = 1..100;

#}</code></pre></pre>
<p>Da wir mit der Range nicht wirklich irgendwas gemacht haben, hat es auch keine Sequenz generiert.
Wenn wir sie allerdings konsumieren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let nums = (1..100).collect::&lt;Vec&lt;i32&gt;&gt;();

#}</code></pre></pre>
<p>dann verlangt <code>collect()</code> von unserer Range der Reihe nach jede Zahl und somit wird die Sequenz erst erzeugt.</p>
<p>Ranges sind einer von zwei grundlegenden Iteratoren wie wir kennen lernen werden.
Der andere ist <code>iter()</code>.
<code>iter()</code> macht aus einem <code>Vector</code> einen einfachen Iterator der uns jedes Element gibt:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let nums = vec![1, 2, 3];

for num in nums.iter() {
   println!(&quot;{}&quot;, num);
}

#}</code></pre></pre>
<p>Diese zwei Iteratoren sollten am Anfang reichen, es gibt aber noch fortgeschrittenere Iteratoren, inklusive unendlichen.</p>
<p>Das reicht aber erstmal. Iterator-Adapter sind das letzte Konzept dem wir uns hier widmen wollen. Also...</p>
<a class="header" href="print.html#iterator-adapter" id="iterator-adapter"><h2>Iterator-Adapter</h2></a>
<p><em>Iterator-Adapter</em> nehmen Iteratoren und modifizieren sie um daraus neue Iteratoren zu machen. Der einfachste ist <code>map</code>:</p>
<pre><code class="language-rust ignore">(1..100).map(|x| x + 1);
</code></pre>
<p><code>map</code> ruft auf jedes Element eines Iterators eine Closure auf.
Das oben genannte Beispiel gibt uns also <code>2-100</code>.
Zumindest fast, wenn du das Beispiel kompilierst bekommst du eine Warnung:</p>
<pre><code class="language-text">warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Hier schlägt die Faulheit zu!
Die Closure wird nie ausgeführt werden.
Genau wie im nächsten Beispiel, welches <strong>keine</strong> Zahlen ausgibt:</p>
<pre><code class="language-rust ignore">(1..100).map(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>Wenn du einen Iterator mit Nebeneffekten verwenden willst, dann nimm lieber <code>for</code>.</p>
<p>Es gibt tonnenweise interessante Iterator-Adapter.
<code>take()</code> gibt einen Iterator über die nächsten 5 Elemente von dem original Iterator zurück.
Probieren wir das doch mal an einer unendlichen Range aus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for i in (1..).take(5) {
    println!(&quot;{}&quot;, i);
}

#}</code></pre></pre>
<p>Hier bekommen wir:</p>
<pre><code class="language-text">1
2
3
4
5
</code></pre>
<p><code>filter()</code> ist ein Adapter der eine Closure nimmt, die <code>true</code> oder <code>false</code> zurück gibt.
Der neue Iterator enthält dann nur Element für die die Closure <code>true</code> zurück gegeben hat:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for i in (1..100).filter(|&amp;x| x % 2 == 0) {
    println!(&quot;{}&quot;, i);
}

#}</code></pre></pre>
<p>Hier kriegen wir alle geraden Zahlen zwischen 1 und hundert.
Wichtig: <code>filter()</code> konsumiert die Elemente nicht, es gibt nur Referenzen weiter, deshalb nimmt die Closure auch nur <code>&amp;x</code> an.</p>
<p>Du kannst alle drei Sachen hintereinander hängen, angefangen mit einem Iterator als &quot;Quelle&quot; ein paar Adaptern als &quot;Filter&quot; und einem Konsumenten zum Schluss:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
(1..)
    .filter(|&amp;x| x % 2 == 0)
    .filter(|&amp;x| x % 3 == 0)
    .take(5)
    .collect::&lt;Vec&lt;i32&gt;&gt;();

#}</code></pre></pre>
<p>Das hier ergibt einen <code>Vector</code> der <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code> und <code>30</code> enthält.</p>
<p>Das ist nur ein kleiner Vorgeschmack darauf was man mit Iteratoren, Iterator-Adaptern und Konsumenten alles tun kann.
Es gibt eine Menge richtig nützlicher Iteratoren und du kannst auch deine eigenen schreiben.
Iteratoren bieten eine sichere und effiziente Methode um all möglichen Listen zu manipulieren.
Am Anfang ist das vielleicht etwas ungewohnt, aber nach einer Weile will man gar nicht mehr zurück.
Eine vollständige Liste aller Iteratoren und Konsumenten lies die <a href="http://doc.rust-lang.org/stable/std/iter/index.html">Moduldokumentation</a> für Iterator.</p>
<a class="header" href="print.html#nebenläufigkeit" id="nebenläufigkeit"><h1>Nebenläufigkeit</h1></a>
<p>Nebenläufigkeit und Parallelismus sind heutzutage unglaublich wichtige Themen in der Informatik genauso wie in der Industrie.
Prozessoren haben mehr und mehr Kerne und dennoch sind Programmierer nicht gut darauf vorbereitet die vielen Kerne voll auszunutzen.</p>
<p>Rusts Speichersicherheit hat einen großen Einfluß auf dessen Verhalten bei Nebenläufigkeit.
Das Typsystem garantiert bereits zur Kompilierzeit dass keine Speicherveletzungen oder Raceconditions auftreten können.</p>
<p>Bevor wir auf Nebenläufigkeit genauer eingehen ist eine Sache erwähnenswert:
Rust ist systemnah genug, dass ein Großteil der hier genannten Funktionalität von der Standardbibliothek zur Verfügung gestellt werden kann, nicht von der Sprache selbst.
Das heißt dass wenn man eine bestimmte Art und Weise wie Rust mit Nebenläufigkeit umgeht nicht mag, dann kann man einfach eine Alternative implementieren.
<a href="https://github.com/carllerche/mio">mio</a> ist ein gutes Beispiel dafür.</p>
<a class="header" href="print.html#hintergrund-send-und-sync" id="hintergrund-send-und-sync"><h2>Hintergrund: <code>Send</code> und <code>Sync</code></h2></a>
<p>Über Verhalten bei Nebenläufigkeit lässt sich häufig nur schwer eine Aussage treffen.
In Rust haben wir jedoch ein strenges, statisches Typsystem, welches uns genau das erleichtert.
Zum Beispiel gibt uns Rust zwei Traits, die uns dabei helfen zu Entscheiden, ob Code potentiell Nebenläufigkeit enthalten kann oder nicht.</p>
<a class="header" href="print.html#send" id="send"><h3><code>Send</code></h3></a>
<p>Das erste Trait über das wir reden ist <a href="http://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a>.
Wenn ein Typ <code>T</code> <code>Send</code> implementiert, dann heißt das, dass es möglich ist den Besitzer dieses Typs sicher zwischen zwei Threads zu wechseln.</p>
<p>Das ist wichtig um bestimmte Restriktionen durchzusetzen.
Wenn wir zum Beispiel einen <code>Channel</code> haben der zwei Threads verbindet, und gerne Daten durch diesen <code>Channel</code> zu einem anderen Thread senden möchten, dann müssen wir sichergehen, dass der Datentyp den wir senden wollen auch <code>Send</code> implementiert.</p>
<p>Eine andere Möglichkeit ist, wenn wir zum Beispiel eine FFI-Bibliothek anbinden, die nicht threadsicher ist, dann wollen wir explizit nicht <code>Send</code> implementieren, damit der Kompiler bereits verbietet, dass ein Objekt jemals den Thread wechselt.</p>
<a class="header" href="print.html#sync" id="sync"><h3><code>Sync</code></h3></a>
<p>Das zweite Trait heißt
<a href="http://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code>Sync</code></a>.
Wenn ein Typ <code>T</code> <code>Sync</code> implementiert, dann heißt das, dass es möglich ist diesen Typen sicher von zwei Threads aus über mehrere Referenzen zu nutzen, ohne Speichersicherheit zu verletzen.
Das impliziert dass Typen die <em>keine</em> <a href="Mutabilit%C3%A4t.html">interne Mutabilität</a> haben inhärent <code>Sync</code> sind, inklusive der primitiven Typen (wie <code>u8</code>) und daraus zusammengesetzte Typen.</p>
<p>Um Referenzen zwischen Threads zu teilen bietet einen Wrapper namens <code>Arc&lt;T&gt;</code>.
<code>Arc&lt;T&gt;</code> implementiert sowohl <code>Send</code> als auch <code>Sync</code> wenn,
und nur wenn, <code>T</code> ebenfalls sowohl <code>Send</code> als auch <code>Sync</code> implementiert.
So kann zum Beispiel ein Objekt vom Typ <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> nicht von einem Thread zum anderen übertragen werden da
<a href="choosing-your-guarantees.html#refcell%3Ct%3E"><code>RefCell</code></a> nicht <code>Sync</code> implementiert, dementsprechend kann <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> nicht <code>Send</code> implementieren.</p>
<a class="header" href="print.html#threads" id="threads"><h2>Threads</h2></a>
<p>Rusts Standardbibliothek enthält auch eine Bibliothek für Threads,
<code>std::thread</code>, die es dir erlaubt Code parallel auszuführen.
Hier mal ein Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    thread::spawn(|| {
        println!(&quot;Hello from a thread!&quot;);
    });
}
</code></pre></pre>
<p>Die Methode <code>thread::spawn()</code> nimmt eine <a href="Closures.html">Closure</a> an,
die dann im neuen Thread ausgeführt wird.
Der Handle den sie zurück gibt,
kann benutzt werden um zu warten bis der Kind-Thread fertig ist und dessen Ergebnis zu erhalten:</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        &quot;Hello from a thread!&quot;
    });

    println!(&quot;{}&quot;, handle.join().unwrap());
}
</code></pre></pre>
<p>Es bieten zwar viele Sprachen Möglichkeiten an Threads zu starten,
das ist allerdings sehr unsicher.
Es gibt ganze Bücher darüber, wie man Fehler,
die dabei auftreten können, wenn zwei Threads auf den gleichen Speicher zugreifen, verhindern kann.
Rust hilft hier mit seinem Typsystem, indem es Raceconditions bereits beim Kompilieren verhindert.
Wie teilt man also nun eigentlich Sachen zwischen Threads?</p>
<a class="header" href="print.html#sicherer-geteilter-und-veränderbarer-speicher" id="sicherer-geteilter-und-veränderbarer-speicher"><h2>sicherer geteilter und veränderbarer Speicher</h2></a>
<p>Rusts Typsystem biete ein Konzept an,
das zu gut klingt um wahr zu sein: &quot;Sicherer geteilter, veränderbarer Speicher&quot;.
Unter Programmierern ist es allgemein bekannt, dass von mehreren Threads aus schreibbarer Speicher die Wurzel allen Übels ist.</p>
<blockquote>
<p>Shared mutable state is the root of all evil. Most languages attempt to deal
with this problem through the 'mutable' part, but Rust deals with it by
solving the 'shared' part.</p>
</blockquote>
<p>Das gleiche <a href="Besitz.html">Besitz System</a> das uns dabei hilft Zeiger richtig zu benutzen hilft uns auch dabei Raceconditions zu vermeiden,
die schlimmste Art von Bugs bei Nebenläufigkeit.</p>
<pre><code class="language-ignore">use std::thread;

fn main() {
    let mut data = vec![1, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
</code></pre>
<p>führt zu diesem Fehler:</p>
<pre><code class="language-text">8:17 error: capture of moved value: `data`
        data[i] += 1;
        ^~~~
</code></pre>
<p>Rust weiß dass das nicht sicher wäre.
Wenn wir eine Referenz auf <code>data</code> in jedem Thread haben,
dann müßte auch jeder Thread Besitzer von <code>data</code> sein.
Das geht in Rust nicht.</p>
<p>Also brauchen wir einen Typen, der es uns erlaubt mehrere Referenzen auf einen Wert zu haben, die wir auf mehrere Threads verteilen können.
Sprich, einen Typen der <code>Sync</code> implementiert.</p>
<p>Dafür benutzen wir <code>Arc&lt;T&gt;</code>, <em>Atomarer Referenz Count</em> (atomarer Referenzzähler).
<code>Arc&lt;T&gt;</code> ist ähnlich wie <code>Box&lt;T&gt;</code>,
nur dass es erlaubt Zugriff auf seinen Inhalt von mehreren Referenzen aus zu haben.
Es können sich quasi mehrere Threads den Besitz teilen.
Reference Counting bedeutet in diesem Zusammenhang,
dass gezählt wird, wieviele Referenzen zu einem Wert existieren.
Atomar bedeutet, dass Raceconditions nicht möglich sind.</p>
<pre><code class="language-ignorele">use std::thread;
use std::sync::Arc;

fn main() {
    let mut data = Arc::new(vec![1, 2, 3]);

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
</code></pre>
<p>Wenn wir hier <code>clone()</code> auf unser <code>Arc&lt;T&gt;</code> aufrufen,
wird intern ein Counter inkrementiert und ein Handle an den Thread weitergegeben.</p>
<p>Und... immer noch ein Fehler:</p>
<pre><code class="language-text">&lt;anon&gt;:11:24 error: cannot borrow immutable borrowed content as mutable
&lt;anon&gt;:11                    data[i] += 1;
                             ^~~~
</code></pre>
<p><code>Arc&lt;T&gt;</code> geht davon aus, dass sein Inhalt sicher geteilt werden kann, also auch <code>Sync</code> implementiert.
Das gilt für unseren Wert nur solange er unveränderlich ist.
Aber wir wollen ja etwas verändern, also müssen wir irgendwie sicherstellen, dass immer nur ein Thread gleichzeitig unseren Wert verändern kann.
Sie müssen sich gegenseitig ausschließen oder <em>mutually exclude</em> another.</p>
<p>Dafür gibt es den Typ <code>Mutex&lt;T&gt;</code>!
Hier also endlich die funktionierende Variante:</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
</code></pre></pre>
<p>Beachte dass der Wert von <code>i</code> in die Closure kopiert wird und nicht zwischen den Threads geteilt wird.
Beachte außerdem, dass <a href="http://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#method.lock"><code>lock</code></a> eine Methode von
<a href="http://doc.rust-lang.org/stable/std/sync/struct.Mutex.html"><code>Mutex</code></a> folgende Signatur hat:</p>
<pre><code class="language-ignore">fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;
</code></pre>
<p>und weil <code>Send</code> für <code>MutexGuard&lt;T&gt;</code> nicht implementiert ist kann der Guard keine Threadgrenze überschreiten, wodurch Locks nur threadlokal akquiriert und freigegeben werden können.</p>
<p>Schauen wir uns das doch mal genauer an:</p>
<pre><pre class="playpen"><code class="language-rust"># use std::sync::{Arc, Mutex};
# use std::thread;
# fn main() {
#     let data = Arc::new(Mutex::new(vec![1, 2, 3]));
#     for i in 0..3 {
#         let data = data.clone();
thread::spawn(move || {
    let mut data = data.lock().unwrap();
    data[i] += 1;
});
#     }
#     thread::sleep_ms(50);
# }
</code></pre></pre>
<p>Erst rufen wir <code>lock()</code> auf, wodurch wir das Lock auf das Mutex akquirieren.
Weil das fehlschlagen könnte gibt <code>lock()</code> ein <code>Result&lt;T, E&gt;</code> zurück.
Das <code>unwrap()</code> ist nur hier im Beispiel angemessen.
Sobald wir das Lock haben dürfen wir endlich den Wert verändern.</p>
<p>Zum Schluss warten wir noch mit einem Timer, das ist nicht ideal,
weil wir die Zeit genau abschätzen müssten.
Besser wäre einer der Mechanismen den Rusts Standardbibliothek zum Synchronisieren von Threads bereithält: Channels.</p>
<a class="header" href="print.html#channels" id="channels"><h2>Channels</h2></a>
<p>Hier ist eine Variante des obigen Beispiels in der wir Channels zur Synchronisation verwenden, anstatt eine bestimmte Zeit zu warten:</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc;

fn main() {
    let data = Arc::new(Mutex::new(0));

    let (tx, rx) = mpsc::channel();

    for _ in 0..10 {
        let (data, tx) = (data.clone(), tx.clone());

        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            *data += 1;

            tx.send(());
        });
    }

    for _ in 0..10 {
        rx.recv();
    }
}
</code></pre></pre>
<p>Wir nutzen die Methode <code>mpsc::channel()</code> um einen Channel zu erzeugen.
Dann <code>send</code>en wir einfach <code>()</code> hindurch und warten darauf bis Zehn davon zurückgekommen sind.</p>
<p>Dieser Channel sendet zwar nur einfache Signale, aber wir alles was <code>Send</code> implementiert durch den Channel senden!</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    for i in 0..10 {
        let tx = tx.clone();

        thread::spawn(move || {
            let answer = i * i;

            tx.send(answer);
        });
    }

    for _ in 0..10 {
        println!(&quot;{}&quot;, rx.recv().unwrap());
    }
}
</code></pre></pre>
<p>Hier erzeugen wir 10 Threads und lassen jeden das Quadrat einer Zahl berechnen (<code>i</code> zum Zeitpunkt von <code>spawn()</code>) und dann mit <code>send()</code> zurücksenden.</p>
<a class="header" href="print.html#panics" id="panics"><h2>Panics</h2></a>
<p>Eine <code>panic!</code> crasht den aktuellen Thread, deshalb kann man in Rust Threads als Mechanismus zur Isolation verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::thread;

let handle = thread::spawn(move || {
    panic!(&quot;oops!&quot;);
});

let result = handle.join();

assert!(result.is_err());

#}</code></pre></pre>
<p><code>Thread.join()</code> gibt uns ein <code>Result</code>, welches zeigt, ob der Thread erfolgreich war oder ob eine <code>panic!</code> aufgetreten ist.</p>
<a class="header" href="print.html#fehlerbehandlung" id="fehlerbehandlung"><h1>Fehlerbehandlung</h1></a>
<a class="header" href="print.html#garantien-wählen" id="garantien-wählen"><h1>Garantien Wählen</h1></a>
<a class="header" href="print.html#ffi" id="ffi"><h1>FFI</h1></a>
<a class="header" href="print.html#borrow-und-asref" id="borrow-und-asref"><h1>Borrow und AsRef</h1></a>
<a class="header" href="print.html#release-kanäle" id="release-kanäle"><h1>Release Kanäle</h1></a>
<a class="header" href="print.html#syntax-und-semantik" id="syntax-und-semantik"><h1>Syntax und Semantik</h1></a>
<p>Dieser Abschnitt zerbricht Rust in kleine Stückchen,
eines für jedes Konzept.</p>
<p>Wenn du Rust lieber <em>bottom up</em> lernen möchtest,
dann lies ruhig in diesem Abschnitt weiter.</p>
<p>Dieser Abschnitt bildet außerdem eine Referenz für jedes Konzept.
Also wenn du ein anderes Tutorial liest und irgendwas verwirrend findest,
dann findest du das entsprechende Konzept hier irgendwo erklärt.</p>
<a class="header" href="print.html#variablenbindung" id="variablenbindung"><h1>Variablenbindung</h1></a>
<p>Fast jedes nicht-triviale Rust Programm verwendet <em>Variablenbindungen</em>.
Sie sehen so aus:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
}
</code></pre></pre>
<p><code>fn main() {</code> in jedes Beispiel zu schreiben ist ein wenig mühsam,
also werden wir es in Zukunft weglassen. Falls du diese Beispiele ausprobierst,
stelle sicher, dass du deinen Code in einer <code>main()</code> Methode schreibst
(und nicht wie wir weglässt). Ansonsten bekommst du einen Fehler.</p>
<p>In vielen Sprachen wird das eine <em>Variable</em> genannt, aber Rusts
Variablenbindungen haben ein paar Tricks im Ärmel.
Zum Beispiel ist die linke Seite der <code>let</code> Anweisung ein ‘<a href="Muster.html">Muster</a>’
und nicht einfach nur ein Variablenname. Das bedeutet,
dass wir solche Sachen tun können:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let (x, y) = (1, 2);

#}</code></pre></pre>
<p>Nach dem Ausführen dieser Anweisung ist <code>x</code> <code>1</code> und <code>y</code> wird <code>2</code> sein.
Muster sind wirklich mächtig und haben <a href="Muster.html">ihren eigenen Abschnitt</a>
im Buch. Wir brauchen diese Features fürs Erste nicht, also behalten wir
uns das hier erstmal im Hinterkopf während wir weiter machen.</p>
<p>Rust ist eine statisch typisierte Sprache, was bedeutet, dass wir unsere
Typen im Voraus angeben müssen und diese zur Kompilierzeit überprüft werden.
Aber warum kompiliert dann unser erstes Beispiel? Nun, Rust kann etwas namens
‘Typinferenz’. Wenn Rust den Typ alleine herausfinden kann, dann müssen
wir den Typ nicht unbedingt angeben.</p>
<p>Wir können den Typ aber angeben, wenn wir wollen.
Ein Typ kommt nach einem Doppelpunkt (<code>:</code>):</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x: i32 = 5;

#}</code></pre></pre>
<p>In diesem Fall stellt <code>x</code> eine vorzeichenbehaftete 32-bit Ganzzahl dar.
Wenn ich dich fragen würde diese Zeile laut auszusprechen,
würdest du sagen:
&quot;<code>x</code> ist eine Bindung mit dem Typ <code>i32</code> und dem Wert <code>fünf</code>.&quot;</p>
<p>Rust hat viele verschiedene primitive Ganzzahl Typen.
Sie beginnen mit <code>i</code> für vorzeichenbehaftete Ganzzahlen und
mit <code>u</code> für vorzeichenlose Ganzzahlen. Die möglichen Ganzzahlgrößen sind
8, 16, 32 und 64 Bits.</p>
<p>In zukünftigen Beispielen werden wir manchmal den Typ in einem Kommentar
angeben. Diese Beispiele werden so aussehen:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5; // x: i32
}
</code></pre></pre>
<p>Beachte die Ähnlichkeit zwischen dieser Anmerkung und der Syntax,
die man mit <code>let</code> verwendet. Diese Art von Kommentar ist kein
idiomatisches Rust, aber wir werden sie dennoch gelegentlich verwenden
um klar zu machen, welche Typen Rust ableitet.</p>
<p>Standardmäßig sind Bindungen <em>immutable</em> [engl.: unveränderbar].
Dieser Code wird nicht kompilieren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 5;
x = 10;

#}</code></pre></pre>
<p>Er wird dir diesen Fehler geben:</p>
<pre><code class="language-text">error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
</code></pre>
<p>Wenn du eine Bindung <em>mutable</em> [engl.: veränderbar] machen willst,
dann geht das mit <code>mut</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5; // mut x: i32
x = 10;

#}</code></pre></pre>
<p>Es gibt verschiedene Gründe, dass Bindungen standardmäßig unveränderbar sind,
aber betrachten wir es einfach mal aus Sicht eines der Hauptziele von Rust:
Sicherheit. Wenn du vergisst <code>mut</code> zu schreiben, dann wird der Compiler
das abfangen und dich wissen lassen, dass du etwas veränderst,
was du vielleicht garnicht verändern willst.
Wären Bindungen standardmäßig veränderbar, dann könnte dir
der Compiler das nicht mitteilen.
Wenn die Veränderung doch beabsichtigt ist,
dann ist die Lösung ziemlich einfach: füge <code>mut</code> hinzu.</p>
<p>Es gibt noch weitere gute Gründe einen veränderbaren Zustand so häufig wie möglich
zu vermeiden, aber das sprengt den Rahmen dieses Guides. <!-- mmh, Ramen -->
Im Allgemeinen kann man häufig ausdrückliche Veränderungen vermeiden.
Somit sind diese in Rust bevorzugt. Dennoch benötigt man manchmal
Veränderungen, also sind sie nicht verboten.</p>
<p>Also zurück zu Bindungen. Rusts Variablenbindungen haben noch einen weiteren
Aspekt, der von anderen Sprachen abweicht:
Bindungen müssen initialisiert werden, bevor man sie benutzen kann.</p>
<p>Lass uns das ausprobieren.
Ändere deine <code>src/main.rs</code> damit sie so aussieht:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: i32;

    println!(&quot;Hallo Welt!&quot;);
}
</code></pre></pre>
<p>Du kannst <code>cargo build</code> in der Kommandozeile verwenden, um es zu kompilieren.
Du wirst zwar eine Warnung bekommen, aber das Programm wird trotzdem
&quot;Hallo Welt!&quot; ausgeben:</p>
<pre><code class="language-text">   Compiling hallo_welt v0.0.1 (file:///home/du/projekte/hallo_welt)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
</code></pre>
<p>Rust warnt uns jedes Mal, wenn eine Bindung nicht verwendet wird, ist
aber ansonsten kein Fehler an sich.
Die Sache ändert sich jedoch, wenn wir versuchen dieses <code>x</code> zu verwenden.
Lass uns das mal ausprobieren. Ändere dein Programm wie folgt:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: i32;

    println!(&quot;Der Wert von x ist: {}&quot;, x);
}
</code></pre></pre>
<p>Und, wenn wir versuchen zu kompilieren, bekommen wir diesen Fehler:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hallo_welt v0.0.1 (file:///home/du/projekte/hallo_welt)
src/main.rs:4:40: 4:41 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!(&quot;Der Wert von x ist: {}&quot;, x);
                                                     ^
note: in expansion of format_args!
&lt;std macros&gt;:2:23: 2:77 note: expansion site
&lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hallo_welt`.
</code></pre>
<p>Rust lässt uns keinen uninitialisierten Wert verwenden.
Lass uns als Nächstes über die Sachen reden, die wir in <code>println!</code>
verwendet haben.</p>
<p>Wenn du die zwei geschweiften Klammern (<code>{}</code>, manche nennen sie Schnurrbärte..)
in deinem auszugebenden String einfügst, dann interpretiert Rust sie als
Anweisung an dieser Stelle irgendeinen Wert einzufügen.
Wir fügen ein Komma und dann <code>x</code> hinzu, um anzuzeigen, dass wir den Wert von
<code>x</code> an dieser Stelle stehen haben wollen. Das Komma wird benutzt, um
mehrere Funktions- oder Makroargumente voneinander zu trennen, falls es mehr
als ein Argument gibt.</p>
<p>Wenn du einfach nur die geschweiften Klammern verwendest, dann versucht
Rust den Wert, basierend auf dessen Typ, auf eine sinnvolle
Art und Weise darzustellen.
Wenn du das Format etwas genauer spezifizieren willst, stehen dir eine
[breite Palette an Optionen zur Verfügung][format].
Fürs Erste bleiben wir beim Standard:
Es ist ja nicht so kompliziert eine Ganzzahl auszugeben.</p>
<a class="header" href="print.html#funktionen" id="funktionen"><h1>Funktionen</h1></a>
<p>Jedes Rust Programm hat mindestens eine Funktion,
die <code>main</code> Funktion:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
}
</code></pre></pre>
<p>Das ist die simpelste Funktionsdeklaration. Wie wir zuvor schon erwähnt haben,
leitet <code>fn</code> eine Funktion ein. Darauf folgt der Name und
ein leeres paar Klammern, da diese Funktion keine Argumente hat,
und ein paar geschweifte Klammern, die den Funktionskörper repräsentieren.
Hier ist eine Funktion namens <code>foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo() {
}

#}</code></pre></pre>
<p>Ok, wie funktioniert das nun mit Argumenten? Hier eine Funktion,
die eine Zahl ausgibt:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}

#}</code></pre></pre>
<p>Hier ist ein vollständiges Programm, welches <code>print_number</code> verwendet:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}
</code></pre></pre>
<p>Wie du sehen kannst funktionieren Funktionsargumente
ähnlich wie <code>let</code> Deklarationen:
Man fügt dem Namen einen Typ durch ein Doppelpunkt hinzu.</p>
<p>Hier ist ein vollständiges Programm,
welches zwei Zahlen addiert und dann ausgibt:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!(&quot;sum is: {}&quot;, x + y);
}
</code></pre></pre>
<p>Wie du siehst werden Argumente durch ein Komma getrennt.
Das gilt sowohl für den Aufruf als auch für die Deklaration von Funktionen.</p>
<p>Anders als bei <code>let</code>, <strong>musst</strong> du die Typen von Funktionsargumenten angeben.
Das hier funktioniert nicht:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn print_sum(x, y) {
    println!(&quot;sum is: {}&quot;, x + y);
}

#}</code></pre></pre>
<pre><code>
Man bekommt diesen Fehler:

```text
expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
</code></pre>
<p>Das ist eine bewusste Designentscheidung.
Obwohl das Herleiten der Typen eines kompletten Programmes möglich ist,
wie zum Beispiel in Sprachen wie Haskell, wird dennoch häufig dazu geraten
die Typen ausdrücklich zu dokumentieren.
Wir stimmen zu, dass ausdrückliche Typvermerke in Funktionssignaturen
und Typherleitung innerhalb von Funktionskörpern
wundervoller Mittelweg ist.</p>
<p>Wie gibt man einen Wert zurück?
Hier ist eine Funktion, die einen Wert inkrementiert.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#}</code></pre></pre>
<p>Rust Funktionen geben genau einen Wert zurück. Diesen gibt man nach einem
&quot;Pfeil&quot; an, welcher aus einem Bindestrich (<code>-</code>), gefolgt von einem
Größer-Gleich Zeichen (<code>&gt;</code>) besteht.
Die letzte Zeile der Funktion ist automatisch der Rückgabewert der Funktion.
Du wirst sehen, dass hier das Semikolon fehlt. Wenn wir es hinzufügen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn add_one(x: i32) -&gt; i32 {
    x + 1;
}

#}</code></pre></pre>
<p>Würden wir einen Fehler bekommen:</p>
<pre><code class="language-text">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</code></pre>
<p>Dies offenbart zwei interessante Aspekte von Rust:
Rust ist eine ausdrucksorientierte Sprache [expression-based language].
Es gibt nur zwei Arten von Anweisungen, alles andere ist ein Ausdruck.</p>
<p>Also worin liegt der Unterschied? Ausdrücke geben einen Wert zurück,
Anweisungen nicht. Deswegen bekommen wir hier eine
‘not all control paths return a value’ Meldung:
Die Anweisung <code>x + 1;</code> gibt keinen Wert zurück.
Es gibt zwei Arten von Anweisungen in Rust:
<code>Deklarations-Anweisungen</code> und <code>Ausdrucks-Anweisungen</code>.
Alles andere ist ein Ausdruck.
Lass uns zuerst über <em>Deklarations-Anweisungen</em> sprechen.</p>
<p>In manchen Sprachen können Variablenbindungen auch als Ausdruck geschrieben
werden. Wie z.B. in Ruby:</p>
<pre><code class="language-ruby">x = y = 5
</code></pre>
<p>In Rust jedoch ist die Variablenbindung mit <code>let</code> <em>kein</em> Ausdruck.
Das Folgende erzeugt einen Fehler beim Kompilieren:</p>
<pre><code class="language-text">let x = (let y = 5); // expected identifier, found keyword `let`
</code></pre>
<p>Der Compiler sagt uns hier, dass er den Beginn eines Ausdrucks erwartet hat,
denn ein <code>let</code> kann nur eine Anweisung einleiten, aber keinen Ausdruck.</p>
<p>Beachte, dass eine Zuweisung an eine bereits gebundene Variable (z.B. <code>y = 5</code>)
trotzdem ein Ausdruck ist, auch wenn dieser nicht besonders nützlich ist.
Anders als in anderen Sprachen, wo der zugewiesene Wert zurückgegeben
werden würde, wird in Rust stattdessen das leere Tupel <code>()</code> zurückgegeben.
Der Grund dafür ist, dass der zugewiesene Wert <a href="Besitz.html">nur einen Besitzer</a>
haben kann und einen anderen Wert zurückzugeben wäre zu überraschend:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut y = 5;

let x = (y = 6);  // x has the value `()`, not `6`

#}</code></pre></pre>
<p>Die zweite Art von Anweisung in Rust ist die <em>Ausdrucks-Anweisung</em>.
Ihr Zweck ist es jeden Ausdruck in eine Anweisung zu verwandeln.
In praktischer Hinsicht erwartet Rusts Grammatik, dass Anweisungen
aufeinander folgen. Das bedeutet, dass man Semikolons nutzt um
Ausdrücke voneinander zu trennen. Das bedeutet auch,
dass Rust anderen Sprachen, welche auch ein Semikolon am Ende einer Zeile
haben, sehr ähnlich sieht und man in Rust fast an jedem Ende einer Zeile ein
Semikolon sieht.</p>
<p>Wegen welcher Ausnahme sagen wir &quot;fast&quot;?.
Du hast sie bereits gesehen und zwar in diesem Code:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#}</code></pre></pre>
<p>Unsere Funktion gibt an ein <code>i32</code> zurückzugeben, aber mit einem Semikolon
würden wir stattdessen <code>()</code> zurückgeben.
Rust versteht, dass wir das wahrscheinlich nicht wollten und schlägt uns in
der Fehlermeldung, die wir sahen, vor das Semikolon zu entfernen.</p>
<a class="header" href="print.html#frühzeitige-rückgabe" id="frühzeitige-rückgabe"><h2>Frühzeitige Rückgabe</h2></a>
<p>Was ist mit frühzeitiger Rückgabe [early returns]?
Rust hat dafür ein Schlpsselwort namens <code>return</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) -&gt; i32 {
    return x;

    // we never run this code!
    x + 1
}

#}</code></pre></pre>
<p><code>return</code> in der letzten Zeile einer Funktion zu verwenden funktioniert zwar,
aber wird als schlechter Stil angesehen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) -&gt; i32 {
    return x + 1;
}

#}</code></pre></pre>
<p>Die vorherige Definition ohne <code>return</code> sieht vielleicht etwas komisch für dich
aus, falls du noch nicht mit ausdrucksorientierten Sprachen gearbeitet hast,
aber du wirst dich mit der Zeit daran gewöhnen.</p>
<a class="header" href="print.html#divergierende-funktionde" id="divergierende-funktionde"><h2>Divergierende Funktionde</h2></a>
<p>Rust hat eine spezielle Syntax für sogennannte ‘divergierende Funktionen’
[diverging functions], also Funktionen, die niemals zurückkehren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn diverges() -&gt; ! {
    panic!(&quot;This function never returns!&quot;);
}

#}</code></pre></pre>
<p><code>panic!()</code> ist ein Makro, ähnlich wie <code>println!()</code>, was wir bereits kennen.
Anders jedoch als <code>println!()</code> sorgt <code>panic!()</code> dafür, dass der aktuelle
Thread mit einer Fehlermeldung abstürzt. Weil diese Funktion einen Crash hervorruft, kehrt sie niemals zurück, deswegen hat sie den Typ ‘<code>!</code>’,
was man als ‘divergiert’ liest.</p>
<p>Wenn du zu einer main Funktion einen <code>diverges()</code> Aufruf hinzufügst
und das Programm ausführst, dann sieht die Ausgabe in etwa so aus:</p>
<pre><code class="language-text">thread ‘&lt;main&gt;’ panicked at ‘This function never returns!’, hello.rs:2
</code></pre>
<p>Wenn du mehr Informationen haben willst, dann kannst du einen Backtrace durch
Setzen der <code>RUST_BACKTRACE</code> Umgebungsvariable erhalten:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 ./diverges
thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p><code>RUST_BACKTRACE</code> funktioniert auch mit Cargos <code>run</code> Befehl:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
     Running `target/debug/diverges`
thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p>Divergierende Funktionen passen mit jedem Typen zusammen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x: i32 = diverges();
let x: String = diverges();

#}</code></pre></pre>
<a class="header" href="print.html#funktionszeiger" id="funktionszeiger"><h2>Funktionszeiger</h2></a>
<p>Wir können auch eine Variablenbindung erzeugen, die auf eine Funktion zeigt:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let f: fn(i32) -&gt; i32;

#}</code></pre></pre>
<p><code>f</code> ist eine Variable, die auf eine Funktion zeigt, welche ein <code>i32</code> als
Argument entgegennimmt und ein <code>i32</code> zurückgibt. Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn plus_one(i: i32) -&gt; i32 {
    i + 1
}

// without type inference
let f: fn(i32) -&gt; i32 = plus_one;

// with type inference
let f = plus_one;

#}</code></pre></pre>
<p>Wir können dann <code>f</code> benutzen um die Funktion aufzurufen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let six = f(5);

#}</code></pre></pre>
<a class="header" href="print.html#primitive-typen" id="primitive-typen"><h1>Primitive Typen</h1></a>
<p>Die Rust Programmiersprache hat eine Reihe von Typen die als &quot;primitiv&quot;
angesehen werden. Das bedeutet, dass sie in die Sprache eingebaut sind.
Rust ist so strukturiert, dass die Standardbibliothek auch eine Menge
nützlicher Typen zur Verfügung stellt,
die auch auf primitiven Typen aufbauen, aber diese hier sind am
&quot;primitivsten&quot;.</p>
<a class="header" href="print.html#booleans" id="booleans"><h1>Booleans</h1></a>
<p>Rust hat einen boolschen Typ namens <code>bool</code>. Er hat zwei mögliche Werte,
<code>true</code> und <code>false</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = true;

let y: bool = false;

#}</code></pre></pre>
<p>Eine übliche Nutzung ist in <a href="If.html"><code>if</code> Bedingungen</a>.</p>
<p>Du findest mehr Dokumentation zu <code>bool</code>s
<a href="https://doc.rust-lang.org/std/primitive.bool.html">in der Dokumentation der Standardbibliothek</a>.</p>
<a class="header" href="print.html#char" id="char"><h1><code>char</code></h1></a>
<p>Der <code>char</code> Typ stellt einen einzelnen Unicode Skalarwert dar.
Du kannst <code>char</code>s mit einzelnen Anführungsszeichen erzeugen: (<code>'</code>)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 'x';
let smiley = '😀';

#}</code></pre></pre>
<p>Anders als in manch anderen Spachen bedeutet das, dass <code>char</code>s
kein einzelnes byte, sondern vier bytes sind.</p>
<p>Du findest mehr Dokumentation zu <code>char</code>s
<a href="https://doc.rust-lang.org/std/primitive.char.html">in der Dokumentation der Standardbibliothk</a>.</p>
<a class="header" href="print.html#numerische-typen" id="numerische-typen"><h1>Numerische Typen</h1></a>
<p>Rust hat eine Vielzahl an numerischen Typen in ein paar Kategorien:
Vorzeichenbehaftet und Vorzeichenlos, feste und variable Größe,
Fließkomma- und Ganzzahl.</p>
<p>Diese Typen bestehen aus zwei Teilen: Der Kategorie und ihrer Größe.
Zum Beispiel ist <code>u16</code> ein vorzeichenloser Typ, der 16 bit groß ist.
Mehr Bits erlauben größere Zahlen.</p>
<p>Wenn ein Zahlenliteral keinen Typ explizit zugewiesen bekommt, dann
sind das hier die Standards:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 42; // x hat den Typ i32

let y = 1.0; // y hat den Typ f64

#}</code></pre></pre>
<p>Hier ist eine Liste der verschiedenen numerischen Typen, inklusive Links
zu ihrer jeweiligen Dokumentation in der Standardbibliothek:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
</ul>
<p>Lass sie uns nach Kategorie durchgehen:</p>
<a class="header" href="print.html#vorzeichenbehaftet-und-vorzeichenlos" id="vorzeichenbehaftet-und-vorzeichenlos"><h2>Vorzeichenbehaftet und Vorzeichenlos</h2></a>
<p>Ganzzahlige Typen kommen in zwei Ausführungen daher:
Vorzeichenbehaftet und Vorzeichenlos. Lass uns eine 4-bit Zahl betrachten
um den Unterschied zu verstehen. Eine Vorzeichenbehaftete 4-bit Zahl würde
dir erlauben Zahlen von <code>-8</code> bis <code>+7</code> zu speichern. Vorzeichenbehaftete Zahlen
verwenden die Zweierkomplementdarstellung. Eine vorzeichenlose 4-bit Zahl
braucht keine negativen Zahlen speichern und kann deswegen Werte von
<code>0</code> bis <code>+15</code> annehmen.</p>
<p>Vorzeichenlose Typen nutzen ein <code>u</code> für ihre Kategorie,
und vorzeichenbehaftete Typen nutzen ein <code>i</code>.
Das <code>i</code> steht für &quot;integer&quot; (Ganzzahl).
Also ist <code>u8</code> eine vorzeichenlose 8-bit Ganzzahl und
<code>i8</code> ist eine vorzeichenbehaftete 8-bit Ganzzahl.</p>
<a class="header" href="print.html#typen-fester-größe" id="typen-fester-größe"><h2>Typen fester Größe</h2></a>
<p>Typen fester Größe enthalten eine speziefische Anzahl an Bits in
ihrer Darstellung. Gültige Bitgrößen sind <code>8</code>, <code>16</code>, <code>32</code> und <code>64</code>.
Also ist <code>u32</code> eine vorzeichenlose Ganzzahl mit 32 Bits und
<code>i64</code> eine vorzeichenbehaftete Ganzzahl mit 64 Bits.</p>
<a class="header" href="print.html#fließkommatypen" id="fließkommatypen"><h2>Fließkommatypen</h2></a>
<p>Rust besitzt auch zwei Fließkommatypen: <code>f32</code> und <code>f64</code>.
Diese entsprechen dem IEEE-754 Standard für Fließkommazahlen
einfacher und doppelter Genauigkeit.</p>
<a class="header" href="print.html#arrays" id="arrays"><h1>Arrays</h1></a>
<p>Wie die meisten Programmiersprachen hat Rust Listentypen
um Sequenzen von Dingen darzustellen.
Die grundlegenste ist das <em>Array</em>, eine Liste fester Größe von Elementen
des selben Typs. Standardmäßig sind Arrays <em>immutable</em>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]

#}</code></pre></pre>
<p>Arrays haben den Typ <code>[T; N]</code>. Wir werden über diese <code>T</code> Notation
<a href="Generics.html">im Generics Abschnitt</a> reden. Das <code>N</code> ist eine Konstante zur
Kompilierzeit um die Länge des Arrays anzuzeigen.</p>
<p>Es gibt eine abkürzende Schreibweise um jedes Element des Arrays mit dem
selben Wert zu initialisieren. In diesem Beispiel wird jedes Element von
<code>a</code> mit <code>0</code> initialisiert:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let a = [0; 20]; // a: [i32; 20]

#}</code></pre></pre>
<p>Du kannst die Anzahl der Elemente eines Array <code>a</code> via <code>a.len()</code> ermitteln:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3];

println!(&quot;a hat {} Elemente&quot;, a.len());

#}</code></pre></pre>
<p>Du kannst auf ein bestimmtes Element des Arrays
mithilfe eckiger Klammern (<code>[]</code>) zugreifen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let namen = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // namen: [&amp;str; 3]

println!(&quot;Der zweite Name ist: {}&quot;, namen[1]);

#}</code></pre></pre>
<p>Die Indizes beginnen bei 0, wie in den meisten Programmiersprachen.
Somit ist der erste Name <code>namen[0]</code> und der zweite Name <code>namen[1]</code>.
Das vorherige Beispiel gibt <code>Der zweite Name ist: Brian</code> aus.
Wenn du versucht einen Index zu verwenden, der nicht im Array liegt,
dann wirst du einen Fehler bekommen: Arrayzugriffe werden zur Laufzeit
auf Gültigkeit geprüft. Solch ein fehlerhafter Zugriff ist die Quelle
vieler Bugs in anderen Systemsprachen.</p>
<p>Du findest mehr Dokumentation über <code>Arrays</code>s
<a href="https://doc.rust-lang.org/std/primitive.array.html">in der Dokumentation der Standardbibliothek</a>.</p>
<a class="header" href="print.html#slices" id="slices"><h1>Slices</h1></a>
<p>Ein <em>slice</em> [engl.: Scheibe/Stück] ist eine Referenz (oder eine &quot;Ansicht&quot;) auf
eine andere Datenstruktur. Sie erlauben einen sicheren und effizienten Zugriff
auf einen Teil eines Arrays ohne zu kopieren.
Zum Beispiel möchtest du vielleicht einfach nur auf eine Zeile einer
Datei im Speicher verweisen.
Aufgrund seiner Natur lässt sich ein <em>slice</em> nicht einfach so direkt erzeugen,
sondern nur aus einer existierenden Variable. Slices haben eine Länge,
können <em>mutable</em> oder <em>immutable</em> sein, und verhalten sich wie Arrays:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let a = [0, 1, 2, 3, 4];
let middle = &amp;a[1..4]; // Ein Slice von a: Nur die Elemente 1, 2, und 3
let complete = &amp;a[..]; // Ein Slice mit allen Elementen von a

#}</code></pre></pre>
<p>Slices haben den Typ <code>&amp;[T]</code>. Wir werden über dieses <code>T</code> sprechen, wenn wir
<a href="Generics.html">Generics</a> behandeln.</p>
<p>Du findest mehr Dokumentation über <code>Slice</code>s
<a href="https://doc.rust-lang.org/std/primitive.slice.html">in der Dokumentation der Standardbibliothek</a>.</p>
<a class="header" href="print.html#str" id="str"><h1><code>str</code></h1></a>
<p>Rusts <code>str</code> Typ ist der primitivste String Typ.
Als ein <a href="Gr%C3%B6%C3%9Fenlose_Typen.html">größenloser Typ</a> ist er alleine nicht sehr nützlich,
aber er wird sehr nützlich in Kombination mit einer Referenz, wie
zum Beispiel <a href="Strings.html"><code>&amp;str</code></a>. Von daher belassen wir es dabei.</p>
<p>Du findest mehr Dokumentation über <code>str</code>s
<a href="https://doc.rust-lang.org/std/primitive.str.html">in der Dokumentation der Standardbibliothek</a>.</p>
<a class="header" href="print.html#tupel" id="tupel"><h1>Tupel</h1></a>
<p>Ein Tupel ist eine geordnete Liste fester Größe. Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = (1, &quot;hallo&quot;);

#}</code></pre></pre>
<p>Wie du sehen kannst sehen kannst, sieht der Typ eins Tupels genaus aus wie
das jeweilige Tupel, aber mit den jeweiligen Typen anstatt Werten.
Aufmerksame Leser werden auch feststellen, dass Tupel heterogen sind:
Wir haben ein <code>i32</code> und ein <code>&amp;str</code> in diesem Tupel.
(In Systemprogrammiersprachen sind Strings ein wenig komplexer als in anderen
Sprachen. Fürs Erste lies <code>&amp;str</code> als ein <em>string slice</em>.
Wir werden bald noch mehr darüber lernen.)</p>
<p>Tupel können einander zugewiesen werden, wenn die enthaltenen Typen und
die <a href="Gloassar.html#stelligkeit">Stelligkeit</a> identisch sind. Tupel haben die gleiche Stelligkeit,
wenn sie dieselbe Länge haben.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;

#}</code></pre></pre>
<p>Du kannst auf die Felder eines Tupels durch <em>let Destrukturierung</em> zugreifen.
Hier ist ein Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let (x, y, z) = (1, 2, 3);

println!(&quot;x ist {}&quot;, x);

#}</code></pre></pre>
<p>Erinnerst du dich an <a href="Variablenbindung.html">zuvor</a>, als wir sagten, dass die linke Seite
etwas mächtiger ist als einfach nur eine Variablenbindung zuzuweisen?
Das ist ein Beispiel dafür. Wir können auf der linken Seite des <code>let</code> ein Muster
verwenden und, wenn es zu der rechten Seite passt, mehrere Variablenbindungen
gleichzeitig zuweisen. In diesem Fall &quot;destrukturiert&quot; <code>let</code> das Tupel bzw.
&quot;nimmt es auseinander&quot; und bindet die Teilstücke an Variablen.</p>
<p>Dieses Muster ist sehr mächtig und wir werden es später noch öfters sehen.</p>
<p>Du kannst ein Tupel mit einem einzelnen Element von einem Wert in Klammern durch
ein Komma unterscheiden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
(0,); // Tupel mit einem Element
(0); // 0 in Klammern

#}</code></pre></pre>
<a class="header" href="print.html#tupel-indizierung" id="tupel-indizierung"><h2>Tupel Indizierung</h2></a>
<p>Du kannst auf die Felder eines Tupel auch durch die &quot;Indizierungssyntax&quot;
zugreifen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let tupel = (1, 2, 3);

let x = tupel.0;
let y = tupel.1;
let z = tupel.2;

println!(&quot;x ist {}&quot;, x);

#}</code></pre></pre>
<p>Wie auch bei der Array Indizierung wird bei 0 begonnen, aber anders als
bei der Array Indizierung verwendet man ein <code>.</code> anstatt <code>[]</code>.</p>
<p>Du findest mehr Dokumentation über Tupel
<a href="https://doc.rust-lang.org/std/primitive.tuple.html">in der Dokumentation der Standardbibliothek</a>.</p>
<a class="header" href="print.html#funktionen-1" id="funktionen-1"><h1>Funktionen</h1></a>
<p>Funktionen haben auch einen Typ! Er sieht so aus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) -&gt; i32 { x }

let x: fn(i32) -&gt; i32 = foo;

#}</code></pre></pre>
<p>In diesem Fall ist <code>x</code> ein ‘Funktionszeiger’ auf eine Funktion,
welche ein <code>i32</code> akzeptiert und ein <code>i32</code> zurückgibt.</p>
<a class="header" href="print.html#kommentare" id="kommentare"><h1>Kommentare</h1></a>
<p>Nun, da wir Funktionen kennen, ist es ein guter Zeitpunkt über Kommentare
zu lernen. Kommentare sind Notizen, die man anderen Programmierern hinterlässt
um Dinge über deinen Code zu erklären.
Der Compiler ignoriert sie größtenteils.</p>
<p>Rust hat zwei wesentliche Arten von Kommentaren:
<em>Zeilenkommentare</em> [<em>line comments</em>] und <em>Doku-Kommentare</em> [<em>doc comments</em>].</p>
<p>Hier ein Beispiel mit 4 Zeilenkommentaren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Line comments are anything after ‘//’ and extend to the end of the line.

let x = 5; // this is also a line comment.

// If you have a long explanation for something, you can put line comments next
// to each other. Put a space between the // and your comment so that it’s
// more readable.

#}</code></pre></pre>
<p>Die andere Art von Kommentar ist ein Doku-Kommentar.
Doku-Kommentare werden mit <code>///</code> anstatt <code>//</code> eingeleitet und
unterstützen darin das Markdown Format:</p>
<pre><code class="lang-rust">
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(5));
/// # fn add_one(x: i32) -> i32 {
/// #     x + 1
/// # }
/// ```
fn add_one(x: i32) -> i32 {
    x + 1
}
</code></pre>
<p>Es gibt noch eine weitere Kommentarform, nämlich <code>//!</code>,
um Dinge zu dokumentieren in denen diese Kommentare enthalten sind
(z.B. in Crates, Modulen oder Funktionen) anstatt das zu kommentieren,
was nach ihnen folgt.
Üblicherweise wird diese Form von Kommentar am Anfang einer
Crate (lib.rs) oder eines Moduls (mod.rs) verwendet:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
//! # The Rust Standard Library
//!
//! The Rust Standard Library provides the essential runtime
//! functionality for building portable Rust software.

#}</code></pre></pre>
<p>Wenn du Doku-Kommentare schreibst, dann ist es sehr hilfreich, wenn du
Beispiele angibst.
Du wirst feststellen, dass wir hier ein neues Makro verwendet haben:
<code>assert_eq!</code>. Dies vergleicht zwei Werte und <code>panic!</code>t wenn sie nicht
gleich sind. Das ist sehr hilfreich in der Dokumentation.
Es gibt ein weiteres Makro, nämlich <code>assert!</code>, welches <code>panic!</code>t,
wenn der übergebene Wert <code>false</code> ist.</p>
<p>Du kannst das <a href="Dokumentation.html"><code>rustdoc</code></a> Tool verwenden um eine HTML
Dokumentation aus diesen Doku-Kommentaren zu erstellen und außerdem
den Beispielcode als Tests laufen lassen!</p>
<a class="header" href="print.html#if" id="if"><h1>if</h1></a>
<p>Rusts <code>if</code> ist nicht besonders kompliziert, aber es ähnelt viel mehr dem
<code>if</code> einer dynamisch typisierten Sprache, als dem einer
eher traditionellen Sprachen.</p>
<p>Lass uns also darüber sprechen, um sicherzustellen, dass du die Feinheiten
verstehst.</p>
<p><code>if</code> ist eine spezielle Form eines allgemeineren Konzeptes, dem Zweig [branch].
Der Name stammt von dem Zweig im Baum: Ein Entscheidungspunkt, an welchem
verschiedene Wege gegangen werden können, je nachdem wie du dich entscheidest.</p>
<p>Im Falle von <code>if</code> gibt es eine Entscheidung mit zwei möglichen Pfaden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 5;

if x == 5 {
    println!(&quot;x is five!&quot;);
}

#}</code></pre></pre>
<p>Wenn wir den Wert von <code>x</code> zu etwas anderem ändern würden, dann würde die
&quot;x is five!&quot; Zeile nicht ausgegeben werden. Genauer gesagt, wenn der Ausdruck
nach dem <code>if</code> zu <code>true</code> ausgewertet wird, dann wird der
nachfolgende Block ausgeführt. Wird er zu <code>false</code> ausgewertet,
dann wird der Block <em>nicht</em> ausgeführt.</p>
<p>Wenn du möchtest, dass in dem <code>false</code> Fall etwas passieren soll,
dann benutze <code>else</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 5;

if x == 5 {
    println!(&quot;x is five!&quot;);
} else {
    println!(&quot;x is not five :(&quot;);
}

#}</code></pre></pre>
<p>Wenn es mehr als einen Fall gibt, benutze <code>else if</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 5;

if x == 5 {
    println!(&quot;x is five!&quot;);
} else if x == 6 {
    println!(&quot;x is six!&quot;);
} else {
    println!(&quot;x is not five or six :(&quot;);
}

#}</code></pre></pre>
<p>Das ist alles ziemlich standardgemäß. Man kann aber auch sowas machen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 5;

let y = if x == 5 {
    10
} else {
    15
}; // y: i32

#}</code></pre></pre>
<p>Was wir auch so schreiben könnten (und wohl auch lieber sollten):</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32

#}</code></pre></pre>
<p>Dies funktioniert, weil <code>if</code> ein Ausdruck ist. Der Wert den der <code>if</code> Ausdruck
zurückgibt ist der letzte des jeweiligen Zweiges.
Ein <code>if</code> ohne <code>else</code> gibt immer ein <code>()</code> zurück.</p>
<a class="header" href="print.html#schleifen" id="schleifen"><h1>Schleifen</h1></a>
<p>Rust bietet drei verschiedene Herangehensweisen eine iterative
Tätigkeit auszuführen. Es gibt: <code>loop</code>, <code>while</code> und <code>for</code>.
Jede dieser Herangehensweisen hat seine eigenen Anwendungsfälle.</p>
<a class="header" href="print.html#loop" id="loop"><h2>loop</h2></a>
<p>Die Endlosschleife <code>loop</code> ist die simpelste Schleifenform, die es in Rust gibt.
Mithilfe des <code>loop</code> Schlüsselwortes bietet uns Rust einen Weg an für eine
unbestimmte Zeit zu iterieren, bis wir irgendwann eine terminierende Anweisung
erreichen.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
loop {
    println!(&quot;Loop forever!&quot;);
}

#}</code></pre></pre>
<a class="header" href="print.html#while" id="while"><h2>while</h2></a>
<p>Rust hat auch eine <code>while</code> Schleife. Sie sieht zum Beispiel so aus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}

#}</code></pre></pre>
<p><code>while</code> Schleifen sind die richtige Wahl, wenn du nicht sicher bist,
wie häufig etwas wiederholt werden muss.</p>
<p>Wenn du eine Endlosschleife benötigst,
dann bist du vielleicht dazu verleitet das hier zu schreiben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
while true {

#}</code></pre></pre>
<p>Es ist jedoch besser in diesem Fall <code>loop</code> zu verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
loop {

#}</code></pre></pre>
<p>Rusts Kontrollflussanalyse behandelt diese Konstrukt anders als <code>while true</code>,
da es weiß, dass die Schleife endlos ist. Allgemein gilt, je mehr
Informationen wir dem Compiler geben können, umso bessere Sicherheit und
Code-Erzeugung erhalten wir. Deswegen solltest du immer <code>loop</code> vorziehen,
falls du planst endlos zu iterieren.</p>
<a class="header" href="print.html#for" id="for"><h2>for</h2></a>
<p>Die <code>for</code> Schleife wird benutzt um eine bestimmte Anzahl von Iterationen
auszuführen. Rusts <code>for</code> Schleifen arbeiten jedoch ein wenig anders als in
anderen Systemsprachen. Rusts <code>for</code> Schleifen sehen <em>nicht</em> aus wie &quot;C-Style&quot;
<code>for</code> Schleifen:</p>
<pre><code class="language-c">for (x = 0; x &lt; 10; x++) {
    printf( &quot;%d\n&quot;, x );
}
</code></pre>
<p>Stattdessen sehen sie so aus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    println!(&quot;{}&quot;, x); // x: i32
}

#}</code></pre></pre>
<p>In etwas abstrakteren Begriffen:</p>
<pre><code>for var in expression {
    code
}
</code></pre>
<p>Der Ausdruck ist ein <a href="Iteratoren.html">Iterator</a>. Der Iterator gibt eine Reihe von
Elementen zurück. Jedes Element ist eine Iteration der Schleife. Dieses Element
wird an den Namen <code>var</code> gebunden, welcher für den Schleifenkörper gültig ist.
Sobald der Körper beendet ist, wird der nächste Wert aus dem Iterator geholt
und der Schleifenkörper damit erneut ausgefürt. Wenn es keine weiteren
Werte mehr gibt, dann ist die <code>for</code> Schleife vorbei.</p>
<p>In unserem Beispiel ist <code>0..10</code> ein Ausdruck, welche eine Start- und eine
Endposition hat und einen Iterator über diese Werte zurückgibt.
Das obere Ende ist jedoch exklusiv, also gibt unsere Schleife nur
<code>0</code> bis <code>9</code>, jedoch nicht <code>10</code> aus.</p>
<p>Rust hat bewusst keine &quot;C-Style&quot; <code>for</code> Schleifen.
Jedes Element der Schleife manuell zu kontrollieren ist kompliziert und
fehleranfällig, sogar für erfahrene C-Entwickler.</p>
<a class="header" href="print.html#enumerate" id="enumerate"><h3>Enumerate</h3></a>
<p>Wenn du gerne wüsstest wie oft du schon iteriert hast, kannst du die
<code>.enumerate()</code> Funktion verwenden.</p>
<a class="header" href="print.html#bei-ranges" id="bei-ranges"><h4>Bei <code>range</code>s:</h4></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for (i,j) in (5..10).enumerate() {
    println!(&quot;i = {} and j = {}&quot;, i, j);
}

#}</code></pre></pre>
<p>Ausgabe:</p>
<pre><code class="language-text">i = 0 and j = 5
i = 1 and j = 6
i = 2 and j = 7
i = 3 and j = 8
i = 4 and j = 9
</code></pre>
<p>Vergiss nicht die Klammern um den <code>Range</code></p>
<a class="header" href="print.html#bei-iteratoren" id="bei-iteratoren"><h4>Bei Iteratoren:</h4></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for (linenumber, line) in lines.enumerate() {
    println!(&quot;{}: {}&quot;, linenumber, line);
}

#}</code></pre></pre>
<!-- Original:
# let lines = "hello\nworld".lines();
for (linenumber, line) in lines.enumerate() {
    println!("{}: {}", linenumber, line);
}
-->
<p>Ausgabe:</p>
<pre><code class="language-text">0: Content of line one
1: Content of line two
2: Content of line three
3: Content of line four
</code></pre>
<a class="header" href="print.html#die-iteration-frühzeitig-beenden" id="die-iteration-frühzeitig-beenden"><h2>Die Iteration frühzeitig beenden</h2></a>
<p>Lass uns einen Blick auf die <code>while</code> Schleife von zuvor werfen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let mut done = false;

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}

#}</code></pre></pre>
<p>Wir mussten eine boolsche <code>mut</code> Variable <code>done</code> verwenden um die Schleife
zu beenden. Rust hat zwei Schüsselwörter, die uns helfen eine Iteration zu
modifizieren: <code>break</code> und <code>continue</code>.</p>
<p>In diesem Fall können wir die Schleife mittels <code>break</code> verbessern:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;

loop {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 { break; }
}

#}</code></pre></pre>
<p>Wir iterieren nun endlos und benutzen <code>break</code> um frühzeitig aus der Schleife
auszubrechen. Eine explizite <code>return</code> Anweisung würde die Schleife ebenso
frühzeitig beenden.</p>
<p><code>continue</code> ist ähnlich, aber anstatt die Schleife zu beenden,
geht man damit zur nächsten Iteration.
Das hier wird nur ungerade Zahlen ausgeben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    if x % 2 == 0 { continue; }

    println!(&quot;{}&quot;, x);
}

#}</code></pre></pre>
<a class="header" href="print.html#schleifen-label" id="schleifen-label"><h2>Schleifen Label</h2></a>
<p>Es könnte sein, dass du in bestimmten Situationen verschachtelte Schleifen
hast und festlegen willst für welche dein <code>break</code> oder <code>continue</code> gelten soll.
Wir bei den meisten anderen Sprache, gelten <code>break</code> und <code>continue</code>
standardmäßig nur für die innerste Schleife.
Wenn du allerdings <code>break</code> oder <code>continue</code> auf eine äußere Schleife anwenden
möchtest, dann kannst du Label verwenden um das festzulegen.
Der folgende Code wird nur etwas ausgeben,
wenn sowohl <code>x</code> als auch <code>y</code> ungerade sind.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // continues the loop over x
        if y % 2 == 0 { continue 'inner; } // continues the loop over y
        println!(&quot;x: {}, y: {}&quot;, x, y);
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#besitz" id="besitz"><h1>Besitz</h1></a>
<p>Dieser Guide ist einer von dreien, der Rusts Ownership-System.
präsentiert. Dies ist eines von Rusts einzigartigen und verlockenden
Features mit denen Rust Entwickler vertraut sein sollten.
Durch Ownership [engl.: Besitz] erreicht Rust sein größtes Ziel,
die Speichersicherheit.
Es gibt ein paar verschiedene Konzepte, jedes mit seinem eigenen Kapitel:</p>
<ul>
<li>Besitz, das was du gerade liest.</li>
<li><a href="Referenzen_Und_Ausleihen.html">Ausleihen</a>, und das assozierte Feature ‘Referenzen’</li>
<li><a href="Lebensdauer.html">Lebensdauer</a>, ein fortgeschrittenes Konzept des Ausleihens.</li>
</ul>
<p>Diese drei Kapitel sind verwandt und deswegen in dieser Reihenfolge zu lesen.
Du wirst alle drei benötigen um das Ownership-System vollständig zu verstehen.</p>
<a class="header" href="print.html#meta" id="meta"><h1>Meta</h1></a>
<p>Bevor wir in die Details gehen gibt es zwei wichtige Hinweise über das
Ownership-System.</p>
<p>Rust hat einen Fokus auf Sicherheit und Geschwindigkeit.
Es erfüllt diese Ziele durch viele &quot;kostenfreie Abstraktionen&quot;
[‘zero-cost abstractions’], was bedeutet, dass in Rust die Kosten so niedrig
wie möglich sind um diese Abstraktionen funktionieren zu lassen.
Jegliche Analyse über die wie in diesem Guide sprechen wird
<em>zur Kompilierzeit</em> ausgeführt. Du zahlst für diese Features
keine Extrakosten zur Laufzeit.</p>
<p>Jedoch hat dieses System einen gewissen Preis: Die Lernkurve.
Viele neue Rust Nutzer erleben etwas,
was wir &quot;mit dem <em>borrow checker</em> kämpfen&quot; nennen,
wobei dann Rust verweigert ein Programm zu kompilieren,
bei dem der Author denkt, dass es korrekt ist.
Das passiert häufig, da das mentale Modell des Programmierers von Ownership
nicht den eigentlichen Regeln entspricht, die Rust implementiert.
Du wirst wahrscheinlich zuerst etwas ähnliches erleben.
Die guten Nachricht ist aber:
Erfahrenere Rust Entwickler berichten, dass, sobald sie eine Zeit
mit den Regeln des Ownership-Systems gearbeitet haben, sie immer weniger
mit dem <em>borrow checker</em> kämpfen müssen.</p>
<p>Mit diesem Wissen, lass uns über Besitz lernen.</p>
<a class="header" href="print.html#besitz-1" id="besitz-1"><h1>Besitz</h1></a>
<p><a href="Variablenbindung.html">Variablenbindungen</a> haben eine bestimmte Eigenschaft in Rust:
Sie ‘besitzen’ das woran sie gebunden sind.
Das bedeutet, dass Rust die gebundene Ressource freigibt,
wenn eine Bindung den Scope verlässt. Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo() {
    let v = vec![1, 2, 3];
}

#}</code></pre></pre>
<p>Wenn <code>v</code> in den Scope eingeführt wird, dann wird ein neuer <a href="https://doc.rust-lang.org/std/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>
erzeugt. In diesem Fall alloziert der Vektor auch Speicher auf dem Heap für
die ersten drei Elemente. Wenn <code>v</code> dann am Ende von <code>foo</code> den Scope verlässt,
räumt Rust alles was mit dem Vektor zu tun hat auf, sogar den auf dem Heap
allozierten Speicher.
Dies passiert deterministisch am Ende des Scopes.</p>
<a class="header" href="print.html#move-semantik" id="move-semantik"><h1>Move Semantik</h1></a>
<p>Es gibt jedoch noch ein paar mehr Feinheiten hier: Rust stellt sicher,
dass es <em>genau eine</em> Bindung an eine bestimmte Ressource gibt.
Zum Beispiel, wenn wir einen Vektor haben, können wir ihn einer
anderen Bindung zuweisen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];

let v2 = v;

#}</code></pre></pre>
<p>Aber, wenn wir versuchen <code>v</code> danach zu verwenden,
bekommen wir einen Fehler:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];

let v2 = v;

println!(&quot;v[0] is: {}&quot;, v[0]);

#}</code></pre></pre>
<p>Der Fehler sieht so aus:</p>
<pre><code class="language-text">error: use of moved value: `v`
println!(&quot;v[0] is: {}&quot;, v[0]);
                        ^
</code></pre>
<p>Etwas ähnliches passiert, wenn wir eine Funktion definieren,
welche etwas in Besitz nimmt und dann versuchen etwas zu verwenden,
nachdem wir es ihr als Argument übergeben haben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn take(v: Vec&lt;i32&gt;) {
    // what happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!(&quot;v[0] is: {}&quot;, v[0]);

#}</code></pre></pre>
<p>Der gleiche Fehler: ‘use of moved value’.
Wenn wir den Besitz an etwas übergeben, dann sagen wir,
dass wir die Sache &quot;bewegt&quot; [moved] haben. Man braucht hier keine
besondere Annotation, Rust macht das einfach standardmäßig.</p>
<a class="header" href="print.html#die-details" id="die-details"><h2>Die Details</h2></a>
<p>Der Grund warum die Bindung nach einem <em>move</em> nicht verwenden können ist
subtil, aber sehr wichtig. Wenn wir solchen Code schreiben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];

let v2 = v;

#}</code></pre></pre>
<p>Die erste Zeile alloziert Speicher für das Vektor-Objekt <code>v</code> und für
die Daten, die es enthält. Das Vektor-Objekt wird auf dem <a href="Der_Stack_Und_Der_Heap.html">Stack</a>
gespeichert und enthält einen Zeiger auf den Inhalt (<code>[1, 2, 3]</code>), welcher
auf dem <a href="Der_Stack_Und_Der_Heap.html">Heap</a> gespeichert ist. Wenn wir <code>v</code> zu <code>v2</code> bewegen,
dann wird eine Kopie dieses Zeigers für <code>v2</code> erstellt.
Das bedeutet, dass es zwei Zeiger gibt, die auf den Inhalt des Vektors auf dem
Heap zeigen. Es würde Rusts Sicherheitsgarantien verletzen indem es ein
<em>data race</em> ermöglicht. Deswegen verbietet Rust es <code>v</code> zu benutzen,
nachdem wir es bewegt haben.</p>
<p>Es ist auch wichtig zu erwähnen, dass Optimierungen die tatsächliche Kopie
der Bytes auf dem Stack entfernen können, je nach den Umständen.
Also ist ein <code>move</code> nicht so ineffizient wie er zuerst scheint.</p>
<a class="header" href="print.html#copy-typen" id="copy-typen"><h2><code>Copy</code> Typen</h2></a>
<p>Wir haben etabliert, dass, wenn Besitz an eine andere Bindung übertragen wird,
man die Originalbindung nicht mehr verwenden lassen. Es gibt jedoch ein
<a href="Traits.html">Trait</a> namens <code>Copy</code> der dieses Verhalten ändert.
Wir haben über Traits noch nicht diskutiert, aber fürs erste kannst du sie
dir als eine Art Annotation eines bestimmten Types vorstellen,
welche zusätzliches Verhalten hinzufügt. Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let v = 1;

let v2 = v;

println!(&quot;v is: {}&quot;, v);

#}</code></pre></pre>
<p>In diesem Fall ist <code>v</code> ein <code>i32</code>, welcher den <code>Copy</code> Trait implementiert.
Das bedeutet, dass genau wie bei einem <em>move</em> eine Kopie der Daten gemacht
wird, wenn wir <code>v</code> nach <code>v2</code> zuweisen. Aber anders als bei einem <em>move</em>,
können wir <code>v</code> danach trotzdem verwenden. Das ist so, weil ein <code>i32</code>
keine Zeiger auf irgendwelche Daten woanders hat und somit eine
vollständige Kopie ist.</p>
<p>Alle primitiven Typen implementieren den <code>Copy</code> Trait und ihr Besitz
wird deswegen nicht bewegt wie man vermuten könnte, gemäß den
´Ownership Regeln´. Zum Beispiel kompilieren die folgenden beiden
Codeschnipsel nur, weil <code>i32</code> und <code>bool</code> den <code>Copy</code> Trait implementieren.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = 5;

    let _y = double(a);
    println!(&quot;{}&quot;, a);
}

fn double(x: i32) -&gt; i32 {
    x * 2
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = true;

    let _y = change_truth(a);
    println!(&quot;{}&quot;, a);
}

fn change_truth(x: bool) -&gt; bool {
    !x
}
</code></pre></pre>
<p>Wenn wir Typen verwendet hätten, die nicht den <code>Copy</code> Trait implementieren,
dann würden wir einen Kompilierfehler bekommen, da wir versucht hätten
einen <em>bewegten Wert</em> [moved value] zu verwenden.</p>
<pre><code class="language-text">error: use of moved value: `a`
println!(&quot;{}&quot;, a);
               ^
</code></pre>
<p>Wir werden im <a href="Traits.html">Traits</a> Abschnitt diskutieren wie
man mit seinen eigenen Typen <code>Copy</code> implementiert.</p>
<a class="header" href="print.html#mehr-als-besitz" id="mehr-als-besitz"><h1>Mehr als Besitz</h1></a>
<p>Wenn wir jedes mal den Besitz zurückgeben müssten,
dann würde jede Funktion die wir schreiben so aussehen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // do stuff with v

    // hand back ownership
    v
}

#}</code></pre></pre>
<p>Das würde sehr lästig werden. Es würde umso schlimmer werden je mehr
Sachen wir in Besitz nehmen wollen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);

#}</code></pre></pre>
<p>Bäh! Der Rückgabetyp, die Return-Zeile und der Funktionsaufruf sind
viel zu kompliziert.</p>
<p>Glücklicherweise bietet uns Rust ein Feature namens &quot;Borrowing&quot;
[engl.: Ausleihen], welches uns hilft dieses Problem zu lösen.
Das ist das Thema des nächsten Abschnitts!</p>
<a class="header" href="print.html#referenzen-und-ausleihen" id="referenzen-und-ausleihen"><h1>Referenzen und Ausleihen</h1></a>
<p>Dieser Guide ist einer von dreien, der Rusts Ownership-System.
präsentiert. Dies ist eines von Rusts einzigartigen und verlockenden
Features mit denen Rust Entwickler vertraut sein sollten.
Durch Ownership [engl.: Besitz] erreicht Rust sein größtes Ziel,
die Speichersicherheit.
Es gibt ein paar verschiedene Konzepte, jedes mit seinem eigenen Kapitel:</p>
<ul>
<li><a href="Besitz.html">Besitz</a>, das Schlüsselkonzept.</li>
<li>Ausleihen, das was du gerade liest.</li>
<li><a href="Lebensdauer.html">Lebensdauer</a>, ein fortgeschrittenes Konzept des Ausleihens.</li>
</ul>
<p>Diese drei Kapitel sind verwandt und deswegen in dieser Reihenfolge zu lesen.
Du wirst alle drei benötigen um das Ownership-System vollständig zu verstehen.</p>
<a class="header" href="print.html#meta-1" id="meta-1"><h1>Meta</h1></a>
<p>Bevor wir in die Details gehen gibt es zwei wichtige Hinweise über das
Ownership-System.</p>
<p>Rust hat einen Fokus auf Sicherheit und Geschwindigkeit.
Es erfüllt diese Ziele durch viele &quot;kostenfreie Abstraktionen&quot;
[‘zero-cost abstractions’], was bedeutet, dass in Rust die Kosten so niedrig
wie möglich sind um diese Abstraktionen funktionieren zu lassen.
Jegliche Analyse über die wie in diesem Guide sprechen wird
<em>zur Kompilierzeit</em> ausgeführt. Du zahlst für diese Features
keine Extrakosten zur Laufzeit.</p>
<p>Jedoch hat dieses System einen gewissen Preis: Die Lernkurve.
Viele neue Rust Nutzer erleben etwas,
was wir &quot;mit dem <em>borrow checker</em> kämpfen&quot; nennen,
wobei dann Rust verweigert ein Programm zu kompilieren,
bei dem der Author denkt, dass es korrekt ist.
Das passiert häufig, da das mentale Modell des Programmierers von Ownership
nicht den eigentlichen Regeln entspricht, die Rust implementiert.
Du wirst wahrscheinlich zuerst etwas ähnliches erleben.
Die guten Nachricht ist aber:
Erfahrenere Rust Entwickler berichten, dass, sobald sie eine Zeit
mit den Regeln des Ownership-Systems gearbeitet haben, sie immer weniger
mit dem <em>borrow checker</em> kämpfen müssen.</p>
<p>Mit diesem Wissen, lass uns über Ausleihen lernen.</p>
<a class="header" href="print.html#ausleihen" id="ausleihen"><h1>Ausleihen</h1></a>
<p>Am ende des <a href="Besitz.html">Besitz</a> Abschnittes hatten wir eine üble Funktion,
die so aussah:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);

#}</code></pre></pre>
<p>Das ist jedoch kein übliches Rust,
da wir das &quot;Ausleihen&quot; [borrowing] nicht verwenden.
Hier ist unser erster Schritt:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // do stuff with v1 and v2

    // return the answer
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&amp;v1, &amp;v2);

// we can use v1 and v2 here!

#}</code></pre></pre>
<p>Anstatt der <code>Vec&lt;i32&gt;</code> verwenden wir Referenzen als Argument:
<code>&amp;Vec&lt;i32&gt;</code>. Und anstatt <code>v1</code> und <code>v2</code> übergeben wir <code>&amp;v1</code> und <code>&amp;v2</code>.
Wir nennen den <code>&amp;T</code> eine ‘Referenz’ und anstatt die Ressource zu besitzen,
leihen sie sich die Ressource aus.
Eine Bindung, die sich etwas ausleiht, gibt den Speicher der Ressource nicht
frei, wenn sie den Scope verlässt. Das bedeutet, dass wir nach dem Aufruf
<code>foo()</code> unsere ursprüngliche Bindung wieder verwenden könnne.</p>
<p>Referenzen sind unveränderbar [immutable], genauso wie Bindungen.
Das bedeutet, dass der Vektor innerhalb von <code>foo()</code> nicht verändert werden kann:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(v: &amp;Vec&lt;i32&gt;) {
     v.push(5);
}

let v = vec![];

foo(&amp;v);

#}</code></pre></pre>
<p>Dies erzeugt einen Fehler:</p>
<pre><code class="language-text">error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
</code></pre>
<p>Eine neue Variable am ende des Vektors anzufügen verändert den Vektor,
also dürfen wir das nicht machen.</p>
<a class="header" href="print.html#mut-referenzen" id="mut-referenzen"><h1>&amp;mut Referenzen</h1></a>
<p>Es gibt eine zweite Art von Referenz: <code>&amp;mut T</code>.
Eine veränderbare Referenz [mutable reference] erlaubt einem
die Ressource, die man ausleiht, zu verändern. Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
{
    let y = &amp;mut x;
    *y += 1;
}
println!(&quot;{}&quot;, x);

#}</code></pre></pre>
<p>Dies wird <code>6</code> ausgeben. Wir machen <code>y</code> zu einer veränderbaren Referenz auf
<code>x</code> und inkrementieren dann den Wert auf den <code>y</code> zeigt.
Du wirst bemerken, dass <code>x</code> ebenfalls als <code>mut</code> markiert werden musste.
Wenn es das nicht wäre, dann könnten wir keine veränderbare Referenz darauf
erzeugen.</p>
<p>Du wirst auch feststellen, dass wir ein Stern (<code>*</code>) vor dem <code>y</code> hinzugefügt
haben: <code>*y</code>. Das ist so, weil <code>y</code> eine <code>&amp;mut</code> Referenz ist.
Du wirst den Stern auch brauchen, wenn du auf den Inhalt einer normalen
Referenz zugreifen möchtest.</p>
<p>Ansonsten sind <code>&amp;mut</code> Referenzen genauso wie die gewöhnlichen Referenzen.
Es <em>gibt</em> jedoch einen großen Unterschied zwischen den beiden und wie sie
interagieren. Du kannst bereits an dem zusätzlichen Scope, den wir mit
<code>{</code> und <code>}</code> eingeführt haben, feststellen, dass etwas komisch ist.</p>
<p>Wenn wir sie entfernen, dann erhalten wir einen Fehler:</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &amp;mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Wie es sich herausstellt gibt es Regeln.</p>
<a class="header" href="print.html#die-regeln" id="die-regeln"><h1>Die Regeln</h1></a>
<p>Hier sind die Regeln die beim Ausleihen in Rust gelten:</p>
<p>Erstens darf etwas nicht länger ausgeliehen werden als das ausgeliehene
existiert. Zweitens du darfst entweder die eine oder die andere Art von
Referenz haben, aber nicht beide zur gleichen Zeit:</p>
<ul>
<li>eine oder mehr Referenzen (<code>&amp;T</code>) auf eine Ressource,</li>
<li>genau eine veränderbare Referenz (<code>&amp;mut T</code>).</li>
</ul>
<p>Du wirs feststellen, das dies sehr ähnlich (wenn auch nicht ganz exakt)
der Definition eines <em>data race</em> entspricht:</p>
<blockquote>
<p>There is a ‘data race’ when two or more pointers access the same memory
location at the same time, where at least one of them is writing, and the
operations are not synchronized.</p>
</blockquote>
<blockquote>
<p>Es gibt ein ‘data race’, wenn zwei oder mehr Zeiger zur selben Zeit
die gleiche Speicherstelle zugreifen, wobei mindestens ein Zugriff
schreibend erfolgt und die Operation nicht synchronisiert ist.</p>
</blockquote>
<p>Referenzen kann man so viele haben wie man möchte,
da keine von ihnen Schreibzugriffe erlaubt.
Wenn man schreibend zugreift, dann benötigt es zwei oder
mehr Zeiger auf die gleiche Speicherstelle um einen <em>data race</em> hervorzurufen,
aber Rust erlaubt es uns zu einem gewissen Zeitpunkt nur eine <code>&amp;mut</code> Referenz
zu haben.
So verhindert Rust <em>data races</em> zur Kompilierzeit:
Wir erhalten Fehler, wenn wir die Regeln brechen.</p>
<a class="header" href="print.html#in-scopes-denken" id="in-scopes-denken"><h2>In Scopes denken</h2></a>
<p>Hier ist der Code:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let y = &amp;mut x;

*y += 1;

println!(&quot;{}&quot;, x);

#}</code></pre></pre>
<p>Dieser Code gibt uns diesen Fehler:</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
</code></pre>
<p>Das kommt weil wir die Regeln verletzt haben:
Wir haben ein <code>&amp;mut T</code> welches auf <code>x</code> zeigt, weswegen wir
keine  <code>&amp;T</code>s erzeugen dürfen. Entweder nur das eine oder nur das andere.
Die <code>note:</code> Meldung gibt uns einen Hinweis
wie man über das Problem denken kann:</p>
<pre><code class="language-text">note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>In anderen Worten bleibt das <em>mutable borrow</em> bis zum Ende unseres
Beispiels bestehen. Was wir wollen ist, dass das <em>mutable borrow</em>
endet <em>bevor</em> wir versuchen <code>println!</code> aufzurufen und damit eine
ein <em>immutable borrow</em> vornehmen.
In Rust ist ein <em>borrow</em> an den Scope gebunden für den es gültig ist.
Und unser Scope sieht so aus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;

let y = &amp;mut x;    // -+ &amp;mut borrow of x starts here
                   //  |
*y += 1;           //  |
                   //  |
println!(&quot;{}&quot;, x); // -+ - try to borrow x here
                   // -+ &amp;mut borrow of x ends here

#}</code></pre></pre>
<p>Die Scopes stehen im Konflikt: Wir können kein <code>&amp;x</code> erzeugen, während <code>y</code>
im Scope ist.
Wenn wir also geschweifte Klammern hinzufügen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;

{                   
    let y = &amp;mut x; // -+ &amp;mut borrow starts here
    *y += 1;        //  |
}                   // -+ ... and ends here

println!(&quot;{}&quot;, x);  // &lt;- try to borrow x here

#}</code></pre></pre>
<p>Dann gibt es kein Problem. Unser <em>mutable borrow</em> verlässt den Scope bevor
wir ein <em>immutable borrow</em> erzeugen.
Der Scope ist der Schlüssel um zu sehen wie lange ein <em>borrow</em> anhält.</p>
<a class="header" href="print.html#probleme-die-das-ausleihen-verhindert" id="probleme-die-das-ausleihen-verhindert"><h2>Probleme die das Ausleihen verhindert</h2></a>
<p>Warum haben wir diese einschränkenden Regeln?
Nun, wie wir schon angemerkt haben, verhindern sie <em>data rces</em>.
Welche Arten von Problemen werden durch <em>data races</em> erzeugt?
Hier sind ein paar.</p>
<a class="header" href="print.html#iterator-invalidation" id="iterator-invalidation"><h3>Iterator invalidation</h3></a>
<p>Ein Beispiel ist ‘iterator invalidation’,
welche stattfindet, wenn man versucht eine Collection
zu verändern über die man iteriert. Rusts Borrow Checker verhindert,
dass das passiert:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
}

#}</code></pre></pre>
<p>Dies gibt eins bis drei aus. Während wir durch den Vektor iterieren
erhalten wir nur Referenzen auf die Elemente. Und <code>v</code> ist selber
nur unveränderbar ausgeliehen, was bedeutet, dass wir es nicht
verändern können, während wir darüber iterieren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
    v.push(34);
}

#}</code></pre></pre>
<p>Hier ist der Fehler:</p>
<pre><code class="language-text">error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &amp;v {
          ^
note: previous borrow ends here
for i in &amp;v {
    println!(“{}”, i);
    v.push(34);
}
^
</code></pre>
<p>Wir können <code>v</code> nicht verändern, da es von der Schleife ausgeliehen ist.</p>
<a class="header" href="print.html#benutzung-nach-einem-free" id="benutzung-nach-einem-free"><h3>Benutzung nach einem <code>free</code></h3></a>
<p>Referenzen dürfen nicht länger leben als die Ressource, die sie referenzieren.
Rust wird die Scopes deiner Referenzen überprüfen um sicherzustellen, dass
das gilt.</p>
<p>Wenn Rust diese Eigenschaft nicht prüfen würde, dann könnten wir
versehentlich eine ungültige Referenz verwenden.
Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let y: &amp;i32;
{ 
    let x = 5;
    y = &amp;x;
}

println!(&quot;{}&quot;, y);

#}</code></pre></pre>
<p>Wir erhalten diesen Fehler:</p>
<pre><code class="language-text">error: `x` does not live long enough
    y = &amp;x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &amp;i32;
{ 
    let x = 5;
    y = &amp;x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &amp;x;
}
</code></pre>
<p>In anderen Worten ist <code>y</code> nur für das Scope gültig, in dem <code>x</code> existiert.
Sobald <code>x</code> weggeht, ist es ungültig darauf zu verweisen.
Deswegen sagt der Fehler dass das <em>borrow</em> nicht lange genug lebt
[<code>does not live long enough</code>], da es nicht für die richtige Länge gültig ist.</p>
<p>Dasselbe Problem taucht auf, wenn eine Referenz vor der referenzierten Variable
deklariert wird:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let y: &amp;i32;
let x = 5;
y = &amp;x;

println!(&quot;{}&quot;, y);

#}</code></pre></pre>
<p>Wir erhalten diesen Fehler:</p>
<pre><code class="language-text">error: `x` does not live long enough
y = &amp;x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &amp;i32;
    let x = 5;
    y = &amp;x;
    
    println!(&quot;{}&quot;, y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &amp;x;
    
    println!(&quot;{}&quot;, y);
}
</code></pre>
<p>In dem oberen Beispiel wird <code>y</code> vor <code>x</code> deklariert, was bedeutet, dass <code>y</code>
länger lebt als <code>x</code>, was nicht erlaubt ist.</p>
<a class="header" href="print.html#lebensdauer" id="lebensdauer"><h1>Lebensdauer</h1></a>
<p>Dieser Guide ist einer von dreien, der Rusts Ownership-System.
präsentiert. Dies ist eines von Rusts einzigartigen und verlockenden
Features mit denen Rust Entwickler vertraut sein sollten.
Durch Ownership [engl.: Besitz] erreicht Rust sein größtes Ziel,
die Speichersicherheit.
Es gibt ein paar verschiedene Konzepte, jedes mit seinem eigenen Kapitel:</p>
<ul>
<li><a href="Besitz.html">Besitz</a>, das Schlüsselkonzept.</li>
<li><a href="Referenzen_Und_Ausleihen.html">Ausleihen</a>, und das assozierte Feature ‘Referenzen’</li>
<li>Lebensdauer, das was du gerade liest.</li>
</ul>
<p>Diese drei Kapitel sind verwandt und deswegen in dieser Reihenfolge zu lesen.
Du wirst alle drei benötigen um das Ownership-System vollständig zu verstehen.</p>
<a class="header" href="print.html#meta-2" id="meta-2"><h1>Meta</h1></a>
<p>Bevor wir in die Details gehen gibt es zwei wichtige Hinweise über das
Ownership-System.</p>
<p>Rust hat einen Fokus auf Sicherheit und Geschwindigkeit.
Es erfüllt diese Ziele durch viele &quot;kostenfreie Abstraktionen&quot;
[‘zero-cost abstractions’], was bedeutet, dass in Rust die Kosten so niedrig
wie möglich sind um diese Abstraktionen funktionieren zu lassen.
Jegliche Analyse über die wie in diesem Guide sprechen wird
<em>zur Kompilierzeit</em> ausgeführt. Du zahlst für diese Features
keine Extrakosten zur Laufzeit.</p>
<p>Jedoch hat dieses System einen gewissen Preis: Die Lernkurve.
Viele neue Rust Nutzer erleben etwas,
was wir &quot;mit dem <em>borrow checker</em> kämpfen&quot; nennen,
wobei dann Rust verweigert ein Programm zu kompilieren
bei dem der Author denkt, dass es korrekt ist.
Das passiert häufig, da das mentale Modell des Programmierers von Ownership
nicht den eigentlichen Regeln entspricht, die Rust implementiert.
Du wirst wahrscheinlich zuerst etwas ähnliches erleben.
Die guten Nachricht ist aber:
Erfahrenere Rust Entwickler berichten, dass, sobald sie eine Zeit
mit den Regeln des Ownership-Systems gearbeitet haben, sie immer weniger
mit dem <em>borrow checker</em> kämpfen müssen.</p>
<p>Mit diesem Wissen, lass uns über Lebensdauer lernen.</p>
<a class="header" href="print.html#lebensdauer-1" id="lebensdauer-1"><h1>Lebensdauer</h1></a>
<p>Eine Referenz auf eine Ressource, die jemand anderes besitzt, auszuleihen
kann kompliziert sein. Stell dir zum Beispiel diese Folge von
Vorgängen vor:</p>
<ul>
<li>Ich erhalte ein Handle für irgendeine Ressource.</li>
<li>Ich leihe dir eine Referenz zu dieser Ressource.</li>
<li>Ich entscheide mich, dass ich die Ressource nicht mehr brauch und
gebe sie frei, während du immernoch deine Referenz hast.</li>
<li>Du entscheidest dich die Ressource zu verwenden.</li>
</ul>
<p>Oh-oh! Deine Referenz zeigt auf eine ungültige Ressource.
Dies wird &quot;baumelnder Zeiger&quot; oder &quot;use after free&quot; genannt.</p>
<p>Um das zu beheben müssen wir sicherstellen, dass Schritt Drei nie nach
Schritt Vier passiert. Das Ownership-System in Rust macht dies durch ein
Konzept namens Lebensdauer [lifetimes], welches den Scope beschreibt
für den eine Referenz gültig ist.</p>
<p>Wenn wir eine Funktion haben, die eine Referenz als Argument nimmt,
dann ist die Lebenszeit dieser Referenz entweder implizit oder explizit:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// implicit
fn foo(x: &amp;i32) {
}

// explicit
fn bar&lt;'a&gt;(x: &amp;'a i32) {
}

#}</code></pre></pre>
<p>Das <code>'a</code> wird als &quot;die Lebenszeit a&quot; gelesen. Technisch gesehen hat jedee
Referenz eine zugehörige Lebenszeit, aber der Compiler erlaubt es diese in
üblichen Fällen wegzulassen.
Bevor wir jedoch darauf eingehen gehen wir noch das explizite Beispiel durch:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn bar&lt;'a&gt;(...)

#}</code></pre></pre>
<p>Dieser Teil deklariert unsere Lebenszeit. Er besagt, dass <code>bar</code> eine Lebenszeit
namens <code>'a</code> hat. Hätten wir zwei Referenz, dann würde das so aussehen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn bar&lt;'a, 'b&gt;(...)

#}</code></pre></pre>
<p>I unserer Parameterlist benutzen wir dann die benannten Lebenszeiten:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
...(x: &amp;'a i32)

#}</code></pre></pre>
<p>Wenn wir eine <code>&amp;mut</code> Referenz haben wollten,
dann würden wir folgendes schreiben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
...(x: &amp;'a mut i32)

#}</code></pre></pre>
<p>Wenn du <code>&amp;mut i32</code> und <code>&amp;'a mut i32</code> miteinander vergleichst,
dann siehst du, dass sie eigentlich identisch sind, bis auf den Unterschied,
dass sich ein <code>'a</code> zwischen dem <code>&amp;</code> und dem <code>mut i32</code> eingeschlichen hat.
Wir lesen <code>&amp;mut i32</code> als &quot;eine veränderbare Referenz auf ein i32&quot; und
<code>&amp;'a mut i32</code> als &quot;eine veränderbare Referenz auf ein i32
mit der Lebenszeit <code>'a</code>&quot;.</p>
<a class="header" href="print.html#in-structs" id="in-structs"><h1>In <code>struct</code>s</h1></a>
<p>Du wirst auch explizite Lebenszeiten brauchen,
wenn du mit <a href="Structs.html"><code>struct</code></a>s arbeitest:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;{}&quot;, f.x);
}
</code></pre></pre>
<p>Wie du sehen kannst können <code>struct</code>s auch Lebenszeiten haben.
Auf eine ähnliche Art und Weise wie Funktionen deklariert</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Foo&lt;'a&gt; {

#}</code></pre></pre>
<p>eine Lebenszeit und</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
x: &amp;'a i32,

#}</code></pre></pre>
<p>benutzt sie. Also warum brauchen wir eine Lebenszeit hier?
Wir müssen sicherstellen, dass keine Referenz auf <code>Foo</code> länger lebt,
als die enthaltene Referenz auf das <code>i32</code>.</p>
<a class="header" href="print.html#impl-blöcke" id="impl-blöcke"><h2><code>impl</code> Blöcke</h2></a>
<p>Lass uns eine Methode auf dem Typen <code>Foo</code> implementieren:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x(&amp;self) -&gt; &amp;'a i32 { self.x }
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;x is: {}&quot;, f.x());
}
</code></pre></pre>
<p>Wie du sehen kannst müssen wir eine Lebensdauer für <code>Foo</code> in der <code>impl</code> Zeile
deklarieren. Wir wiederholen <code>'a</code> zweimal, genau wie bei Funktionen: <code>impl&lt;'a&gt;</code>
deklariert eine Lebensdauer <code>'a</code> und <code>Foo&lt;'a&gt;</code> benutzt sie.</p>
<a class="header" href="print.html#mehr-als-eine-lebensdauer" id="mehr-als-eine-lebensdauer"><h2>Mehr als eine Lebensdauer</h2></a>
<p>Wenn du mehrere Referenzen hast, dann kannst du die gleiche Lebensdauer mehrmals
verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn x_or_y&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {

#}</code></pre></pre>
<p>Dieser code besagt, dass <code>x</code>, <code>y</code> und
der Rückgabewert die gleiche Lebenszeit haben.
Wenn du wolltest, dass <code>x</code> und <code>y</code> verschiedene Lebenszeiten haben,
dann kannst du mehrere Lebenszeit-Parameter verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn x_or_y&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {

#}</code></pre></pre>
<p>In diesem Beispiel haben <code>x</code> und <code>y</code> also verschiedene gültige Scopes,
aber der Rückgabewert hat dieselbe Lebenszeit wie <code>x</code>.</p>
<a class="header" href="print.html#in-scopes-denken-1" id="in-scopes-denken-1"><h2>In Scopes denken</h2></a>
<p>Ein Weg über Lebenszeiten zu nachzudenken ist den Scope, indem eine Referenz
gültig ist, zu visualisieren. Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = &amp;5;     // -+ y goes into scope
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ y goes out of scope
</code></pre></pre>
<p>Mit unserem <code>Foo</code> hinzugefügt:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5;           // -+ y goes into scope
    let f = Foo { x: y }; // -+ f goes into scope
    // stuff              //  |
                          //  |
}                         // -+ f and y go out of scope
</code></pre></pre>
<p>Unser <code>f</code> lebt im Scope von <code>y</code>, also funktioniert alles.
Aber was wenn nicht? Dieser Code Funktioniert nicht:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let x;                    // -+ x goes into scope
                              //  |
    {                         //  |
        let y = &amp;5;           // ---+ y goes into scope
        let f = Foo { x: y }; // ---+ f goes into scope
        x = &amp;f.x;             //  | | error here
    }                         // ---+ f and y go out of scope
                              //  |
    println!(&quot;{}&quot;, x);        //  |
}                             // -+ x goes out of scope
</code></pre></pre>
<p>Uff! Wie du hier siehst ist der Scope von <code>f</code> und <code>y</code> kleiner als der von <code>x</code>.
Aber wenn wir <code>x = &amp;f.x</code> ausführen, erzeugen wir eine Referenz auf etwas, was
kurz davor steht den Scope zu verlassen.</p>
<a class="header" href="print.html#static" id="static"><h2>'static</h2></a>
<p>Die Lebenszeit namens ‘static’ ist eine besondere Lebenszeit. Sie signalisiert,
dass etwas dieselbe Lebenszeit wie das ganze Programm hat.
Die meisten Rust Programmierer treffen das erste mal auf <code>'static</code>,
wenn sie mit Strings arbeiten:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x: &amp;'static str = &quot;Hello, world.&quot;;

#}</code></pre></pre>
<p>Stringliterale haben den Typ <code>&amp;'static str</code>, da die Referenz immer gültig ist:
Sie sind in das Datensegment der Binärdatei integriert.
Ein anderes Beispiel sind <em>globals</em> (globale Variablen):</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
static FOO: i32 = 5;
let x: &amp;'static i32 = &amp;FOO;

#}</code></pre></pre>
<p>Dies fügt dem Datensegment der Binärdatei eine <code>i32</code> hinzu und <code>x</code> ist eine
Referenz darauf.</p>
<a class="header" href="print.html#weglassen-von-lebenszeiten" id="weglassen-von-lebenszeiten"><h2>Weglassen von Lebenszeiten</h2></a>
<p>Rust unterstützt mächtige lokale Typinferenz in Funktionskörpern, aber es ist
verboten in Signaturen aus der jeweiligen Signatur allein Sachen abzuleiten.
Es gibt jedoch aus ergonomischen Gründen eine sehr Eingeschränkte Form von
Inferenz namens <em>lifetime elision</em> (&quot;Weglassen von Lebenszeiten&quot;), welche
das erlaubt. Sie leitet ausschließlich basierend aus der Signatur einer
Komponente (also nicht dem Körper) etwas ab und zwar nur Lebenszeit-Parameter.
Außerdem geschieht <em>lifetime elision</em> gemäß nur drei einfahc zu merkenden und
deutlichen Regeln. Dies erlaubt der <em>lifetime elision</em> eine Kurzschreibweise
für Signaturen zu ermöglichen und gleichzeitig nicht die eigentlichen
involvierten Typen zu verstecken, wie es eine vollständig Inferenz machen würde.</p>
<p>Wenn wir über <em>lifetime elision</em> reden, dann benutzen wir den Begriff
<em>input lifetime</em> und <em>output lifetime</em>. Eine <em>input lifetime</em> ist eine
Lebenszeit, die mit einem Parameter einer Funktion assoziiert ist,
und eine <em>output lifetime</em> ist eine Lebenszeit, die mit dem Rückgabewert einer
Funktion assoziiert ist. Zum Beispiel hat diese Funktion eine <em>input lifetime</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a&gt;(bar: &amp;'a str)

#}</code></pre></pre>
<p>Diese hier hat eine <em>output lifetime</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a&gt;() -&gt; &amp;'a str

#}</code></pre></pre>
<p>Und diese hier hat eine Lebenszeit in beiden Positionen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a&gt;(bar: &amp;'a str) -&gt; &amp;'a str

#}</code></pre></pre>
<p>Hier sind die drei Regeln:</p>
<ul>
<li>
<p>Jede weggelassene Lebenszeit bei den Argumenten einer Funktion bekommt einen
individuellen Lebenszeit-Paramter.</p>
</li>
<li>
<p>Wenn es genau eine <em>input lifetime</em> gibt, ob weggelassen oder nicht,
dann wird diese Lebenszeit aller ausgelassenen Lebenszeiten im Rückgabewert
der Funktion zugewiesen.</p>
</li>
<li>
<p>Wenn es mehrere <em>input lifetime</em> gibt und eines der Argumente <code>&amp;self</code>,
<code>&amp;mut self</code> oder <code>self</code> ist, dann wird die Lebenszeit von <code>self</code>
allen weggelassenen <em>output lifetimes</em> zugewiesen.</p>
</li>
</ul>
<p>Andernfalls ist es einen Fehler eine Lebenszeit wegzulassen.</p>
<a class="header" href="print.html#beispiele" id="beispiele"><h3>Beispiele</h3></a>
<p>Hier sind ein paar Beispiel-Funktionen mit weggelassenen Lebenszeiten.
Wir haben jedes Beispiel einer ausgelassenen Lebenszeit mit ihrer
expandierten Form gepaart.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn print(s: &amp;str); // elided
fn print&lt;'a&gt;(s: &amp;'a str); // expanded

fn debug(lvl: u32, s: &amp;str); // elided
fn debug&lt;'a&gt;(lvl: u32, s: &amp;'a str); // expanded

// In dem vorangehenden Beispiel benötigt `lvl` keine eigene Lebenszeit,
// da es keine Referenz (`&amp;`) ist. Nur Sachen, die mit Referenzen zu tun haben
// (wie z.B. `struct`s, die Referenzen enthalten) benötigen Lebenszeiten.

fn substr(s: &amp;str, until: u32) -&gt; &amp;str; // elided
fn substr&lt;'a&gt;(s: &amp;'a str, until: u32) -&gt; &amp;'a str; // expanded

fn get_str() -&gt; &amp;str; // ILLEGAL, no inputs

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str; // ILLEGAL, two inputs
fn frob&lt;'a, 'b&gt;(s: &amp;'a str, t: &amp;'b str) -&gt; &amp;str; // Expanded: Output lifetime is ambiguous

fn get_mut(&amp;mut self) -&gt; &amp;mut T; // elided
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T; // expanded

fn args&lt;T:ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command // elided
fn args&lt;'a, 'b, T:ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command // expanded

fn new(buf: &amp;mut [u8]) -&gt; BufWriter; // elided
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt; // expanded

#}</code></pre></pre>
<a class="header" href="print.html#veränderbarkeit" id="veränderbarkeit"><h1>Veränderbarkeit</h1></a>
<!-- Mutability, the ability to change something, works a bit differently in Rust
than in other languages. The first aspect of mutability is its non-default
status: -->
Veränderbarkeit, die Möglichkeit etwas zu ändern, funktioniert in Rust ein wenig anders als in anderen Programmiersprachen.
Standardmäßig sind Variablen nicht veränderbar: 
<!-- XXX rust,ignore wird bei meinem gitbook nicht erkannt und Syntaxhighlighting ist aus -->
```rust,ignore
let x = 5;
x = 6; // Fehler!
```
<!-- We can introduce mutability with the `mut` keyword: -->
Wir können Veränderbarkeit mit dem Schlüsselwort `mut`, die Kurzform für "mutable" (englisch: veränderbar), einführen:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;

x = 6; // Kein Problem!

#}</code></pre></pre>
<!-- This is a mutable [variable binding][vb]. When a binding is mutable, it means
you’re allowed to change what the binding points to. So in the above example,
it’s not so much that the value at `x` is changing, but that the binding
changed from one `i32` to another. -->
Dies ist eine veränderbare [Variablenbindung][v].
Wenn eine Bindung veränderbar ist, bedeutet es,
 dass du ändern kannst woran die Variablenbindung gebunden ist.
In dem oberen Beispiel ist es nicht so, dass sich der Wert in `x` ändert,
 sondern dass sich die Bindung von `x` von einem `i32` zu einem Anderen geändert hat.
<!-- You can also create a [reference][ref] to it, using `&x`, but if you want to use the reference to change it, you will need a mutable reference: -->
Du kannst auch eine [Referenz][ref] zu einer Variablenbindung mittels `&x` erstellen.
Wenn du aber die Referenz benutzen möchtest um die Variablenbindung zu ändern,
 benötigst du eine *veränderbare* Referenz: <!-- *Hervorhebung* hinzugefügt -->
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let y = &amp;mut x;

#}</code></pre></pre>
<!-- `y` is an immutable binding to a mutable reference,
  which means that you can’t bind 'y' to something else (`y = &mut z`),
  but `y` can be used to bind `x` to something else (`*y = 5`). A subtle distinction. -->
`y` ist eine unveränderbare Variablenbindung zu einer veränderbaren Referenz.
Das bedeutet, dass du `y` nicht zu etwas anderem binden kannst, z.B. `y = &mut z`.
Du kannst aber `y` benutzen um `x` an etwas anders zu binden, z.B. durch `*y = 5`.
Ein subtiler Unterschied.
<!-- Of course, if you need both: -->
Wenn du beides brauchst:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let mut y = &amp;mut x;

#}</code></pre></pre>
<!-- Now `y` can be bound to another value, and the value it’s referencing can be
changed. -->
Jetzt kann `y` an einen anderen Wert gebunden werden und der Wert der referenziert wird,
 kann geändert werden.
<!-- It’s important to note that `mut` is part of a [pattern][pattern], so you
can do things like this: -->
Es ist wichtig hervorzuheben, dass `mut` Teil eines [`Musters`][pattern] ist,
 so dass du zu soetwas binden kannst:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let (mut x, y) = (5, 6);

fn foo(mut x: i32) {
}

#}</code></pre></pre>
<!-- hier war ein Fehler in dem Book 1.3.0 durch ein # im Code -->
<!-- Note that here, the `x` is mutable, but not the `y`. -->
In dem Beispiel ist `x` veränderbar aber nicht `y`.
<!-- # Interior vs. Exterior Mutability -->
# Innere und äußere Veränderbarkeit
<!-- However, when we say something is ‘immutable’ in Rust, that doesn’t mean that
it’s not able to be changed: we are referring to its ‘exterior mutability’ that
in this case is immutable. Consider, for example, [`Arc<T>`][arc]: -->
Doch wenn wir sagen, etwas ist "unveränderlich" in Rust,
 dann bedeutet das nicht, dass es sich nicht ändern kann:
 wir meinen damit, dass dessen "äußere Veränderbarkeit" unveränderlich ist.
Betrachte als Beispiel [`Arc<T>`][arc]:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::sync::Arc;

let x = Arc::new(5);
let y = x.clone();

#}</code></pre></pre>
<!-- When we call `clone()`, the `Arc<T>` needs to update the reference count. Yet
we’ve not used any `mut`s here, `x` is an immutable binding, and we didn’t take
`&mut 5` or anything. So what gives? -->
Wenn wir `clone()` aufrufen, muss das `Arc<T>` seinen Referenzzähler aktualisieren.
Jedoch haben wir kein `mut` verwendet,
 `x` ist eine unveränderliche Variablenbindung,
 und wir haben nicht `&mut 5` oder soetwas benutzt.
Nun, was passiert hier?
<!-- To understand this, we have to go back to the core of Rust’s guiding
philosophy, memory safety, and the mechanism by which Rust guarantees it, the
[ownership][ownership] system, and more specifically, [borrowing][borrowing]: -->
Um das zu verstehen, müssen wir zurück zu den Kernprinzipien von Rust,
 Speichersicherheit und der Mechanismus, mit dem dies garantiert wird,
 [Besitz][ownership] und [Ausleihe][borrowing].
<!--
> You may have one or the other of these two kinds of borrows, but not both at
> the same time:
>
> * one or more references (`&T`) to a resource,
> * exactly one mutable reference (`&mut T`).
-->
> Du hast entweder die eine oder die andere Art Ausleihe, aber nicht beide gleichzeitig:
>
> * eine oder mehrere Referenzen (`&T`) zu einer Resource,
> * exakt eine veränderbare Referenz (`&mut T`).
<!-- So, that’s the real definition of ‘immutability’: is this safe to have two
pointers to? In `Arc<T>`’s case, yes: the mutation is entirely contained inside
the structure itself. It’s not user facing. For this reason, it hands out `&T`
with `clone()`. If it handed out `&mut T`s, though, that would be a problem. -->
Nun, dies ist die wirkliche Definition von "Unveränderbarkeit".
Ist es sicher zwei Referenzen zu Etwas zu haben?
Im Falle von `Arc<T>` ist es sicher.
Die Veränderung ist gekapselt im der Struktur selbst.
Sie ist nicht nach Außen sichtbar.
Aus diesem Grund wird `&T` durch `clone()` zurück gegeben.
Wenn es `&mut T` zurück geben würde, wäre das ein Problem.
<!-- XXX der englische Text selbst ist mit
     '...: is this safe to have two pointers to? ... yes: ...`
     sehr holprig und unklar was gemeint ist.
     Ich habe das mal angepasst. -->
<!-- Other types, like the ones in the [`std::cell`][stdcell] module, have the
opposite: interior mutability. For example: -->
Andere Typen, wie die in dem [`std::cell`][stdcell] Modul,
 haben hingegen innere Veränderbarkeit:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();

#}</code></pre></pre>
<!-- RefCell hands out `&mut` references to what’s inside of it with the
`borrow_mut()` method. Isn’t that dangerous? What if we do: -->
`RefCell` gibt über die Methode `borrow_mut()`
 eine `&mut` Referenz zu der inneren Bindung <!-- XXX Bindung oder Wert? -->
 zurück.
Ist das nicht gefährlich? Was ist, wenn wir folgendes tun:
<pre><code class="language-rust ignore">use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
let z = x.borrow_mut();
# (y, z);
</code></pre>
<!-- XXX warum ist hier ein # (y, z); ? Im book ist diese Zeile nicht mit einkompiliert. -->
<!-- This will in fact panic, at runtime. This is what `RefCell` does: it enforces
Rust’s borrowing rules at runtime, and `panic!`s if they’re violated. This
allows us to get around another aspect of Rust’s mutability rules. Let’s talk
about it first. -->
Dies löst durchaus eine `panic` zur Laufzeit aus.
Das ist, was `RefCell` macht:
 es setzt Rusts Regeln zum Ausleihen zur Laufzeit durch
 und `panic!`t wenn sie gebrochen werden.
Das erlaubt es uns mit einem weiteren Aspekt von Rusts Regeln zur Veränderbarkeit
 umzuhehen.
Lass uns aber ersteinmal über diesen Aspekt sprechen.
<!-- ## Field-level mutability -->
## Veränderbarkeit bei Feldern
<!-- Mutability is a property of either a borrow (`&mut`) or a binding (`let mut`).
This means that, for example, you cannot have a [`struct`][struct] with
some fields mutable and some immutable: -->
Veränderbarkeit ist eine Eigenschaft einer Ausleihe (`&mut`)
 oder einer Variablenbindung (`let mut`).
Das bedeutet zum Beispiel, dass du kein [Struct][struct]
 mit einigen veränderbaren und einigen unveränderbaren Feldern haben kannst:
<pre><code class="language-rust ignore">struct Point {
      x: i32,
      mut y: i32, // das geht nicht
}
</code></pre>
<!-- The mutability of a struct is in its binding: -->
Die Veränderbarkeit eines Struct ist in ihrer Bindung:
<pre><code class="language-rust ignore">struct Point {
      x: i32,
      y: i32,
}

let mut a = Point { x: 5, y: 6 };

a.x = 10;

let b = Point { x: 5, y: 6};

b.x = 10; // error: cannot assign to immutable field `b.x`
</code></pre>
<!-- However, by using [`Cell<T>`][cell], you can emulate field-level mutability: -->
Jedoch kann man mit Hilfe von [`Cell<T>`][cell] Veränderbarkeit pro Feld nachbilden:
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::cell::Cell;

struct Point {
      x: i32,
      y: Cell&lt;i32&gt;,
}

let point = Point { x: 5, y: Cell::new(6) };

point.y.set(7);

println!(&quot;y: {:?}&quot;, point.y);

#}</code></pre></pre>
<!-- This will print `y: Cell { value: 7 }`. We’ve successfully updated `y`. -->
Dies gibt `y: Cell { value: 7 }` aus.
Wir haben `y` erfolgreich verändert.
<a class="header" href="print.html#structs" id="structs"><h1>Structs</h1></a>
<p>Mithilfe von <em>Structs</em> ist es möglich komplexere Datentypen zu erstellen.
Als Beispiel betrachten wir einen Gegenstand in einem 2D Raum. Um seine Position zu beschrieben,
sind die zwei Koordinaten <code>x</code> und <code>y</code> von Nöten.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x_position = 0;
let y_position = 0;

#}</code></pre></pre>
<p>Allerdings sind zwei eigene Variablen für die beiden Koordinaten nicht gerade praktisch im Handling.
Mit einem <em>Struct</em> können beide Werte in einem Datentyp zusammengefasst werden.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Position {
    x: i32,
    y: i32,
}

#}</code></pre></pre>
<p>Dieses <em>Struct</em> umfasst nun die beiden Variablen <code>x</code> und <code>y</code> vom Typen <code>i32</code>.
Das Schlüsselwort <code>struct</code> leitet die Deklaration eines <em>Structs</em> ein. Der Konvention folgend,
beginnt der Bezeichner eines <em>Structs</em> mit einem Großbuchstaben. Auch werden die Worte von Bezeichnern mit mehreren Worten zusammengezogen und nicht mit Unterstrichen (_) getrennt. Dabei beginnt jedes Wort mit einem Großbuchstaben.
Beispiele:
<code>struct PositionInSpace</code> : korrekt
<code>struct Position_in_Space</code>: nach der Konvention nicht korrekt
<code>struct PositioninSpace</code> : nach der Konvention nicht korrekt</p>
<p>Ein <em>Struct</em> zu initialisieren und auf seine Inhalte zuzugreifen ist nicht weiter problematisch.</p>
<pre><pre class="playpen"><code class="language-rust">struct Position {
    x: i32,
    y: i32,
}

fn main() {
    let start = Position { x: 0, y: 0.5 };

    println!(&quot;The start of Race is at ({},{})&quot;, start.x, start.y);
}
</code></pre></pre>
<p>Wie gewohnt wird mit <code>let</code> die Instanz des <em>Structs</em> erzeugt. Die einzelnen Felder des <em>Structs</em> werden mit der <code>key: value</code> Syntax gesetzt.
Dabei ist es nicht relevant, in welcher Reihenfolge die Felder gesetzt werden.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let start = Position { x: 0, y: 0.5 };
let start = Position { y: 0.5, x: 0 }; 

#}</code></pre></pre>
<p>Beide Aufrufe sind korrekt und füllen die Felder mit den ihnen zugewiesenen Werten.
Da auch die Felder innerhalb eines <em>Structs</em> Bezeichner tragen, ist es möglich diese über <code>Structbezeichner.Feldbezeichner</code> anzusprechen.</p>
<p>Standardmäßig sind die Felder innerhalb eines <em>Structs</em> schreibgeschützt. Aber wie bei anderen Bindungen in Rust,
kann auch bei <em>Structs</em> das Schlüsselwort <code>mut</code> die Felder als beschreibbar markieren.</p>
<pre><pre class="playpen"><code class="language-rust">struct Position {
    x: i32,
    y: i32,
}

fn main() {

    let mut start = Position { x: 0, y: 0.5 };
    let end = Position { x: 0.5, y: 0 };

    start.x = 10;   // Dies ist korrekt da start 
                //als beschreibbar gekennzeichnet ist.
    end.x = 1;  // Dies wird einen Fehler erzeugen 
                //da end schreibgeschützt ist.
}
</code></pre></pre>
<p>Innerhalb des <em>Structs</em> ist es nicht möglich die definierten Felder/Variablen als beschreibbar zu setzen.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
strcut Position {
    mut x: i32,  // Das ist nicht möglich!
    y: i32,
}

#}</code></pre></pre>
<p>Dieser Umstand ist darin begründet, dass beschreibbar und unbeschreibbar Eigenschaften von Bindungen und nicht der Variablen und Werte an sich selbst sind. Jedoch ist es möglich die Felder des <em>Structs</em> nur für eine kurze Zeit als beschreibbar zu kennzeichnen.</p>
<pre><pre class="playpen"><code class="language-rust">struct Position {
    x: i32,
    y: i32,
}

fn main() {

    let mut start = Position { x: 0 , y: 0.5 };
    
    start.x = 10; // Hier ist eine Zuweisung noch möglich.
    
    let start = start;
    
    start.x = 0 ; // Diese Zuweisung wirft einen Fehler.
}
</code></pre></pre>
<a class="header" href="print.html#updating-syntax" id="updating-syntax"><h2>Updating Syntax</h2></a>
<p>Es gibt eine weitere Möglichkeit die Felder eines <em>Structs</em> zu modifizieren. Mit <code>..</code> kann Rust darüber informiert werden, das eine Kopie von Werten eines anderen <em>Structs</em> übernommen werden sollen.</p>
<pre><pre class="playpen"><code class="language-rust">struct Position {
    x: i32,
    y: i32,
    z: i32,
}

fn main() {

    let mut start = Position { x: 0 , y: 0.5, z: 1 };
    start = Position { y : 2, .. start }
}
</code></pre></pre>
<p>Durch die Zuweisung erhält <code>start</code> einen neuen <code>y</code> Wert. Alle anderen Werte werden aus der alten Wertebelegung von <code>start</code> kopiert bevor <code>start</code> überschrieben wird. Dabei ist es möglich die Syntax nicht nur auf dasselbe <em>Struct</em> anzuwenden, aus dem auch gelesen wird. Es besteht auch die Möglichkeit eine neues <em>Struct</em> damit zu initialisieren.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

    let start = Position {x: 0, y: 0.5, z: 1};
    let example_1 = Position {z: 3, y: 2, .. start }; 
    // Wie bereits erwähnt, kommt es bei dieser 
    //Schreibweise nicht auf die Reihenfolge
    //der Variablen an. 
    //Nur die spezielle Updatesyntax muss am Ende stehen. 
}
</code></pre></pre>
<a class="header" href="print.html#tuple---structs" id="tuple---structs"><h2>Tuple - Structs</h2></a>
<p>In Rust existiert ein Datentyp, der einer Art Hybrid aus einem <em>Struct</em> und aus einem [Tuple][tupel] bildet. Doch ist es empfohlen auf den normalen <em>Struct</em> - Datentyp zurückzugreifen.
[tupel]: Primitive_Typen.html#tupel</p>
<pre><pre class="playpen"><code class="language-rust">struct Color (i32, i32, i32)
struct Position (i32, i32, i32) 

fn main(){
    let black = Color(0, 0, 0);
    let start = Position (0, 0, 0);
    // Diese beiden Belgungen sind nicht identisch,
    //auch wenn es sich um die selben Werte
    //innerhalb der Strucs handelt.
}
</code></pre></pre>
<p>Die <em>Structs</em> weisen einen Bezeichner auf. Color oder Position.
Die Werte innerhalb der <em>Structs</em> haben allerdings keine Bezeichnungen.
Daher ist es besser die <em>Tuple - Structs</em> in die Syntax normaler <em>Structs</em> zu überführen.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Color {
    red: i32,
    blue: i32,
    green: i32,
}

struct Position {
    x: i32,
    y: i32,
    z: i32,
}


#}</code></pre></pre>
<p>Es gibt einen Fall, in dem es sinnvoll ist ein <em>Tuple - Struct</em> zu verwenden.
Es handelt sich um das Entwicklungsmuster (engl.: pattern) <em>newtype</em>. Dieses Muster erlaubt es einen neuen Typen zu erschaffen, welcher verschieden zu dem Typ des Wertes ist, welchen er beinhaltet.</p>
<pre><pre class="playpen"><code class="language-rust">struct Meter(i32); 

fn main() {
    let meter = Meter(10); 
    let Meter(value) = meter;
    println!(&quot;value is {} meter&quot;, value);
}

</code></pre></pre>
<p>Die Variable <code>meter</code> ist vom Typen <code>Meter</code>. Um an den Inhalt, also den Wert des Datentypen innerhalb von Meter heran zu kommen, kann das [<em>Patternmatching</em>][muster] verwendet werden.
<code>value</code> ist vom primitiven Typen <code>i32</code>. Auch ist es eine copy des Wertes in Meter und nicht eine Referenz.
[muster]: Muster.html</p>
<a class="header" href="print.html#einheitstyp-engl-unit-like-structs" id="einheitstyp-engl-unit-like-structs"><h2>Einheitstyp (engl.: unit-like structs)</h2></a>
<p>Es kann ein <em>Struct</em> definiert werden, welches keinen Inhalt aufweist.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Unicorn;

#}</code></pre></pre>
<p>Solch ein <em>Struct</em> wird als Einheit (engl.: unit-like) betrachtet. Es ähnelt stark dem leeren [Tuple][tupel]. Wie ein <em>Tuple - Struct</em> definiert dieser Einheitstyp einen neuen Typen.
Der Einheitstyp ist für sich selbst genommen bereits sehr nützlich. Er kann beispielsweise als Markierung verwendet werden. In der Kombination mit anderen Funktionen entfaltet der Einheitstyp seine volles Potenzial. Wenn das Interesse nicht an den Werten besteht sondern nur an dem Typen beispielsweise. Ein Interface erwartet, ein <em>Struct</em> welches verschiedene <code>trait</code>s implementiert, um Ereignisse (engl.: Event) zu behandeln.</p>
<a class="header" href="print.html#enums" id="enums"><h1>Enums</h1></a>
<a class="header" href="print.html#match" id="match"><h1>Match</h1></a>
<a class="header" href="print.html#muster" id="muster"><h1>Muster</h1></a>
<a class="header" href="print.html#methodensyntax" id="methodensyntax"><h1>Methodensyntax</h1></a>
<a class="header" href="print.html#vektoren" id="vektoren"><h1>Vektoren</h1></a>
<a class="header" href="print.html#strings" id="strings"><h1>Strings</h1></a>
<a class="header" href="print.html#generics" id="generics"><h1>Generics</h1></a>
<a class="header" href="print.html#traits" id="traits"><h1>Traits</h1></a>
<p>Ein Trait ist ein Sprachkonstrukt in Rust, welches dem Kompiler sagt welche Funktionalität ein Typ implementiert.</p>
<p>Kannst du dich noch an das Keyword <code>impl</code> erinnern, mit dem man <a href="Methoden-Syntax.html">Methoden</a> zu einem Typ implementiert?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

#}</code></pre></pre>
<p>Traits sind ähnlich, nur dass wir hier nur die Signaturen der Methoden angeben und dann erst später implementieren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

#}</code></pre></pre>
<p>Wie man hier erkennt, sieht der <code>trait</code> Block fast genau so aus wie der <code>impl</code> Block,
aber wir definieren den Körper der Funktionen nicht, nur deren Signatur.
Wenn wir dann mit <code>impl</code> einen Trait implementieren schreiben wir <code>imple Trait for Item</code> anstatt nur <code>impl Item</code>.</p>
<a class="header" href="print.html#trait-schranken-für-generische-funktionen" id="trait-schranken-für-generische-funktionen"><h2>Trait-Schranken für generische Funktionen</h2></a>
<p>Traits sind sehr nützlich, denn sie erlauben es uns bestimmte Zusagen über das Verhalten von Typen zu machen.
Generische Funktionen können somit Voraussetzungen für Typen die sie annehmen einfordern.
Nehmen wir mal folgendes Beispiel an:</p>
<pre><code class="language-rust ignore">fn print_area&lt;T&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
</code></pre>
<p>Rust beschwert sich jetzt:</p>
<pre><code class="language-text">error: no method named `area` found for type `T` in the current scope
</code></pre>
<p>Weil <code>T</code> jeder Typ sein könnte, können wir nicht sicher sein dass <code>area</code> auch wirklich eine implementierte Methode ist.
Aber wir können eine &quot;Trait-Schranke&quot; zu unserem Generischen <code>T</code> hinzufügen, um das sicher zu stellen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# trait HasArea {
#     fn area(&amp;self) -&gt; f64;
# }
fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}

#}</code></pre></pre>
<p>Die Syntax <code>&lt;T: HasArea&gt;</code> bedeutet &quot;jeder Typ der das Trait <code>HasArea</code> implementiert&quot;.
Weil Traits Funktionssignaturen definieren können wir sicher sein, dass jeder Typ der <code>HasArea</code> implementiert auch die Methode <code>.area()</code> haben wird.</p>
<p>Hier ist ein erweitertes Beispiel wie das geht:</p>
<pre><pre class="playpen"><code class="language-rust">trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}

fn main() {
    let c = Circle {
        x: 0.0f64,
        y: 0.0f64,
        radius: 1.0f64,
    };

    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 1.0f64,
    };

    print_area(c);
    print_area(s);
}
</code></pre></pre>
<p>Das gibt aus</p>
<pre><code class="language-text">This shape has an area of 3.141593
This shape has an area of 1
</code></pre>
<p>Wie du siehst ist <code>print_area</code> jetzt generisch, aber stellt außerdem Sicher, dass es die korrekten Typen annimmt.
Wenn wir falsche Typen übergeben:</p>
<pre><code class="language-rust ignore">print_area(5);
</code></pre>
<p>Bekommen wir einen Kompilerfehler:</p>
<pre><code class="language-text">error: the trait `HasArea` is not implemented for the type `_` [E0277]
</code></pre>
<a class="header" href="print.html#trait-schranken-für-generische-structs" id="trait-schranken-für-generische-structs"><h2>Trait-Schranken für generische Structs</h2></a>
<p>Deine generischen Structs können auch von Trait-Schranken profitieren.
Alles was du machen musst ist die Schranke an deinen Typparameter anhängen.
Hier ist ein neues <code>Rectangle&lt;T&gt;</code> und seine Methode <code>is_square()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle&lt;T&gt; {
    x: T,
    y: T,
    width: T,
    height: T,
}

impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; {
    fn is_square(&amp;self) -&gt; bool {
        self.width == self.height
    }
}

fn main() {
    let mut r = Rectangle {
        x: 0,
        y: 0,
        width: 47,
        height: 47,
    };

    assert!(r.is_square());

    r.height = 42;
    assert!(!r.is_square());
}
</code></pre></pre>
<p><code>is_square()</code> muss checken das die Seiten gleich sind, also müssen die Seiten einen Typen haben der <a href="http://doc.rust-lang.org/stable/std/cmp/trait.PartialEq.html"><code>core::cmp::PartialEq</code></a> implementiert:</p>
<pre><code class="language-ignore">impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; { ... }
</code></pre>
<p>Hier haben wir also ein Struct <code>Rectangle</code> definiert, das alle Typen als Höhe und Breite akzeptiert die sich auf Gleichheit vergleichen lassen.
Geht das auch mit <code>HasArea</code> Structs, wie <code>Square</code> und <code>Circle</code>?
Ja, aber sie benötigen Multiplikation, dafür müssen wir wissen wie man mittels <a href="operators-and-overloading.html">Operatoren-Traits</a> Operatoren überlädt.</p>
<a class="header" href="print.html#regeln-für-trait-implementierung" id="regeln-für-trait-implementierung"><h1>Regeln für Trait Implementierung</h1></a>
<p>Bis lang haben wir nur Traits für Structs implementiert, aber das geht auch für andere Typen.
Theoretisch könnten wir auch <code>HasArea</code> für <code>i32</code> implementieren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for i32 {
    fn area(&amp;self) -&gt; f64 {
        println!(&quot;this is silly&quot;);

        *self as f64
    }
}

5.area();

#}</code></pre></pre>
<p>Es wird allerdings allgemein als schlechter Stil angesehen für primitive Typen solche Methoden zu implementieren, auch wenn es prinzipiell möglich ist.</p>
<p>Es gibt allerdings zwei Einschränkungen was die Implementierung von Traits angeht.
Die erste ist, dass Traits nur gelten, wenn sie im aktuellen Geltungsbereich sichtbar sind.
An einem Beispiel: die Standardbibliothek enthält das Trait <a href="http://doc.rust-lang.org/stable/std/io/trait.Write.html"><code>Write</code></a>,
welches extra Funktionalität zu <code>File</code> hinzufügt.
Standardmäßig haben <code>File</code>s diese Methoden aber nicht:</p>
<pre><code class="language-rust ignore">let mut f = std::fs::File::open(&quot;foo.txt&quot;).ok().expect(&quot;Couldn’t open foo.txt&quot;);
let buf = b&quot;whatever&quot;; // byte string literal. buf: &amp;[u8; 8]
let result = f.write(buf);
# result.unwrap(); // ignore the error
</code></pre>
<p>Hier kommt folgender Fehler:</p>
<pre><code class="language-text">error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
</code></pre>
<p>Wir müssen also mittels <code>use</code> das Trait <code>Write</code> einbinden:</p>
<pre><code class="language-rust ignore">use std::io::Write;

let mut f = std::fs::File::open(&quot;foo.txt&quot;).ok().expect(&quot;Couldn’t open foo.txt&quot;);
let buf = b&quot;whatever&quot;;
let result = f.write(buf);
# result.unwrap(); // ignore the error
</code></pre>
<p>Jetzt kompiliert es ohne Fehler.</p>
<p>Das heißt, dass selbst wenn jemand etwas &quot;so schlimmes&quot; macht wie Methoden zu <code>i32</code> hinzufügen, dann hat das nicht zwangsläufig Auswirkungen auf andere.</p>
<p>Eine weitere Einschränkungen ist, dass
entweder der Trait oder der Typ für den du den Trait mit <code>impl</code> implementierst, Mindestens eins von beiden, von dir stammen muss.
Es ist nicht erlaubt externe Traits für externe Typen zu implementieren.</p>
<p>Wir könnten also <code>HasArea</code> für <code>i32</code> implementieren, da <code>HasArea</code> von uns stammt.
Aber wenn wir versuchen würden <code>ToString</code>, einen Traits aus der Rust Standardbibliothek, für <code>i32</code> zu implementieren, würde uns rustc das nicht erlauben.</p>
<p>Eine Sache noch über Traits: generische Funktionen mit Trait-Schranken müssen &quot;monomorphization&quot; (mono: eine, morph: Form )verwenden, also statisch dispatchen.
Was heißt das?
Das erfährst du im Kapitel zu [Trait Objekten](Trait Objekte.html).</p>
<a class="header" href="print.html#mehrere-trait-schranken" id="mehrere-trait-schranken"><h1>Mehrere Trait-Schranken</h1></a>
<p>Du weißt jetzt, dass man generische Typparameter mit Traits beschränken kann:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo&lt;T: Clone&gt;(x: T) {
    x.clone();
}

#}</code></pre></pre>
<p>Wenn du mehr als eine Beschränkung brachst nutze <code>+</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::fmt::Debug;

fn foo&lt;T: Clone + Debug&gt;(x: T) {
    x.clone();
    println!(&quot;{:?}&quot;, x);
}

#}</code></pre></pre>
<p><code>T</code> muss nun sowohl <code>Clone</code>, als auch <code>Debug</code> implementieren.</p>
<a class="header" href="print.html#das-where-keyword" id="das-where-keyword"><h1>Das <code>where</code> Keyword</h1></a>
<p>Funktionen mit nur wenigen generischen Typen und nur wenigen Traits geht noch einigermaßen, aber sobald die Anzahl wächst, wird die Syntax zunehmend seltsamer:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

#}</code></pre></pre>
<p>Der Name der Funktion ist ganz links und die Parameter die sie annimmt ist ganz ganz rechts.
Die Schranken sind hier etwas störend.</p>
<p>Rust hat dafür eine syntaktische Lösung: <code>where</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn main() {
    foo(&quot;Hello&quot;, &quot;world&quot;);
    bar(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre></pre>
<p><code>foo()</code> benutzt die erste Syntax und <code>bar()</code> benutzt <code>where</code>.
Alles was du machen musst ist die Schranken an den Parametern weglassen und dann ein <code>where</code> nach der Parameterliste anfügen.
Bei längeren Listen kannst du auch Leerzeichen benutzen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::fmt::Debug;

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: Clone,
          K: Clone + Debug {

    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

#}</code></pre></pre>
<p>Das ist eine relative flexible Methode um komplexe Situationen übersichtlicher zu machen.
Davon abgesehen ist <code>where</code> aber auch mächtiger also die einfachere Syntax:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait ConvertTo&lt;Output&gt; {
    fn convert(&amp;self) -&gt; Output;
}

impl ConvertTo&lt;i64&gt; for i32 {
    fn convert(&amp;self) -&gt; i64 { *self as i64 }
}

// can be called with T == i32
fn normal&lt;T: ConvertTo&lt;i64&gt;&gt;(x: &amp;T) -&gt; i64 {
    x.convert()
}

// can be called with T == i64
fn inverse&lt;T&gt;() -&gt; T
        // this is using ConvertTo as if it were &quot;ConvertTo&lt;i64&gt;&quot;
        where i32: ConvertTo&lt;T&gt; {
    42.convert()
}

#}</code></pre></pre>
<p>Das hier verdeutlicht das zusätzliche Feature von <code>where</code>: es erlaubt Schranken, bei denen die linke Seite ein beliebiger Typ ist (z.b. <code>i32</code>), nicht einfach ein Typparameter wie <code>T</code>.</p>
<a class="header" href="print.html#default-methoden" id="default-methoden"><h1>Default Methoden</h1></a>
<p>Wenn du bereits weißt wie eine typische Implementation einer Methode auszusehen hat, kannst du die konkrete Implementation schon vorgeben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn is_valid(&amp;self) -&gt; bool;

    fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
}

#}</code></pre></pre>
<p>Typen die <code>Foo</code> implementieren, müssen <code>is_valid()</code> implementieren, aber nicht <code>is_invalid()</code>.
Hier wird das Standardverhalten verwendet.
Es lässt sich allerdings trotzdem noch überschreiben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# trait Foo {
#     fn is_valid(&amp;self) -&gt; bool;
#
#     fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
# }
struct UseDefault;

impl Foo for UseDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Called UseDefault.is_valid.&quot;);
        true
    }
}

struct OverrideDefault;

impl Foo for OverrideDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Called OverrideDefault.is_valid.&quot;);
        true
    }

    fn is_invalid(&amp;self) -&gt; bool {
        println!(&quot;Called OverrideDefault.is_invalid!&quot;);
        true // this implementation is a self-contradiction!
    }
}

let default = UseDefault;
assert!(!default.is_invalid()); // prints &quot;Called UseDefault.is_valid.&quot;

let over = OverrideDefault;
assert!(over.is_invalid()); // prints &quot;Called OverrideDefault.is_invalid!&quot;

#}</code></pre></pre>
<a class="header" href="print.html#vererbung" id="vererbung"><h1>Vererbung</h1></a>
<p>Manchmal setzt die Implementierung eines Traits die Implementierung eines anderen voraus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn foo(&amp;self);
}

trait FooBar : Foo {
    fn foobar(&amp;self);
}

#}</code></pre></pre>
<p>Typen die <code>FooBar</code> implementieren müssen also auch <code>Foo</code> implementieren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# trait Foo {
#     fn foo(&amp;self);
# }
# trait FooBar : Foo {
#     fn foobar(&amp;self);
# }
struct Baz;

impl Foo for Baz {
    fn foo(&amp;self) { println!(&quot;foo&quot;); }
}

impl FooBar for Baz {
    fn foobar(&amp;self) { println!(&quot;foobar&quot;); }
}

#}</code></pre></pre>
<p>Aber wenn wir das mal vergessen, wird der Compiler uns das schon vorwerfen:</p>
<pre><code class="language-text">error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]
</code></pre>
<a class="header" href="print.html#ableiten" id="ableiten"><h1>Ableiten</h1></a>
<p>Das Implementieren von Traits wie <code>Debug</code> und <code>Default</code> kann mitunter recht eintönig und nervig werden.
Aus diesem Grund lässt uns Rust mittels <a href="attribute.html">Attributen</a> bestimmte Traits automatisch zu implementieren:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Foo;

fn main() {
    println!(&quot;{:?}&quot;, Foo);
}
</code></pre></pre>
<p>Das ist jedoch momentan auf bestimmte Traits beschränkt:</p>
<ul>
<li><code>Clone</code></li>
<li><code>Copy</code></li>
<li><code>Debug</code></li>
<li><code>Default</code></li>
<li><code>Eq</code></li>
<li><code>Hash</code></li>
<li><code>Ord</code></li>
<li><code>PartialEq</code></li>
<li><code>PartialOrd</code></li>
</ul>
<a class="header" href="print.html#drop" id="drop"><h1>Drop</h1></a>
<a class="header" href="print.html#if-let" id="if-let"><h1>if let</h1></a>
<a class="header" href="print.html#trait-objekte" id="trait-objekte"><h1>Trait Objekte</h1></a>
<a class="header" href="print.html#closures" id="closures"><h1>Closures</h1></a>
<a class="header" href="print.html#universal-function-call-syntax" id="universal-function-call-syntax"><h1>Universal Function Call Syntax</h1></a>
<a class="header" href="print.html#crates-und-module" id="crates-und-module"><h1>Crates und Module</h1></a>
<a class="header" href="print.html#const-und-static" id="const-und-static"><h1><code>const</code> und <code>static</code></h1></a>
<a class="header" href="print.html#attribute" id="attribute"><h1>Attribute</h1></a>
<a class="header" href="print.html#type-aliase" id="type-aliase"><h1><code>type</code> Aliase</h1></a>
<a class="header" href="print.html#zwischen-typen-umwandeln" id="zwischen-typen-umwandeln"><h1>Zwischen typen umwandeln</h1></a>
<a class="header" href="print.html#assoziierte-typen" id="assoziierte-typen"><h1>Assoziierte Typen</h1></a>
<a class="header" href="print.html#größenlose-typen" id="größenlose-typen"><h1>Größenlose Typen</h1></a>
<a class="header" href="print.html#operatoren-und-Überladen" id="operatoren-und-Überladen"><h1>Operatoren und Überladen</h1></a>
<a class="header" href="print.html#deref-umwandlung" id="deref-umwandlung"><h1>Deref Umwandlung</h1></a>
<a class="header" href="print.html#makros" id="makros"><h1>Makros</h1></a>
<a class="header" href="print.html#raw-zeiger" id="raw-zeiger"><h1>Raw Zeiger</h1></a>
<a class="header" href="print.html#unsafe" id="unsafe"><h1><code>unsafe</code></h1></a>
<a class="header" href="print.html#nightly-rust" id="nightly-rust"><h1>Nightly Rust</h1></a>
<a class="header" href="print.html#compiler-plugins" id="compiler-plugins"><h1>Compiler Plugins</h1></a>
<a class="header" href="print.html#inline-assembly" id="inline-assembly"><h1>Inline Assembly</h1></a>
<a class="header" href="print.html#no_stdlib" id="no_stdlib"><h1><code>no_stdlib</code></h1></a>
<a class="header" href="print.html#intrinsics" id="intrinsics"><h1>Intrinsics</h1></a>
<a class="header" href="print.html#lang-items" id="lang-items"><h1>Lang items</h1></a>
<a class="header" href="print.html#fortgeschrittenes-linken" id="fortgeschrittenes-linken"><h1>Fortgeschrittenes Linken</h1></a>
<a class="header" href="print.html#benchmark-tests" id="benchmark-tests"><h1>Benchmark Tests</h1></a>
<a class="header" href="print.html#box-syntax-und-muster" id="box-syntax-und-muster"><h1>Box Syntax und Muster</h1></a>
<a class="header" href="print.html#slice-muster" id="slice-muster"><h1>Slice Muster</h1></a>
<a class="header" href="print.html#assoziierte-konstanten" id="assoziierte-konstanten"><h1>Assoziierte Konstanten</h1></a>
<a class="header" href="print.html#glossar" id="glossar"><h1>Glossar</h1></a>
<a class="header" href="print.html#akademische-forschung" id="akademische-forschung"><h1>Akademische Forschung</h1></a>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
