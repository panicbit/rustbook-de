<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Testen - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="Einführung.html"><strong>1.</strong> Einführung</a></li><li><a href="Erste_Schritte.html"><strong>2.</strong> Erste Schritte</a></li><li><ul class="section"><li><a href="Rust_Installieren.html"><strong>2.1.</strong> Rust installieren</a></li><li><a href="Hallo_Welt.html"><strong>2.2.</strong> Hallo Welt</a></li><li><a href="Hallo_Cargo.html"><strong>2.3.</strong> Hallo Cargo</a></li></ul></li><li><a href="Lerne_Rust.html"><strong>3.</strong> Lerne Rust</a></li><li><ul class="section"><li><a href="Ratespiel.html"><strong>3.1.</strong> Ratespiel</a></li><li><a href="Speisende_Philosophen.html"><strong>3.2.</strong> Speisende Philosophen</a></li><li><a href="Rust_In_Anderen_Sprachen.html"><strong>3.3.</strong> Rust in anderen Sprachen</a></li></ul></li><li><a href="Effektives_Rust.html"><strong>4.</strong> Effektives Rust</a></li><li><ul class="section"><li><a href="Der_Stack_Und_Der_Heap.html"><strong>4.1.</strong> Der Stack und der Heap</a></li><li><a href="Testen.html" class="active"><strong>4.2.</strong> Testen</a></li><li><a href="Bedingte_Kompilierung.html"><strong>4.3.</strong> Bedingte Kompilierung</a></li><li><a href="Dokumentation.html"><strong>4.4.</strong> Dokumentation</a></li><li><a href="Iteratoren.html"><strong>4.5.</strong> Iteratoren</a></li><li><a href="Nebenläufigkeit.html"><strong>4.6.</strong> Nebenläufigkeit</a></li><li><a href="Fehlerbehandlung.html"><strong>4.7.</strong> Fehlerbehandlung</a></li><li><a href="Garantien_Wählen.html"><strong>4.8.</strong> Garantien Wählen</a></li><li><a href="FFI.html"><strong>4.9.</strong> FFI</a></li><li><a href="Borrow_Und_AsRef.html"><strong>4.10.</strong> Borrow und AsRef</a></li><li><a href="Release_Kanäle.html"><strong>4.11.</strong> Release Kanäle</a></li></ul></li><li><a href="Syntax_Und_Semantik.html"><strong>5.</strong> Syntax und Semantik</a></li><li><ul class="section"><li><a href="Variablenbindung.html"><strong>5.1.</strong> Variablenbindung</a></li><li><a href="Funktionen.html"><strong>5.2.</strong> Funktionen</a></li><li><a href="Primitive_Typen.html"><strong>5.3.</strong> Primitive Typen</a></li><li><a href="Kommentare.html"><strong>5.4.</strong> Kommentare</a></li><li><a href="If.html"><strong>5.5.</strong> if</a></li><li><a href="Schleifen.html"><strong>5.6.</strong> Schleifen</a></li><li><a href="Besitz.html"><strong>5.7.</strong> Besitz</a></li><li><a href="Referenzen_Und_Ausleihen.html"><strong>5.8.</strong> Referenzen und Ausleihen</a></li><li><a href="Lebensdauer.html"><strong>5.9.</strong> Lebensdauer</a></li><li><a href="Veränderbarkeit.html"><strong>5.10.</strong> Veränderbarkeit</a></li><li><a href="Structs.html"><strong>5.11.</strong> Structs</a></li><li><a href="Enums.html"><strong>5.12.</strong> Enums</a></li><li><a href="Match.html"><strong>5.13.</strong> Match</a></li><li><a href="Muster.html"><strong>5.14.</strong> Muster</a></li><li><a href="Methodensyntax.html"><strong>5.15.</strong> Methodensyntax</a></li><li><a href="Vektoren.html"><strong>5.16.</strong> Vektoren</a></li><li><a href="Strings.html"><strong>5.17.</strong> Strings</a></li><li><a href="Generics.html"><strong>5.18.</strong> Generics</a></li><li><a href="Traits.html"><strong>5.19.</strong> Traits</a></li><li><a href="Drop.html"><strong>5.20.</strong> Drop</a></li><li><a href="If_Let.html"><strong>5.21.</strong> if let</a></li><li><a href="Trait_Objekte.html"><strong>5.22.</strong> Trait Objekte</a></li><li><a href="Closures.html"><strong>5.23.</strong> Closures</a></li><li><a href="UFCS.html"><strong>5.24.</strong> Universal Function Call Syntax</a></li><li><a href="Crates_Und_Module.html"><strong>5.25.</strong> Crates und Module</a></li><li><a href="Const_Und_Static.html"><strong>5.26.</strong> <code>const</code> und <code>static</code></a></li><li><a href="Attribute.html"><strong>5.27.</strong> Attribute</a></li><li><a href="Type_Aliase.html"><strong>5.28.</strong> <code>type</code> Aliase</a></li><li><a href="Zwischen_Typen_Umwandeln.html"><strong>5.29.</strong> Zwischen typen umwandeln</a></li><li><a href="Assoziierte_Typen.html"><strong>5.30.</strong> Assoziierte Typen</a></li><li><a href="Größenlose_Typen.html"><strong>5.31.</strong> Größenlose Typen</a></li><li><a href="Operatoren_Und_Überladen.html"><strong>5.32.</strong> Operatoren und Überladen</a></li><li><a href="Deref_Umwandlung.html"><strong>5.33.</strong> Deref Umwandlung</a></li><li><a href="Makros.html"><strong>5.34.</strong> Makros</a></li><li><a href="Raw_Zeiger.html"><strong>5.35.</strong> Raw Zeiger</a></li><li><a href="Unsafe.html"><strong>5.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="Nightly_Rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="Compiler_Plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="Inline_Assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="No_Stdlib.html"><strong>6.3.</strong> <code>no_stdlib</code></a></li><li><a href="Intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="Lang_Items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="Fortgeschrittenes_Linken.html"><strong>6.6.</strong> Fortgeschrittenes Linken</a></li><li><a href="Benchmark_Tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="Box_Syntax_Und_Muster.html"><strong>6.8.</strong> Box Syntax und Muster</a></li><li><a href="Slice_Muster.html"><strong>6.9.</strong> Slice Muster</a></li><li><a href="Assoziierte_Konstanten.html"><strong>6.10.</strong> Assoziierte Konstanten</a></li></ul></li><li><a href="Glossar.html"><strong>7.</strong> Glossar</a></li><li><a href="Akademische_Forschung.html"><strong>8.</strong> Akademische Forschung</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="Testen.html#testing" id="testing"><h1>Testing</h1></a>
<blockquote>
<p>Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.</p>
<p><em>Das Testen von Programmen ist eine sehr effektive Art,
die Anwesenheit von Bugs zu zeigen, aber ist hoffnungslos unangemessen, deren Abwesenheit zu zeigen.</em></p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>
<a class="header" href="Testen.html#das-test-attribut" id="das-test-attribut"><h2>Das <code>test</code> Attribut</h2></a>
<p>In Rust ist ein Test ganz einfach eine Funktion die mit <code>test</code> annotiert ist.
Beginnen wir also ein kleines Cargo Projekt namens <code>adder</code>:</p>
<pre><code class="language-bash">$ cargo new adder
$ cd adder
</code></pre>
<p>Wenn wir <code>cargo new</code> ohne <code>--bin</code> ausführen erzeugt Cargo ein Library-Projekt.
Cargo generiert automatisch einen kleinen Test, wie man am Inhalt von <code>src/lib.rs</code> sieht:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
}

#}</code></pre></pre>
<p>Achte auf <code>#[test]</code>.
Das ist ein Attribut und es markiert die Funktion <code>it_works()</code> als Test.
Sie ist erst mal leer.
Dann kann sie auch auch nicht fehlschlagen.
Wir können sie ganz einfach mit <code>cargo test</code> ausführen:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Hier sehen wir zwei Ausgaben.
Die erste für den Test den wir geschrieben haben,
die zweite für Dokumentationstests, davon später mehr.
Vorerst:</p>
<pre><code class="language-text">test it_works ... ok
</code></pre>
<p>Beachte dass hier der Name unserer Funktion <code>it_works</code> steht.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn it_works() {
}

#}</code></pre></pre>
<p>Warum schlägt dieser leere Test aber nun nicht fehl?
Jeder Test der kein <code>panic!()</code> provoziert ist erfolgreich.
Wie könnten wir ihn nun fehlschlagen lassen?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert!(false);
}

#}</code></pre></pre>
<p><code>assert!</code> ist ein Macro in Rust das genau ein Argument nimmt,
und wenn das nicht <code>true</code> ist, dann ruft es <code>panic!</code> auf.
Also nochmal:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247
</code></pre>
<p>Rust sagt uns, dass unser Test gefailt ist.</p>
<pre><code class="language-text">test it_works ... FAILED
</code></pre>
<p>Was uns auch die Zusammenfassung am Ende sagt:</p>
<pre><code class="language-text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Wir haben ebenfalls einen non-zero status code bekommen, ein feature unserer Shell (<em>linux und OS X</em>), dass das letzte Kommando fehlgeschlagen ist.</p>
<pre><code class="language-bash">$ echo $?
101
</code></pre>
<p>Auf Windows in <code>cmd</code> :</p>
<pre><code class="language-bash">&gt; echo %ERRORLEVEL%
</code></pre>
<p>oder PowerShell:</p>
<pre><code class="language-bash">&gt; echo $LASTEXITCODE # Der Exitcode selbst
&gt; echo $? # ein boolean, Erfolgreich oder nicht
</code></pre>
<p>Das ist nützlich wenn du <code>cargo test</code> in andere Tools integrieren willst.</p>
<p>Wir können den Test auch invertieren, wenn wir wollen, dass er fehlschlägt: <code>should_panic</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic]
fn it_works() {
    assert!(false);
}

#}</code></pre></pre>
<p>Der Test zählt nun als erfolgreich, wenn <code>panic!</code> eintritt.
Gleich mal ausprobieren:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Rust kennt noch ein weiteres Macro: <code>assert_eq!</code>, zum Vergleichen zweier Werte:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}

#}</code></pre></pre>
<p>Schlägt das hier nun fehl?
Nein, denn da steht noch <code>should_panic</code>:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><code>should_panic</code> ist immer mit etwas Vorsicht zu genießen, denn es schwer sicher zu sein, ob der Test nicht auf Grund anderer Probleme ge<code>panic</code>t hat.
Wir können aber Bedingungen für bestimmte Fehler hinzufügen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic(expected = &quot;assertion failed&quot;)]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}

#}</code></pre></pre>
<p>Jetzt muss das <code>assert_eq!</code> fehlschlagen, sonst scheitert der Test trotzdem.</p>
<p>Soviel also zu Grundlagen, schreiben wir endlich einen nützlichen Test!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}

#}</code></pre></pre>
<p>Das ist ein klassischer Fall für <code>assert_eq!</code>: Wir rufen eine Funktion auf und vergleichen ihren Rückgabewert.</p>
<a class="header" href="Testen.html#das-ignore-attribut" id="das-ignore-attribut"><h2>Das <code>ignore</code> Attribut</h2></a>
<p>In Manchen Situationen wollen wir bestimmte Tests nicht immer mit ausführen, besonders, wenn sie teuer sind.
Diese kann man dann mit <code>ignore</code> ausschalten:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}

#[test]
#[ignore]
fn expensive_test() {
    // Code der eine Stunde läuft
}

#}</code></pre></pre>
<p>Jetzt werden sie exklusiv dann ausgeführt wenn wir <code>cargo test -- --ignored</code> ausführen:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Wir sehen: <code>it_works</code> wurde getestet, <code>expensive_test</code> nicht.</p>
<pre><code class="language-bash">$ cargo test -- --ignored
     Running target/adder-91b3e234d4ed382a

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Wichtig: <code>--ignored</code> ist ein Argument, das von dem Testbinary interpretiert wird, nicht von Cargo selbst.
Das wird mit den extra <code>--</code> vermittelt.</p>
<a class="header" href="Testen.html#das-tests-modul" id="das-tests-modul"><h2>Das <code>tests</code> Modul</h2></a>
<p>Was ist allerdings, wenn wir noch Hilfsfunktionen für unsere Tests brauchen,
die selbst keine Tests sind, die wir aber auch nicht mit ausliefern wollen?
Dafür kann man Tests innerhalb eines <code>tests</code> Moduls implementieren.
So in etwa:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::add_two;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}

#}</code></pre></pre>
<p>Das erlaubt es uns alle unsere Tests hier zu gruppieren und zusätzlich auch noch ggf. Hilfsfunktionen zu implementieren.
Dieses gesamte Modul wird nicht in unser crate kompiliert, wenn wir es nicht explizit als Test kompilieren, wir haben also nie Testcode in unserer Bibliothek.
Das spart nicht nur Kompilierzeit, sondern auch noch Platz.</p>
<p>Eine weitere Änderung ist die <code>use</code> Deklaration.
Weil wir uns hier in einem Untermodul und damit einem anderen Namespace befinden müssen, müssen wir die zu testende Funktion quasi importieren.
Das kann nerven, wenn wir irgendwann größere Projekte haben, also vereinfachen wir das doch einfach mit <code>*</code></p>
<pre><code class="language-rust ignore">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Beachte, dass sich die <code>use</code> Zeile geändert hat:</p>
<pre><code class="language-bash">$ cargo test
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Schön!</p>
<p>Die momentane Konvention ist, dass das <code>tests</code> Modul deine &quot;unit-style&quot; Tests enthält.
Alles was nur kleine Funktionalitätstests umfasst.
Integrationstest jedoch, verdienen etwas mehr Platz, dafür haben wir das <code>tests</code> Verzeichnis.</p>
<a class="header" href="Testen.html#das-tests-verzeichnis" id="das-tests-verzeichnis"><h2>Das <code>tests</code> Verzeichnis</h2></a>
<p>Um einen Integrationstest zu schreiben erzeugen wir erst einmal unser <code>tests</code> Verzeichnis und legen darin eine <code>.rs</code> Datei an: <code>tests/lib.rs</code>:</p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_works() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Das sieht unserem vorherigen Test schon sehr ähnlich, naja, nicht ganz.
Wir haben nun die Zeile <code>extern crate adder</code> ganz oben.
Das ist weil die Tests im <code>tests</code> Verzeichnis ein eigenes Crate sind und daher unsere Bibliothek erst einbinden müssen.
Das ist auch ein Grund warum Integrationstests hier gut aufgehoben sind, sie verwenden unsere Bibliothek genauso wie es ein dritter tun würde.</p>
<p>Führen wir sie aus:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Jetzt haben wir drei Sektionen: unsere vorherigen Tests werden ja immernoch ausgeführt.</p>
<p>Das ist alles zum <code>tests</code> Verzeichnis.
Das <code>tests</code> Modul brauchen wir hier nicht, da alles mit Tests zu tun hat.</p>
<p>Kommen wir nun zum dritten Teil: Dokumentation.</p>
<a class="header" href="Testen.html#dokumentationstests" id="dokumentationstests"><h2>Dokumentationstests</h2></a>
<p>Nichts ist besser als Dokumentation mit Beispielen.
Nichts ist blöder als wenn die Beispiele in der Dokumentation nicht funktionieren, zum Beispiel, weil sich die API verändert hat, seitdem die Dokumentation geschrieben wurde.
Rust macht damit Schluss, indem es automatisch den Code in der Dokumentation mit ausführt.
<em>Allerdings nur bei Bibliothek-Crates, nicht Binary-Crates.</em>
Hier nochmal <code>src/lib.rs</code> mit Beispielen:</p>
<pre><code class="lang-rust">
//! The `adder` crate provides functions that add numbers to other numbers.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// This function adds two to its argument.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Wichtig hier: Moduldokumentation beginnt mit <code>//!</code> und Funktionsdokumentation mit <code>///</code>.
Kommentare die mit <code>//</code> beginnen landen nicht in der Dokumentation.
Rusts Dokumentationswerkzeug unterstützt Markdown, daher markieren drei Accent grave Zeichen *(backticks &quot;`&quot;)*
Es ist Konvention eine Überschrift <code># Examples</code> <em>(bitte Englisch)</em> zu haben, dem dann die Beispiele folgen.</p>
<p>Noch ein Testlauf:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Jetzt haben wir alle drei Arten von Tests getestet.
Hier heißt der Dokumentationstest <code>_0</code> und der Funktionstest <code>add_two_0</code>.
Die Zahl wir inkrementiert je mehr Tests dazukommen.</p>
<p>Wir haben noch nicht alles wichtige zu Dokumentationstests hier erwähnt.
Für mehr schau in das <a href="documentation">Dokumentationskapitel</a>.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="Der_Stack_Und_Der_Heap.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="Bedingte_Kompilierung.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="Der_Stack_Und_Der_Heap.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="Bedingte_Kompilierung.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
