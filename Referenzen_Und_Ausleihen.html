<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Referenzen und Ausleihen - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="Einführung.html"><strong>1.</strong> Einführung</a></li><li><a href="Erste_Schritte.html"><strong>2.</strong> Erste Schritte</a></li><li><ul class="section"><li><a href="Rust_Installieren.html"><strong>2.1.</strong> Rust installieren</a></li><li><a href="Hallo_Welt.html"><strong>2.2.</strong> Hallo Welt</a></li><li><a href="Hallo_Cargo.html"><strong>2.3.</strong> Hallo Cargo</a></li></ul></li><li><a href="Lerne_Rust.html"><strong>3.</strong> Lerne Rust</a></li><li><ul class="section"><li><a href="Ratespiel.html"><strong>3.1.</strong> Ratespiel</a></li><li><a href="Speisende_Philosophen.html"><strong>3.2.</strong> Speisende Philosophen</a></li><li><a href="Rust_In_Anderen_Sprachen.html"><strong>3.3.</strong> Rust in anderen Sprachen</a></li></ul></li><li><a href="Effektives_Rust.html"><strong>4.</strong> Effektives Rust</a></li><li><ul class="section"><li><a href="Der_Stack_Und_Der_Heap.html"><strong>4.1.</strong> Der Stack und der Heap</a></li><li><a href="Testen.html"><strong>4.2.</strong> Testen</a></li><li><a href="Bedingte_Kompilierung.html"><strong>4.3.</strong> Bedingte Kompilierung</a></li><li><a href="Dokumentation.html"><strong>4.4.</strong> Dokumentation</a></li><li><a href="Iteratoren.html"><strong>4.5.</strong> Iteratoren</a></li><li><a href="Nebenläufigkeit.html"><strong>4.6.</strong> Nebenläufigkeit</a></li><li><a href="Fehlerbehandlung.html"><strong>4.7.</strong> Fehlerbehandlung</a></li><li><a href="Garantien_Wählen.html"><strong>4.8.</strong> Garantien Wählen</a></li><li><a href="FFI.html"><strong>4.9.</strong> FFI</a></li><li><a href="Borrow_Und_AsRef.html"><strong>4.10.</strong> Borrow und AsRef</a></li><li><a href="Release_Kanäle.html"><strong>4.11.</strong> Release Kanäle</a></li></ul></li><li><a href="Syntax_Und_Semantik.html"><strong>5.</strong> Syntax und Semantik</a></li><li><ul class="section"><li><a href="Variablenbindung.html"><strong>5.1.</strong> Variablenbindung</a></li><li><a href="Funktionen.html"><strong>5.2.</strong> Funktionen</a></li><li><a href="Primitive_Typen.html"><strong>5.3.</strong> Primitive Typen</a></li><li><a href="Kommentare.html"><strong>5.4.</strong> Kommentare</a></li><li><a href="If.html"><strong>5.5.</strong> if</a></li><li><a href="Schleifen.html"><strong>5.6.</strong> Schleifen</a></li><li><a href="Besitz.html"><strong>5.7.</strong> Besitz</a></li><li><a href="Referenzen_Und_Ausleihen.html" class="active"><strong>5.8.</strong> Referenzen und Ausleihen</a></li><li><a href="Lebensdauer.html"><strong>5.9.</strong> Lebensdauer</a></li><li><a href="Veränderbarkeit.html"><strong>5.10.</strong> Veränderbarkeit</a></li><li><a href="Structs.html"><strong>5.11.</strong> Structs</a></li><li><a href="Enums.html"><strong>5.12.</strong> Enums</a></li><li><a href="Match.html"><strong>5.13.</strong> Match</a></li><li><a href="Muster.html"><strong>5.14.</strong> Muster</a></li><li><a href="Methodensyntax.html"><strong>5.15.</strong> Methodensyntax</a></li><li><a href="Vektoren.html"><strong>5.16.</strong> Vektoren</a></li><li><a href="Strings.html"><strong>5.17.</strong> Strings</a></li><li><a href="Generics.html"><strong>5.18.</strong> Generics</a></li><li><a href="Traits.html"><strong>5.19.</strong> Traits</a></li><li><a href="Drop.html"><strong>5.20.</strong> Drop</a></li><li><a href="If_Let.html"><strong>5.21.</strong> if let</a></li><li><a href="Trait_Objekte.html"><strong>5.22.</strong> Trait Objekte</a></li><li><a href="Closures.html"><strong>5.23.</strong> Closures</a></li><li><a href="UFCS.html"><strong>5.24.</strong> Universal Function Call Syntax</a></li><li><a href="Crates_Und_Module.html"><strong>5.25.</strong> Crates und Module</a></li><li><a href="Const_Und_Static.html"><strong>5.26.</strong> <code>const</code> und <code>static</code></a></li><li><a href="Attribute.html"><strong>5.27.</strong> Attribute</a></li><li><a href="Type_Aliase.html"><strong>5.28.</strong> <code>type</code> Aliase</a></li><li><a href="Zwischen_Typen_Umwandeln.html"><strong>5.29.</strong> Zwischen typen umwandeln</a></li><li><a href="Assoziierte_Typen.html"><strong>5.30.</strong> Assoziierte Typen</a></li><li><a href="Größenlose_Typen.html"><strong>5.31.</strong> Größenlose Typen</a></li><li><a href="Operatoren_Und_Überladen.html"><strong>5.32.</strong> Operatoren und Überladen</a></li><li><a href="Deref_Umwandlung.html"><strong>5.33.</strong> Deref Umwandlung</a></li><li><a href="Makros.html"><strong>5.34.</strong> Makros</a></li><li><a href="Raw_Zeiger.html"><strong>5.35.</strong> Raw Zeiger</a></li><li><a href="Unsafe.html"><strong>5.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="Nightly_Rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="Compiler_Plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="Inline_Assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="No_Stdlib.html"><strong>6.3.</strong> <code>no_stdlib</code></a></li><li><a href="Intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="Lang_Items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="Fortgeschrittenes_Linken.html"><strong>6.6.</strong> Fortgeschrittenes Linken</a></li><li><a href="Benchmark_Tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="Box_Syntax_Und_Muster.html"><strong>6.8.</strong> Box Syntax und Muster</a></li><li><a href="Slice_Muster.html"><strong>6.9.</strong> Slice Muster</a></li><li><a href="Assoziierte_Konstanten.html"><strong>6.10.</strong> Assoziierte Konstanten</a></li></ul></li><li><a href="Glossar.html"><strong>7.</strong> Glossar</a></li><li><a href="Akademische_Forschung.html"><strong>8.</strong> Akademische Forschung</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="Referenzen_Und_Ausleihen.html#referenzen-und-ausleihen" id="referenzen-und-ausleihen"><h1>Referenzen und Ausleihen</h1></a>
<p>Dieser Guide ist einer von dreien, der Rusts Ownership-System.
präsentiert. Dies ist eines von Rusts einzigartigen und verlockenden
Features mit denen Rust Entwickler vertraut sein sollten.
Durch Ownership [engl.: Besitz] erreicht Rust sein größtes Ziel,
die Speichersicherheit.
Es gibt ein paar verschiedene Konzepte, jedes mit seinem eigenen Kapitel:</p>
<ul>
<li><a href="Besitz.html">Besitz</a>, das Schlüsselkonzept.</li>
<li>Ausleihen, das was du gerade liest.</li>
<li><a href="Lebensdauer.html">Lebensdauer</a>, ein fortgeschrittenes Konzept des Ausleihens.</li>
</ul>
<p>Diese drei Kapitel sind verwandt und deswegen in dieser Reihenfolge zu lesen.
Du wirst alle drei benötigen um das Ownership-System vollständig zu verstehen.</p>
<a class="header" href="Referenzen_Und_Ausleihen.html#meta" id="meta"><h1>Meta</h1></a>
<p>Bevor wir in die Details gehen gibt es zwei wichtige Hinweise über das
Ownership-System.</p>
<p>Rust hat einen Fokus auf Sicherheit und Geschwindigkeit.
Es erfüllt diese Ziele durch viele &quot;kostenfreie Abstraktionen&quot;
[‘zero-cost abstractions’], was bedeutet, dass in Rust die Kosten so niedrig
wie möglich sind um diese Abstraktionen funktionieren zu lassen.
Jegliche Analyse über die wie in diesem Guide sprechen wird
<em>zur Kompilierzeit</em> ausgeführt. Du zahlst für diese Features
keine Extrakosten zur Laufzeit.</p>
<p>Jedoch hat dieses System einen gewissen Preis: Die Lernkurve.
Viele neue Rust Nutzer erleben etwas,
was wir &quot;mit dem <em>borrow checker</em> kämpfen&quot; nennen,
wobei dann Rust verweigert ein Programm zu kompilieren,
bei dem der Author denkt, dass es korrekt ist.
Das passiert häufig, da das mentale Modell des Programmierers von Ownership
nicht den eigentlichen Regeln entspricht, die Rust implementiert.
Du wirst wahrscheinlich zuerst etwas ähnliches erleben.
Die guten Nachricht ist aber:
Erfahrenere Rust Entwickler berichten, dass, sobald sie eine Zeit
mit den Regeln des Ownership-Systems gearbeitet haben, sie immer weniger
mit dem <em>borrow checker</em> kämpfen müssen.</p>
<p>Mit diesem Wissen, lass uns über Ausleihen lernen.</p>
<a class="header" href="Referenzen_Und_Ausleihen.html#ausleihen" id="ausleihen"><h1>Ausleihen</h1></a>
<p>Am ende des <a href="Besitz.html">Besitz</a> Abschnittes hatten wir eine üble Funktion,
die so aussah:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);

#}</code></pre></pre>
<p>Das ist jedoch kein übliches Rust,
da wir das &quot;Ausleihen&quot; [borrowing] nicht verwenden.
Hier ist unser erster Schritt:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // do stuff with v1 and v2

    // return the answer
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&amp;v1, &amp;v2);

// we can use v1 and v2 here!

#}</code></pre></pre>
<p>Anstatt der <code>Vec&lt;i32&gt;</code> verwenden wir Referenzen als Argument:
<code>&amp;Vec&lt;i32&gt;</code>. Und anstatt <code>v1</code> und <code>v2</code> übergeben wir <code>&amp;v1</code> und <code>&amp;v2</code>.
Wir nennen den <code>&amp;T</code> eine ‘Referenz’ und anstatt die Ressource zu besitzen,
leihen sie sich die Ressource aus.
Eine Bindung, die sich etwas ausleiht, gibt den Speicher der Ressource nicht
frei, wenn sie den Scope verlässt. Das bedeutet, dass wir nach dem Aufruf
<code>foo()</code> unsere ursprüngliche Bindung wieder verwenden könnne.</p>
<p>Referenzen sind unveränderbar [immutable], genauso wie Bindungen.
Das bedeutet, dass der Vektor innerhalb von <code>foo()</code> nicht verändert werden kann:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(v: &amp;Vec&lt;i32&gt;) {
     v.push(5);
}

let v = vec![];

foo(&amp;v);

#}</code></pre></pre>
<p>Dies erzeugt einen Fehler:</p>
<pre><code class="language-text">error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
</code></pre>
<p>Eine neue Variable am ende des Vektors anzufügen verändert den Vektor,
also dürfen wir das nicht machen.</p>
<a class="header" href="Referenzen_Und_Ausleihen.html#mut-referenzen" id="mut-referenzen"><h1>&amp;mut Referenzen</h1></a>
<p>Es gibt eine zweite Art von Referenz: <code>&amp;mut T</code>.
Eine veränderbare Referenz [mutable reference] erlaubt einem
die Ressource, die man ausleiht, zu verändern. Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
{
    let y = &amp;mut x;
    *y += 1;
}
println!(&quot;{}&quot;, x);

#}</code></pre></pre>
<p>Dies wird <code>6</code> ausgeben. Wir machen <code>y</code> zu einer veränderbaren Referenz auf
<code>x</code> und inkrementieren dann den Wert auf den <code>y</code> zeigt.
Du wirst bemerken, dass <code>x</code> ebenfalls als <code>mut</code> markiert werden musste.
Wenn es das nicht wäre, dann könnten wir keine veränderbare Referenz darauf
erzeugen.</p>
<p>Du wirst auch feststellen, dass wir ein Stern (<code>*</code>) vor dem <code>y</code> hinzugefügt
haben: <code>*y</code>. Das ist so, weil <code>y</code> eine <code>&amp;mut</code> Referenz ist.
Du wirst den Stern auch brauchen, wenn du auf den Inhalt einer normalen
Referenz zugreifen möchtest.</p>
<p>Ansonsten sind <code>&amp;mut</code> Referenzen genauso wie die gewöhnlichen Referenzen.
Es <em>gibt</em> jedoch einen großen Unterschied zwischen den beiden und wie sie
interagieren. Du kannst bereits an dem zusätzlichen Scope, den wir mit
<code>{</code> und <code>}</code> eingeführt haben, feststellen, dass etwas komisch ist.</p>
<p>Wenn wir sie entfernen, dann erhalten wir einen Fehler:</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &amp;mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Wie es sich herausstellt gibt es Regeln.</p>
<a class="header" href="Referenzen_Und_Ausleihen.html#die-regeln" id="die-regeln"><h1>Die Regeln</h1></a>
<p>Hier sind die Regeln die beim Ausleihen in Rust gelten:</p>
<p>Erstens darf etwas nicht länger ausgeliehen werden als das ausgeliehene
existiert. Zweitens du darfst entweder die eine oder die andere Art von
Referenz haben, aber nicht beide zur gleichen Zeit:</p>
<ul>
<li>eine oder mehr Referenzen (<code>&amp;T</code>) auf eine Ressource,</li>
<li>genau eine veränderbare Referenz (<code>&amp;mut T</code>).</li>
</ul>
<p>Du wirs feststellen, das dies sehr ähnlich (wenn auch nicht ganz exakt)
der Definition eines <em>data race</em> entspricht:</p>
<blockquote>
<p>There is a ‘data race’ when two or more pointers access the same memory
location at the same time, where at least one of them is writing, and the
operations are not synchronized.</p>
</blockquote>
<blockquote>
<p>Es gibt ein ‘data race’, wenn zwei oder mehr Zeiger zur selben Zeit
die gleiche Speicherstelle zugreifen, wobei mindestens ein Zugriff
schreibend erfolgt und die Operation nicht synchronisiert ist.</p>
</blockquote>
<p>Referenzen kann man so viele haben wie man möchte,
da keine von ihnen Schreibzugriffe erlaubt.
Wenn man schreibend zugreift, dann benötigt es zwei oder
mehr Zeiger auf die gleiche Speicherstelle um einen <em>data race</em> hervorzurufen,
aber Rust erlaubt es uns zu einem gewissen Zeitpunkt nur eine <code>&amp;mut</code> Referenz
zu haben.
So verhindert Rust <em>data races</em> zur Kompilierzeit:
Wir erhalten Fehler, wenn wir die Regeln brechen.</p>
<a class="header" href="Referenzen_Und_Ausleihen.html#in-scopes-denken" id="in-scopes-denken"><h2>In Scopes denken</h2></a>
<p>Hier ist der Code:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let y = &amp;mut x;

*y += 1;

println!(&quot;{}&quot;, x);

#}</code></pre></pre>
<p>Dieser Code gibt uns diesen Fehler:</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
</code></pre>
<p>Das kommt weil wir die Regeln verletzt haben:
Wir haben ein <code>&amp;mut T</code> welches auf <code>x</code> zeigt, weswegen wir
keine  <code>&amp;T</code>s erzeugen dürfen. Entweder nur das eine oder nur das andere.
Die <code>note:</code> Meldung gibt uns einen Hinweis
wie man über das Problem denken kann:</p>
<pre><code class="language-text">note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>In anderen Worten bleibt das <em>mutable borrow</em> bis zum Ende unseres
Beispiels bestehen. Was wir wollen ist, dass das <em>mutable borrow</em>
endet <em>bevor</em> wir versuchen <code>println!</code> aufzurufen und damit eine
ein <em>immutable borrow</em> vornehmen.
In Rust ist ein <em>borrow</em> an den Scope gebunden für den es gültig ist.
Und unser Scope sieht so aus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;

let y = &amp;mut x;    // -+ &amp;mut borrow of x starts here
                   //  |
*y += 1;           //  |
                   //  |
println!(&quot;{}&quot;, x); // -+ - try to borrow x here
                   // -+ &amp;mut borrow of x ends here

#}</code></pre></pre>
<p>Die Scopes stehen im Konflikt: Wir können kein <code>&amp;x</code> erzeugen, während <code>y</code>
im Scope ist.
Wenn wir also geschweifte Klammern hinzufügen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;

{                   
    let y = &amp;mut x; // -+ &amp;mut borrow starts here
    *y += 1;        //  |
}                   // -+ ... and ends here

println!(&quot;{}&quot;, x);  // &lt;- try to borrow x here

#}</code></pre></pre>
<p>Dann gibt es kein Problem. Unser <em>mutable borrow</em> verlässt den Scope bevor
wir ein <em>immutable borrow</em> erzeugen.
Der Scope ist der Schlüssel um zu sehen wie lange ein <em>borrow</em> anhält.</p>
<a class="header" href="Referenzen_Und_Ausleihen.html#probleme-die-das-ausleihen-verhindert" id="probleme-die-das-ausleihen-verhindert"><h2>Probleme die das Ausleihen verhindert</h2></a>
<p>Warum haben wir diese einschränkenden Regeln?
Nun, wie wir schon angemerkt haben, verhindern sie <em>data rces</em>.
Welche Arten von Problemen werden durch <em>data races</em> erzeugt?
Hier sind ein paar.</p>
<a class="header" href="Referenzen_Und_Ausleihen.html#iterator-invalidation" id="iterator-invalidation"><h3>Iterator invalidation</h3></a>
<p>Ein Beispiel ist ‘iterator invalidation’,
welche stattfindet, wenn man versucht eine Collection
zu verändern über die man iteriert. Rusts Borrow Checker verhindert,
dass das passiert:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
}

#}</code></pre></pre>
<p>Dies gibt eins bis drei aus. Während wir durch den Vektor iterieren
erhalten wir nur Referenzen auf die Elemente. Und <code>v</code> ist selber
nur unveränderbar ausgeliehen, was bedeutet, dass wir es nicht
verändern können, während wir darüber iterieren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
    v.push(34);
}

#}</code></pre></pre>
<p>Hier ist der Fehler:</p>
<pre><code class="language-text">error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &amp;v {
          ^
note: previous borrow ends here
for i in &amp;v {
    println!(“{}”, i);
    v.push(34);
}
^
</code></pre>
<p>Wir können <code>v</code> nicht verändern, da es von der Schleife ausgeliehen ist.</p>
<a class="header" href="Referenzen_Und_Ausleihen.html#benutzung-nach-einem-free" id="benutzung-nach-einem-free"><h3>Benutzung nach einem <code>free</code></h3></a>
<p>Referenzen dürfen nicht länger leben als die Ressource, die sie referenzieren.
Rust wird die Scopes deiner Referenzen überprüfen um sicherzustellen, dass
das gilt.</p>
<p>Wenn Rust diese Eigenschaft nicht prüfen würde, dann könnten wir
versehentlich eine ungültige Referenz verwenden.
Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let y: &amp;i32;
{ 
    let x = 5;
    y = &amp;x;
}

println!(&quot;{}&quot;, y);

#}</code></pre></pre>
<p>Wir erhalten diesen Fehler:</p>
<pre><code class="language-text">error: `x` does not live long enough
    y = &amp;x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &amp;i32;
{ 
    let x = 5;
    y = &amp;x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &amp;x;
}
</code></pre>
<p>In anderen Worten ist <code>y</code> nur für das Scope gültig, in dem <code>x</code> existiert.
Sobald <code>x</code> weggeht, ist es ungültig darauf zu verweisen.
Deswegen sagt der Fehler dass das <em>borrow</em> nicht lange genug lebt
[<code>does not live long enough</code>], da es nicht für die richtige Länge gültig ist.</p>
<p>Dasselbe Problem taucht auf, wenn eine Referenz vor der referenzierten Variable
deklariert wird:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let y: &amp;i32;
let x = 5;
y = &amp;x;

println!(&quot;{}&quot;, y);

#}</code></pre></pre>
<p>Wir erhalten diesen Fehler:</p>
<pre><code class="language-text">error: `x` does not live long enough
y = &amp;x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &amp;i32;
    let x = 5;
    y = &amp;x;
    
    println!(&quot;{}&quot;, y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &amp;x;
    
    println!(&quot;{}&quot;, y);
}
</code></pre>
<p>In dem oberen Beispiel wird <code>y</code> vor <code>x</code> deklariert, was bedeutet, dass <code>y</code>
länger lebt als <code>x</code>, was nicht erlaubt ist.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="Besitz.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="Lebensdauer.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="Besitz.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="Lebensdauer.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
