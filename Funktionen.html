<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Funktionen - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="Einführung.html"><strong>1.</strong> Einführung</a></li><li><a href="Erste_Schritte.html"><strong>2.</strong> Erste Schritte</a></li><li><ul class="section"><li><a href="Rust_Installieren.html"><strong>2.1.</strong> Rust installieren</a></li><li><a href="Hallo_Welt.html"><strong>2.2.</strong> Hallo Welt</a></li><li><a href="Hallo_Cargo.html"><strong>2.3.</strong> Hallo Cargo</a></li></ul></li><li><a href="Lerne_Rust.html"><strong>3.</strong> Lerne Rust</a></li><li><ul class="section"><li><a href="Ratespiel.html"><strong>3.1.</strong> Ratespiel</a></li><li><a href="Speisende_Philosophen.html"><strong>3.2.</strong> Speisende Philosophen</a></li><li><a href="Rust_In_Anderen_Sprachen.html"><strong>3.3.</strong> Rust in anderen Sprachen</a></li></ul></li><li><a href="Effektives_Rust.html"><strong>4.</strong> Effektives Rust</a></li><li><ul class="section"><li><a href="Der_Stack_Und_Der_Heap.html"><strong>4.1.</strong> Der Stack und der Heap</a></li><li><a href="Testen.html"><strong>4.2.</strong> Testen</a></li><li><a href="Bedingte_Kompilierung.html"><strong>4.3.</strong> Bedingte Kompilierung</a></li><li><a href="Dokumentation.html"><strong>4.4.</strong> Dokumentation</a></li><li><a href="Iteratoren.html"><strong>4.5.</strong> Iteratoren</a></li><li><a href="Nebenläufigkeit.html"><strong>4.6.</strong> Nebenläufigkeit</a></li><li><a href="Fehlerbehandlung.html"><strong>4.7.</strong> Fehlerbehandlung</a></li><li><a href="Garantien_Wählen.html"><strong>4.8.</strong> Garantien Wählen</a></li><li><a href="FFI.html"><strong>4.9.</strong> FFI</a></li><li><a href="Borrow_Und_AsRef.html"><strong>4.10.</strong> Borrow und AsRef</a></li><li><a href="Release_Kanäle.html"><strong>4.11.</strong> Release Kanäle</a></li></ul></li><li><a href="Syntax_Und_Semantik.html"><strong>5.</strong> Syntax und Semantik</a></li><li><ul class="section"><li><a href="Variablenbindung.html"><strong>5.1.</strong> Variablenbindung</a></li><li><a href="Funktionen.html" class="active"><strong>5.2.</strong> Funktionen</a></li><li><a href="Primitive_Typen.html"><strong>5.3.</strong> Primitive Typen</a></li><li><a href="Kommentare.html"><strong>5.4.</strong> Kommentare</a></li><li><a href="If.html"><strong>5.5.</strong> if</a></li><li><a href="Schleifen.html"><strong>5.6.</strong> Schleifen</a></li><li><a href="Besitz.html"><strong>5.7.</strong> Besitz</a></li><li><a href="Referenzen_Und_Ausleihen.html"><strong>5.8.</strong> Referenzen und Ausleihen</a></li><li><a href="Lebensdauer.html"><strong>5.9.</strong> Lebensdauer</a></li><li><a href="Veränderbarkeit.html"><strong>5.10.</strong> Veränderbarkeit</a></li><li><a href="Structs.html"><strong>5.11.</strong> Structs</a></li><li><a href="Enums.html"><strong>5.12.</strong> Enums</a></li><li><a href="Match.html"><strong>5.13.</strong> Match</a></li><li><a href="Muster.html"><strong>5.14.</strong> Muster</a></li><li><a href="Methodensyntax.html"><strong>5.15.</strong> Methodensyntax</a></li><li><a href="Vektoren.html"><strong>5.16.</strong> Vektoren</a></li><li><a href="Strings.html"><strong>5.17.</strong> Strings</a></li><li><a href="Generics.html"><strong>5.18.</strong> Generics</a></li><li><a href="Traits.html"><strong>5.19.</strong> Traits</a></li><li><a href="Drop.html"><strong>5.20.</strong> Drop</a></li><li><a href="If_Let.html"><strong>5.21.</strong> if let</a></li><li><a href="Trait_Objekte.html"><strong>5.22.</strong> Trait Objekte</a></li><li><a href="Closures.html"><strong>5.23.</strong> Closures</a></li><li><a href="UFCS.html"><strong>5.24.</strong> Universal Function Call Syntax</a></li><li><a href="Crates_Und_Module.html"><strong>5.25.</strong> Crates und Module</a></li><li><a href="Const_Und_Static.html"><strong>5.26.</strong> <code>const</code> und <code>static</code></a></li><li><a href="Attribute.html"><strong>5.27.</strong> Attribute</a></li><li><a href="Type_Aliase.html"><strong>5.28.</strong> <code>type</code> Aliase</a></li><li><a href="Zwischen_Typen_Umwandeln.html"><strong>5.29.</strong> Zwischen typen umwandeln</a></li><li><a href="Assoziierte_Typen.html"><strong>5.30.</strong> Assoziierte Typen</a></li><li><a href="Größenlose_Typen.html"><strong>5.31.</strong> Größenlose Typen</a></li><li><a href="Operatoren_Und_Überladen.html"><strong>5.32.</strong> Operatoren und Überladen</a></li><li><a href="Deref_Umwandlung.html"><strong>5.33.</strong> Deref Umwandlung</a></li><li><a href="Makros.html"><strong>5.34.</strong> Makros</a></li><li><a href="Raw_Zeiger.html"><strong>5.35.</strong> Raw Zeiger</a></li><li><a href="Unsafe.html"><strong>5.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="Nightly_Rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="Compiler_Plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="Inline_Assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="No_Stdlib.html"><strong>6.3.</strong> <code>no_stdlib</code></a></li><li><a href="Intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="Lang_Items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="Fortgeschrittenes_Linken.html"><strong>6.6.</strong> Fortgeschrittenes Linken</a></li><li><a href="Benchmark_Tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="Box_Syntax_Und_Muster.html"><strong>6.8.</strong> Box Syntax und Muster</a></li><li><a href="Slice_Muster.html"><strong>6.9.</strong> Slice Muster</a></li><li><a href="Assoziierte_Konstanten.html"><strong>6.10.</strong> Assoziierte Konstanten</a></li></ul></li><li><a href="Glossar.html"><strong>7.</strong> Glossar</a></li><li><a href="Akademische_Forschung.html"><strong>8.</strong> Akademische Forschung</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="Funktionen.html#funktionen" id="funktionen"><h1>Funktionen</h1></a>
<p>Jedes Rust Programm hat mindestens eine Funktion,
die <code>main</code> Funktion:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
}
</code></pre></pre>
<p>Das ist die simpelste Funktionsdeklaration. Wie wir zuvor schon erwähnt haben,
leitet <code>fn</code> eine Funktion ein. Darauf folgt der Name und
ein leeres paar Klammern, da diese Funktion keine Argumente hat,
und ein paar geschweifte Klammern, die den Funktionskörper repräsentieren.
Hier ist eine Funktion namens <code>foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo() {
}

#}</code></pre></pre>
<p>Ok, wie funktioniert das nun mit Argumenten? Hier eine Funktion,
die eine Zahl ausgibt:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}

#}</code></pre></pre>
<p>Hier ist ein vollständiges Programm, welches <code>print_number</code> verwendet:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}
</code></pre></pre>
<p>Wie du sehen kannst funktionieren Funktionsargumente
ähnlich wie <code>let</code> Deklarationen:
Man fügt dem Namen einen Typ durch ein Doppelpunkt hinzu.</p>
<p>Hier ist ein vollständiges Programm,
welches zwei Zahlen addiert und dann ausgibt:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!(&quot;sum is: {}&quot;, x + y);
}
</code></pre></pre>
<p>Wie du siehst werden Argumente durch ein Komma getrennt.
Das gilt sowohl für den Aufruf als auch für die Deklaration von Funktionen.</p>
<p>Anders als bei <code>let</code>, <strong>musst</strong> du die Typen von Funktionsargumenten angeben.
Das hier funktioniert nicht:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn print_sum(x, y) {
    println!(&quot;sum is: {}&quot;, x + y);
}

#}</code></pre></pre>
<pre><code>
Man bekommt diesen Fehler:

```text
expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
</code></pre>
<p>Das ist eine bewusste Designentscheidung.
Obwohl das Herleiten der Typen eines kompletten Programmes möglich ist,
wie zum Beispiel in Sprachen wie Haskell, wird dennoch häufig dazu geraten
die Typen ausdrücklich zu dokumentieren.
Wir stimmen zu, dass ausdrückliche Typvermerke in Funktionssignaturen
und Typherleitung innerhalb von Funktionskörpern
wundervoller Mittelweg ist.</p>
<p>Wie gibt man einen Wert zurück?
Hier ist eine Funktion, die einen Wert inkrementiert.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#}</code></pre></pre>
<p>Rust Funktionen geben genau einen Wert zurück. Diesen gibt man nach einem
&quot;Pfeil&quot; an, welcher aus einem Bindestrich (<code>-</code>), gefolgt von einem
Größer-Gleich Zeichen (<code>&gt;</code>) besteht.
Die letzte Zeile der Funktion ist automatisch der Rückgabewert der Funktion.
Du wirst sehen, dass hier das Semikolon fehlt. Wenn wir es hinzufügen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn add_one(x: i32) -&gt; i32 {
    x + 1;
}

#}</code></pre></pre>
<p>Würden wir einen Fehler bekommen:</p>
<pre><code class="language-text">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</code></pre>
<p>Dies offenbart zwei interessante Aspekte von Rust:
Rust ist eine ausdrucksorientierte Sprache [expression-based language].
Es gibt nur zwei Arten von Anweisungen, alles andere ist ein Ausdruck.</p>
<p>Also worin liegt der Unterschied? Ausdrücke geben einen Wert zurück,
Anweisungen nicht. Deswegen bekommen wir hier eine
‘not all control paths return a value’ Meldung:
Die Anweisung <code>x + 1;</code> gibt keinen Wert zurück.
Es gibt zwei Arten von Anweisungen in Rust:
<code>Deklarations-Anweisungen</code> und <code>Ausdrucks-Anweisungen</code>.
Alles andere ist ein Ausdruck.
Lass uns zuerst über <em>Deklarations-Anweisungen</em> sprechen.</p>
<p>In manchen Sprachen können Variablenbindungen auch als Ausdruck geschrieben
werden. Wie z.B. in Ruby:</p>
<pre><code class="language-ruby">x = y = 5
</code></pre>
<p>In Rust jedoch ist die Variablenbindung mit <code>let</code> <em>kein</em> Ausdruck.
Das Folgende erzeugt einen Fehler beim Kompilieren:</p>
<pre><code class="language-text">let x = (let y = 5); // expected identifier, found keyword `let`
</code></pre>
<p>Der Compiler sagt uns hier, dass er den Beginn eines Ausdrucks erwartet hat,
denn ein <code>let</code> kann nur eine Anweisung einleiten, aber keinen Ausdruck.</p>
<p>Beachte, dass eine Zuweisung an eine bereits gebundene Variable (z.B. <code>y = 5</code>)
trotzdem ein Ausdruck ist, auch wenn dieser nicht besonders nützlich ist.
Anders als in anderen Sprachen, wo der zugewiesene Wert zurückgegeben
werden würde, wird in Rust stattdessen das leere Tupel <code>()</code> zurückgegeben.
Der Grund dafür ist, dass der zugewiesene Wert <a href="Besitz.html">nur einen Besitzer</a>
haben kann und einen anderen Wert zurückzugeben wäre zu überraschend:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut y = 5;

let x = (y = 6);  // x has the value `()`, not `6`

#}</code></pre></pre>
<p>Die zweite Art von Anweisung in Rust ist die <em>Ausdrucks-Anweisung</em>.
Ihr Zweck ist es jeden Ausdruck in eine Anweisung zu verwandeln.
In praktischer Hinsicht erwartet Rusts Grammatik, dass Anweisungen
aufeinander folgen. Das bedeutet, dass man Semikolons nutzt um
Ausdrücke voneinander zu trennen. Das bedeutet auch,
dass Rust anderen Sprachen, welche auch ein Semikolon am Ende einer Zeile
haben, sehr ähnlich sieht und man in Rust fast an jedem Ende einer Zeile ein
Semikolon sieht.</p>
<p>Wegen welcher Ausnahme sagen wir &quot;fast&quot;?.
Du hast sie bereits gesehen und zwar in diesem Code:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#}</code></pre></pre>
<p>Unsere Funktion gibt an ein <code>i32</code> zurückzugeben, aber mit einem Semikolon
würden wir stattdessen <code>()</code> zurückgeben.
Rust versteht, dass wir das wahrscheinlich nicht wollten und schlägt uns in
der Fehlermeldung, die wir sahen, vor das Semikolon zu entfernen.</p>
<a class="header" href="Funktionen.html#frühzeitige-rückgabe" id="frühzeitige-rückgabe"><h2>Frühzeitige Rückgabe</h2></a>
<p>Was ist mit frühzeitiger Rückgabe [early returns]?
Rust hat dafür ein Schlpsselwort namens <code>return</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) -&gt; i32 {
    return x;

    // we never run this code!
    x + 1
}

#}</code></pre></pre>
<p><code>return</code> in der letzten Zeile einer Funktion zu verwenden funktioniert zwar,
aber wird als schlechter Stil angesehen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) -&gt; i32 {
    return x + 1;
}

#}</code></pre></pre>
<p>Die vorherige Definition ohne <code>return</code> sieht vielleicht etwas komisch für dich
aus, falls du noch nicht mit ausdrucksorientierten Sprachen gearbeitet hast,
aber du wirst dich mit der Zeit daran gewöhnen.</p>
<a class="header" href="Funktionen.html#divergierende-funktionde" id="divergierende-funktionde"><h2>Divergierende Funktionde</h2></a>
<p>Rust hat eine spezielle Syntax für sogennannte ‘divergierende Funktionen’
[diverging functions], also Funktionen, die niemals zurückkehren:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn diverges() -&gt; ! {
    panic!(&quot;This function never returns!&quot;);
}

#}</code></pre></pre>
<p><code>panic!()</code> ist ein Makro, ähnlich wie <code>println!()</code>, was wir bereits kennen.
Anders jedoch als <code>println!()</code> sorgt <code>panic!()</code> dafür, dass der aktuelle
Thread mit einer Fehlermeldung abstürzt. Weil diese Funktion einen Crash hervorruft, kehrt sie niemals zurück, deswegen hat sie den Typ ‘<code>!</code>’,
was man als ‘divergiert’ liest.</p>
<p>Wenn du zu einer main Funktion einen <code>diverges()</code> Aufruf hinzufügst
und das Programm ausführst, dann sieht die Ausgabe in etwa so aus:</p>
<pre><code class="language-text">thread ‘&lt;main&gt;’ panicked at ‘This function never returns!’, hello.rs:2
</code></pre>
<p>Wenn du mehr Informationen haben willst, dann kannst du einen Backtrace durch
Setzen der <code>RUST_BACKTRACE</code> Umgebungsvariable erhalten:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 ./diverges
thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p><code>RUST_BACKTRACE</code> funktioniert auch mit Cargos <code>run</code> Befehl:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
     Running `target/debug/diverges`
thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p>Divergierende Funktionen passen mit jedem Typen zusammen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x: i32 = diverges();
let x: String = diverges();

#}</code></pre></pre>
<a class="header" href="Funktionen.html#funktionszeiger" id="funktionszeiger"><h2>Funktionszeiger</h2></a>
<p>Wir können auch eine Variablenbindung erzeugen, die auf eine Funktion zeigt:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let f: fn(i32) -&gt; i32;

#}</code></pre></pre>
<p><code>f</code> ist eine Variable, die auf eine Funktion zeigt, welche ein <code>i32</code> als
Argument entgegennimmt und ein <code>i32</code> zurückgibt. Zum Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn plus_one(i: i32) -&gt; i32 {
    i + 1
}

// without type inference
let f: fn(i32) -&gt; i32 = plus_one;

// with type inference
let f = plus_one;

#}</code></pre></pre>
<p>Wir können dann <code>f</code> benutzen um die Funktion aufzurufen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let six = f(5);

#}</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="Variablenbindung.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="Primitive_Typen.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="Variablenbindung.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="Primitive_Typen.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
