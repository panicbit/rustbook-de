<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Schleifen - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="Einführung.html"><strong>1.</strong> Einführung</a></li><li><a href="Erste_Schritte.html"><strong>2.</strong> Erste Schritte</a></li><li><ul class="section"><li><a href="Rust_Installieren.html"><strong>2.1.</strong> Rust installieren</a></li><li><a href="Hallo_Welt.html"><strong>2.2.</strong> Hallo Welt</a></li><li><a href="Hallo_Cargo.html"><strong>2.3.</strong> Hallo Cargo</a></li></ul></li><li><a href="Lerne_Rust.html"><strong>3.</strong> Lerne Rust</a></li><li><ul class="section"><li><a href="Ratespiel.html"><strong>3.1.</strong> Ratespiel</a></li><li><a href="Speisende_Philosophen.html"><strong>3.2.</strong> Speisende Philosophen</a></li><li><a href="Rust_In_Anderen_Sprachen.html"><strong>3.3.</strong> Rust in anderen Sprachen</a></li></ul></li><li><a href="Effektives_Rust.html"><strong>4.</strong> Effektives Rust</a></li><li><ul class="section"><li><a href="Der_Stack_Und_Der_Heap.html"><strong>4.1.</strong> Der Stack und der Heap</a></li><li><a href="Testen.html"><strong>4.2.</strong> Testen</a></li><li><a href="Bedingte_Kompilierung.html"><strong>4.3.</strong> Bedingte Kompilierung</a></li><li><a href="Dokumentation.html"><strong>4.4.</strong> Dokumentation</a></li><li><a href="Iteratoren.html"><strong>4.5.</strong> Iteratoren</a></li><li><a href="Nebenläufigkeit.html"><strong>4.6.</strong> Nebenläufigkeit</a></li><li><a href="Fehlerbehandlung.html"><strong>4.7.</strong> Fehlerbehandlung</a></li><li><a href="Garantien_Wählen.html"><strong>4.8.</strong> Garantien Wählen</a></li><li><a href="FFI.html"><strong>4.9.</strong> FFI</a></li><li><a href="Borrow_Und_AsRef.html"><strong>4.10.</strong> Borrow und AsRef</a></li><li><a href="Release_Kanäle.html"><strong>4.11.</strong> Release Kanäle</a></li></ul></li><li><a href="Syntax_Und_Semantik.html"><strong>5.</strong> Syntax und Semantik</a></li><li><ul class="section"><li><a href="Variablenbindung.html"><strong>5.1.</strong> Variablenbindung</a></li><li><a href="Funktionen.html"><strong>5.2.</strong> Funktionen</a></li><li><a href="Primitive_Typen.html"><strong>5.3.</strong> Primitive Typen</a></li><li><a href="Kommentare.html"><strong>5.4.</strong> Kommentare</a></li><li><a href="If.html"><strong>5.5.</strong> if</a></li><li><a href="Schleifen.html" class="active"><strong>5.6.</strong> Schleifen</a></li><li><a href="Besitz.html"><strong>5.7.</strong> Besitz</a></li><li><a href="Referenzen_Und_Ausleihen.html"><strong>5.8.</strong> Referenzen und Ausleihen</a></li><li><a href="Lebensdauer.html"><strong>5.9.</strong> Lebensdauer</a></li><li><a href="Veränderbarkeit.html"><strong>5.10.</strong> Veränderbarkeit</a></li><li><a href="Structs.html"><strong>5.11.</strong> Structs</a></li><li><a href="Enums.html"><strong>5.12.</strong> Enums</a></li><li><a href="Match.html"><strong>5.13.</strong> Match</a></li><li><a href="Muster.html"><strong>5.14.</strong> Muster</a></li><li><a href="Methodensyntax.html"><strong>5.15.</strong> Methodensyntax</a></li><li><a href="Vektoren.html"><strong>5.16.</strong> Vektoren</a></li><li><a href="Strings.html"><strong>5.17.</strong> Strings</a></li><li><a href="Generics.html"><strong>5.18.</strong> Generics</a></li><li><a href="Traits.html"><strong>5.19.</strong> Traits</a></li><li><a href="Drop.html"><strong>5.20.</strong> Drop</a></li><li><a href="If_Let.html"><strong>5.21.</strong> if let</a></li><li><a href="Trait_Objekte.html"><strong>5.22.</strong> Trait Objekte</a></li><li><a href="Closures.html"><strong>5.23.</strong> Closures</a></li><li><a href="UFCS.html"><strong>5.24.</strong> Universal Function Call Syntax</a></li><li><a href="Crates_Und_Module.html"><strong>5.25.</strong> Crates und Module</a></li><li><a href="Const_Und_Static.html"><strong>5.26.</strong> <code>const</code> und <code>static</code></a></li><li><a href="Attribute.html"><strong>5.27.</strong> Attribute</a></li><li><a href="Type_Aliase.html"><strong>5.28.</strong> <code>type</code> Aliase</a></li><li><a href="Zwischen_Typen_Umwandeln.html"><strong>5.29.</strong> Zwischen typen umwandeln</a></li><li><a href="Assoziierte_Typen.html"><strong>5.30.</strong> Assoziierte Typen</a></li><li><a href="Größenlose_Typen.html"><strong>5.31.</strong> Größenlose Typen</a></li><li><a href="Operatoren_Und_Überladen.html"><strong>5.32.</strong> Operatoren und Überladen</a></li><li><a href="Deref_Umwandlung.html"><strong>5.33.</strong> Deref Umwandlung</a></li><li><a href="Makros.html"><strong>5.34.</strong> Makros</a></li><li><a href="Raw_Zeiger.html"><strong>5.35.</strong> Raw Zeiger</a></li><li><a href="Unsafe.html"><strong>5.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="Nightly_Rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="Compiler_Plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="Inline_Assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="No_Stdlib.html"><strong>6.3.</strong> <code>no_stdlib</code></a></li><li><a href="Intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="Lang_Items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="Fortgeschrittenes_Linken.html"><strong>6.6.</strong> Fortgeschrittenes Linken</a></li><li><a href="Benchmark_Tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="Box_Syntax_Und_Muster.html"><strong>6.8.</strong> Box Syntax und Muster</a></li><li><a href="Slice_Muster.html"><strong>6.9.</strong> Slice Muster</a></li><li><a href="Assoziierte_Konstanten.html"><strong>6.10.</strong> Assoziierte Konstanten</a></li></ul></li><li><a href="Glossar.html"><strong>7.</strong> Glossar</a></li><li><a href="Akademische_Forschung.html"><strong>8.</strong> Akademische Forschung</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="Schleifen.html#schleifen" id="schleifen"><h1>Schleifen</h1></a>
<p>Rust bietet drei verschiedene Herangehensweisen eine iterative
Tätigkeit auszuführen. Es gibt: <code>loop</code>, <code>while</code> und <code>for</code>.
Jede dieser Herangehensweisen hat seine eigenen Anwendungsfälle.</p>
<a class="header" href="Schleifen.html#loop" id="loop"><h2>loop</h2></a>
<p>Die Endlosschleife <code>loop</code> ist die simpelste Schleifenform, die es in Rust gibt.
Mithilfe des <code>loop</code> Schlüsselwortes bietet uns Rust einen Weg an für eine
unbestimmte Zeit zu iterieren, bis wir irgendwann eine terminierende Anweisung
erreichen.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
loop {
    println!(&quot;Loop forever!&quot;);
}

#}</code></pre></pre>
<a class="header" href="Schleifen.html#while" id="while"><h2>while</h2></a>
<p>Rust hat auch eine <code>while</code> Schleife. Sie sieht zum Beispiel so aus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}

#}</code></pre></pre>
<p><code>while</code> Schleifen sind die richtige Wahl, wenn du nicht sicher bist,
wie häufig etwas wiederholt werden muss.</p>
<p>Wenn du eine Endlosschleife benötigst,
dann bist du vielleicht dazu verleitet das hier zu schreiben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
while true {

#}</code></pre></pre>
<p>Es ist jedoch besser in diesem Fall <code>loop</code> zu verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
loop {

#}</code></pre></pre>
<p>Rusts Kontrollflussanalyse behandelt diese Konstrukt anders als <code>while true</code>,
da es weiß, dass die Schleife endlos ist. Allgemein gilt, je mehr
Informationen wir dem Compiler geben können, umso bessere Sicherheit und
Code-Erzeugung erhalten wir. Deswegen solltest du immer <code>loop</code> vorziehen,
falls du planst endlos zu iterieren.</p>
<a class="header" href="Schleifen.html#for" id="for"><h2>for</h2></a>
<p>Die <code>for</code> Schleife wird benutzt um eine bestimmte Anzahl von Iterationen
auszuführen. Rusts <code>for</code> Schleifen arbeiten jedoch ein wenig anders als in
anderen Systemsprachen. Rusts <code>for</code> Schleifen sehen <em>nicht</em> aus wie &quot;C-Style&quot;
<code>for</code> Schleifen:</p>
<pre><code class="language-c">for (x = 0; x &lt; 10; x++) {
    printf( &quot;%d\n&quot;, x );
}
</code></pre>
<p>Stattdessen sehen sie so aus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    println!(&quot;{}&quot;, x); // x: i32
}

#}</code></pre></pre>
<p>In etwas abstrakteren Begriffen:</p>
<pre><code>for var in expression {
    code
}
</code></pre>
<p>Der Ausdruck ist ein <a href="Iteratoren.html">Iterator</a>. Der Iterator gibt eine Reihe von
Elementen zurück. Jedes Element ist eine Iteration der Schleife. Dieses Element
wird an den Namen <code>var</code> gebunden, welcher für den Schleifenkörper gültig ist.
Sobald der Körper beendet ist, wird der nächste Wert aus dem Iterator geholt
und der Schleifenkörper damit erneut ausgefürt. Wenn es keine weiteren
Werte mehr gibt, dann ist die <code>for</code> Schleife vorbei.</p>
<p>In unserem Beispiel ist <code>0..10</code> ein Ausdruck, welche eine Start- und eine
Endposition hat und einen Iterator über diese Werte zurückgibt.
Das obere Ende ist jedoch exklusiv, also gibt unsere Schleife nur
<code>0</code> bis <code>9</code>, jedoch nicht <code>10</code> aus.</p>
<p>Rust hat bewusst keine &quot;C-Style&quot; <code>for</code> Schleifen.
Jedes Element der Schleife manuell zu kontrollieren ist kompliziert und
fehleranfällig, sogar für erfahrene C-Entwickler.</p>
<a class="header" href="Schleifen.html#enumerate" id="enumerate"><h3>Enumerate</h3></a>
<p>Wenn du gerne wüsstest wie oft du schon iteriert hast, kannst du die
<code>.enumerate()</code> Funktion verwenden.</p>
<a class="header" href="Schleifen.html#bei-ranges" id="bei-ranges"><h4>Bei <code>range</code>s:</h4></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for (i,j) in (5..10).enumerate() {
    println!(&quot;i = {} and j = {}&quot;, i, j);
}

#}</code></pre></pre>
<p>Ausgabe:</p>
<pre><code class="language-text">i = 0 and j = 5
i = 1 and j = 6
i = 2 and j = 7
i = 3 and j = 8
i = 4 and j = 9
</code></pre>
<p>Vergiss nicht die Klammern um den <code>Range</code></p>
<a class="header" href="Schleifen.html#bei-iteratoren" id="bei-iteratoren"><h4>Bei Iteratoren:</h4></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for (linenumber, line) in lines.enumerate() {
    println!(&quot;{}: {}&quot;, linenumber, line);
}

#}</code></pre></pre>
<!-- Original:
# let lines = "hello\nworld".lines();
for (linenumber, line) in lines.enumerate() {
    println!("{}: {}", linenumber, line);
}
-->
<p>Ausgabe:</p>
<pre><code class="language-text">0: Content of line one
1: Content of line two
2: Content of line three
3: Content of line four
</code></pre>
<a class="header" href="Schleifen.html#die-iteration-frühzeitig-beenden" id="die-iteration-frühzeitig-beenden"><h2>Die Iteration frühzeitig beenden</h2></a>
<p>Lass uns einen Blick auf die <code>while</code> Schleife von zuvor werfen:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let mut done = false;

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}

#}</code></pre></pre>
<p>Wir mussten eine boolsche <code>mut</code> Variable <code>done</code> verwenden um die Schleife
zu beenden. Rust hat zwei Schüsselwörter, die uns helfen eine Iteration zu
modifizieren: <code>break</code> und <code>continue</code>.</p>
<p>In diesem Fall können wir die Schleife mittels <code>break</code> verbessern:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let mut x = 5;

loop {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 { break; }
}

#}</code></pre></pre>
<p>Wir iterieren nun endlos und benutzen <code>break</code> um frühzeitig aus der Schleife
auszubrechen. Eine explizite <code>return</code> Anweisung würde die Schleife ebenso
frühzeitig beenden.</p>
<p><code>continue</code> ist ähnlich, aber anstatt die Schleife zu beenden,
geht man damit zur nächsten Iteration.
Das hier wird nur ungerade Zahlen ausgeben:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    if x % 2 == 0 { continue; }

    println!(&quot;{}&quot;, x);
}

#}</code></pre></pre>
<a class="header" href="Schleifen.html#schleifen-label" id="schleifen-label"><h2>Schleifen Label</h2></a>
<p>Es könnte sein, dass du in bestimmten Situationen verschachtelte Schleifen
hast und festlegen willst für welche dein <code>break</code> oder <code>continue</code> gelten soll.
Wir bei den meisten anderen Sprache, gelten <code>break</code> und <code>continue</code>
standardmäßig nur für die innerste Schleife.
Wenn du allerdings <code>break</code> oder <code>continue</code> auf eine äußere Schleife anwenden
möchtest, dann kannst du Label verwenden um das festzulegen.
Der folgende Code wird nur etwas ausgeben,
wenn sowohl <code>x</code> als auch <code>y</code> ungerade sind.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // continues the loop over x
        if y % 2 == 0 { continue 'inner; } // continues the loop over y
        println!(&quot;x: {}, y: {}&quot;, x, y);
    }
}

#}</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="If.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="Besitz.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="If.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="Besitz.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
